{"nodes":[{"pos":[1314,1378],"content":"Defines the underlying structure of all code access permissions.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines the underlying structure of all code access permissions.","pos":[0,64]}]},{"pos":[1391,2250],"content":"Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission. If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState?displayProperty=fullName>.       The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.       Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure. To determine that the inheritors are fully trusted, CodeAccessPermission issues an <xref:System.Security.Permissions.SecurityAction> for <xref:System.Security.Permissions.SecurityPermissionFlag> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag> = `true`.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.","pos":[0,111]},{"content":"If a permission object is <ph id=\"ph1\">`null`</ph>, it is handled the same as a permission object with the state &lt;xref:System.Security.Permissions.PermissionState?displayProperty=fullName&gt;.","pos":[112,283],"source":" If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState?displayProperty=fullName>."},{"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","pos":[290,425]},{"content":"Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure.","pos":[432,579]},{"content":"To determine that the inheritors are fully trusted, CodeAccessPermission issues an &lt;xref:System.Security.Permissions.SecurityAction&gt; for &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id=\"ph1\">`true`</ph> and &lt;xref:System.Security.Permissions.SecurityPermissionFlag&gt; = <ph id=\"ph2\">`true`</ph>.","pos":[580,855],"source":" To determine that the inheritors are fully trusted, CodeAccessPermission issues an <xref:System.Security.Permissions.SecurityAction> for <xref:System.Security.Permissions.SecurityPermissionFlag> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag> = `true`."}]},{"pos":[3448,3546],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.CodeAccessPermission\"></xref> class."},{"pos":[3558,3877],"content":"This constructor is called to initialize state in the type whenever an instance of the derived class is created. Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"This constructor is called to initialize state in the type whenever an instance of the derived class is created. Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.","pos":[0,319],"nodes":[{"content":"This constructor is called to initialize state in the type whenever an instance of the derived class is created.","pos":[0,112]},{"content":"Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.","pos":[113,319]}]}]},{"pos":[4385,4647],"content":"Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource. Using Assert can create security issues.","needQuote":true,"needEscape":true,"nodes":[{"content":"Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource. Using Assert can create security issues.","pos":[0,262],"nodes":[{"content":"Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.","pos":[0,221]},{"content":"Using Assert can create security issues.","pos":[222,262]}]}]},{"pos":[4660,6434],"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method. Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission. An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.       The call to Assert is effective until the calling code returns to its caller. Only one Assert can be active on a frame. An attempt to call Assert when an active Assert exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Assert.       Assert is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call Assert. This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.      > [!CAUTION] >  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately. Therefore, it should be used with great caution.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","pos":[0,135]},{"content":"Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.","pos":[136,282]},{"content":"Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.","pos":[283,488]},{"content":"An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.","pos":[489,616]},{"content":"The call to Assert is effective until the calling code returns to its caller.","pos":[623,700]},{"content":"Only one Assert can be active on a frame.","pos":[701,742]},{"content":"An attempt to call Assert when an active Assert exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.","pos":[743,865],"source":" An attempt to call Assert when an active Assert exists on the frame results in a <xref:System.Security.SecurityException>."},{"content":"Call &lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Assert.","pos":[866,1018],"source":" Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Assert."},{"content":"Assert is ignored for a permission not granted because a demand for that permission will not succeed.","pos":[1025,1126]},{"content":"However, if code lower on the call stack calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call Assert.","pos":[1127,1365],"source":" However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call Assert."},{"content":"This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.","pos":[1366,1486]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.","pos":[1492,1718],"source":"      > [!CAUTION] >  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately."},{"content":"Therefore, it should be used with great caution.","pos":[1719,1767]}]},{"pos":[6685,6868],"content":"The calling code does not have <xref href=\"System.Security.Permissions.SecurityPermissionFlag\"></xref>.       -or-       There is already an active Assert for the current frame.","needQuote":false,"needEscape":true,"nodes":[{"content":"The calling code does not have <bpt id=\"p1\">&lt;xref href=\"System.Security.Permissions.SecurityPermissionFlag\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,103],"source":"The calling code does not have <xref href=\"System.Security.Permissions.SecurityPermissionFlag\"></xref>."},{"content":"-or-       There is already an active Assert for the current frame.","pos":[110,177]}]},{"pos":[7217,7325],"content":"When implemented by a derived class, creates and returns an identical copy of the current permission object.","needQuote":true,"needEscape":true,"nodes":[{"content":"When implemented by a derived class, creates and returns an identical copy of the current permission object.","pos":[0,108]}]},{"pos":[7337,7441],"content":"A copy of a permission object represents the same access to resources as the original permission object.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"A copy of a permission object represents the same access to resources as the original permission object.","pos":[0,104]}]},{"pos":[8171,8211],"content":"A copy of the current permission object.","needQuote":true,"needEscape":true,"nodes":[{"content":"A copy of the current permission object.","pos":[0,40]}]},{"pos":[8641,8814],"content":"Forces a <xref:System.Security.SecurityException> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.","needQuote":true,"needEscape":true,"nodes":[{"content":"Forces a &lt;xref:System.Security.SecurityException&gt; at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.","pos":[0,173],"source":"Forces a <xref:System.Security.SecurityException> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance."}]},{"pos":[8827,9507],"content":"This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls Demand for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.       The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Demand succeeds only if no <xref:System.Security.SecurityException> is raised.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls Demand for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.       The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Demand succeeds only if no <xref:System.Security.SecurityException> is raised.","pos":[0,678],"nodes":[{"content":"This method is typically used by secure libraries to ensure that callers have permission to access a resource.","pos":[0,110]},{"content":"For example, a file class in a secure class library calls Demand for the necessary &lt;xref:System.Security.Permissions.FileIOPermission&gt; before performing a file operation requested by the caller.","pos":[111,305],"source":" For example, a file class in a secure class library calls Demand for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller."},{"content":"The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.","pos":[312,463]},{"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","pos":[464,599]},{"content":"Demand succeeds only if no &lt;xref:System.Security.SecurityException&gt; is raised.","pos":[600,678],"source":" Demand succeeds only if no <xref:System.Security.SecurityException> is raised."}]}]},{"pos":[9758,10005],"content":"A caller higher in the call stack does not have the permission specified by the current instance.       -or-       A caller higher in the call stack has called <xref:System.Security.CodeAccessPermission.Deny*> on the current permission object.","needQuote":false,"needEscape":true,"nodes":[{"content":"A caller higher in the call stack does not have the permission specified by the current instance.       -or-       A caller higher in the call stack has called <xref:System.Security.CodeAccessPermission.Deny*> on the current permission object.","pos":[0,243],"nodes":[{"content":"A caller higher in the call stack does not have the permission specified by the current instance.","pos":[0,97]},{"content":"-or-       A caller higher in the call stack has called &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; on the current permission object.","pos":[104,243],"source":"       -or-       A caller higher in the call stack has called <xref:System.Security.CodeAccessPermission.Deny*> on the current permission object."}]}]},{"pos":[10354,10496],"content":"Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.","needQuote":true,"needEscape":true,"nodes":[{"content":"Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.","pos":[0,142]}]},{"pos":[10509,12819],"content":"> [!IMPORTANT] >  The Deny method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method `A` issues a Deny for a permission and then calls method `B`, method `B` can overtly override the Deny by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>. The called method is always higher in the stack. Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no Deny or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack. Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method. In that case, the Deny placed on the stack by method `A` (the calling method) is never discovered.       This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.       Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission. If a method calls Deny on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.       The call to Deny is effective until the calling code returns to its caller. Only one Deny can be active on a frame. An attempt to call Deny when an active Deny exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Deny. Deny is ignored for a permission not granted because a demand for that permission will not succeed.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"<ph id=\"ph1\">&gt; [!IMPORTANT]</ph> &gt;  The Deny method should be used only to protect resources from accidental access by fully trusted code.","pos":[0,120],"source":"> [!IMPORTANT] >  The Deny method should be used only to protect resources from accidental access by fully trusted code."},{"content":"It should not be used to protect resources from intentional misuse by untrusted code.","pos":[121,206]},{"content":"For example, if method <ph id=\"ph1\">`A`</ph> issues a Deny for a permission and then calls method <ph id=\"ph2\">`B`</ph>, method <ph id=\"ph3\">`B`</ph> can overtly override the Deny by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.","pos":[207,401],"source":" For example, if method `A` issues a Deny for a permission and then calls method `B`, method `B` can overtly override the Deny by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>."},{"content":"The called method is always higher in the stack.","pos":[402,450]},{"content":"Therefore, if method <ph id=\"ph1\">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id=\"ph2\">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no Deny or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; lower in the stack.","pos":[451,761],"source":" Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no Deny or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack."},{"content":"Method <ph id=\"ph1\">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.","pos":[762,924],"source":" Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method."},{"content":"In that case, the Deny placed on the stack by method <ph id=\"ph1\">`A`</ph> (the calling method) is never discovered.","pos":[925,1023],"source":" In that case, the Deny placed on the stack by method `A` (the calling method) is never discovered."},{"content":"This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.","pos":[1030,1227]},{"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","pos":[1228,1363]},{"content":"Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission.","pos":[1370,1586]},{"content":"If a method calls Deny on a permission, and if a &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.","pos":[1587,1813],"source":" If a method calls Deny on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny."},{"content":"The call to Deny is effective until the calling code returns to its caller.","pos":[1820,1895]},{"content":"Only one Deny can be active on a frame.","pos":[1896,1935]},{"content":"An attempt to call Deny when an active Deny exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.","pos":[1936,2054],"source":" An attempt to call Deny when an active Deny exists on the frame results in a <xref:System.Security.SecurityException>."},{"content":"Call &lt;xref:System.Security.CodeAccessPermission.RevertDeny%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active Deny.","pos":[2055,2203],"source":" Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Deny."},{"content":"Deny is ignored for a permission not granted because a demand for that permission will not succeed.","pos":[2204,2303]}]},{"pos":[13065,13119],"content":"There is already an active Deny for the current frame.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is already an active Deny for the current frame.","pos":[0,54]}]},{"pos":[13525,13705],"content":"Determines whether the specified <bpt id=\"p1\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object is equal to the current <bpt id=\"p2\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Determines whether the specified <xref href=\"System.Security.CodeAccessPermission\"></xref> object is equal to the current <xref href=\"System.Security.CodeAccessPermission\"></xref>."},{"pos":[13717,13774],"content":"For more information, see <xref:System.Object.Equals%2A>.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"For more information, see &lt;xref:System.Object.Equals%2A&gt;.","pos":[0,57],"source":"For more information, see <xref:System.Object.Equals%2A>."}]},{"pos":[13915,14070],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object to compare with the current <bpt id=\"p2\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Security.CodeAccessPermission\"></xref> object to compare with the current <xref href=\"System.Security.CodeAccessPermission\"></xref>."},{"pos":[14129,14429],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the specified <bpt id=\"p2\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> object is equal to the current <bpt id=\"p3\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p3\">&lt;/xref&gt;</ept>; otherwise, <bpt id=\"p4\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p4\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the specified <xref href=\"System.Security.CodeAccessPermission\"></xref> object is equal to the current <xref href=\"System.Security.CodeAccessPermission\"></xref>; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[14977,15088],"content":"When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.","pos":[0,111]}]},{"pos":[15100,15277],"content":"Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and FromXml methods to make the objects security-encodable.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Custom code that extends security objects needs to implement the &lt;xref:System.Security.CodeAccessPermission.ToXml%2A&gt; and FromXml methods to make the objects security-encodable.","pos":[0,177],"source":"Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and FromXml methods to make the objects security-encodable."}]},{"pos":[16033,16092],"content":"The XML encoding to use to reconstruct the security object.","needQuote":true,"needEscape":true,"nodes":[{"content":"The XML encoding to use to reconstruct the security object.","pos":[0,59]}]},{"pos":[16267,16363],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">elem</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <code>elem</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[16459,16675],"content":"The <code>elem</code> parameter does not contain the XML encoding for an instance of the same type as the current instance.       -or-       The version number of the <code>elem</code> parameter is not supported.","needQuote":false,"needEscape":true,"nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">elem</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter does not contain the XML encoding for an instance of the same type as the current instance.","pos":[0,123],"source":"The <code>elem</code> parameter does not contain the XML encoding for an instance of the same type as the current instance."},{"content":"-or-       The version number of the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">elem</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not supported.","pos":[130,212],"source":"       -or-       The version number of the <code>elem</code> parameter is not supported."}]},{"pos":[17059,17237],"content":"Gets a hash code for the <bpt id=\"p1\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that is suitable for use in hashing algorithms and data structures such as a hash table.","needQuote":true,"needEscape":true,"source":"Gets a hash code for the <xref href=\"System.Security.CodeAccessPermission\"></xref> object that is suitable for use in hashing algorithms and data structures such as a hash table."},{"pos":[17249,17428],"content":"The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two &lt;xref:System.Security.CodeAccessPermission&gt; objects.","pos":[0,179],"source":"The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects."}]},{"pos":[17563,17656],"content":"A hash code for the current <bpt id=\"p1\">&lt;xref href=\"System.Security.CodeAccessPermission\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object.","needQuote":true,"needEscape":true,"source":"A hash code for the current <xref href=\"System.Security.CodeAccessPermission\"></xref> object."},{"pos":[18199,18349],"content":"When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.","pos":[0,150]}]},{"pos":[18361,18559],"content":"The intersection of two permissions is a permission that describes the set of operations they both describe in common. Only a demand that passes both original permissions will pass the intersection.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The intersection of two permissions is a permission that describes the set of operations they both describe in common. Only a demand that passes both original permissions will pass the intersection.","pos":[0,198],"nodes":[{"content":"The intersection of two permissions is a permission that describes the set of operations they both describe in common.","pos":[0,118]},{"content":"Only a demand that passes both original permissions will pass the intersection.","pos":[119,198]}]}]},{"pos":[19335,19444],"content":"A permission to intersect with the current permission. It must be of the same type as the current permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"A permission to intersect with the current permission. It must be of the same type as the current permission.","pos":[0,109],"nodes":[{"content":"A permission to intersect with the current permission.","pos":[0,54]},{"content":"It must be of the same type as the current permission.","pos":[55,109]}]}]},{"pos":[19516,19735],"content":"A new permission that represents the intersection of the current permission and the specified permission. This new permission is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> if the intersection is empty.","needQuote":true,"needEscape":true,"nodes":[{"content":"A new permission that represents the intersection of the current permission and the specified permission.","pos":[0,105]},{"content":"This new permission is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the intersection is empty.","pos":[106,219],"source":" This new permission is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> if the intersection is empty."}]},{"pos":[19904,20073],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">target</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> and is not an instance of the same class as the current permission.","needQuote":true,"needEscape":true,"source":"The <code>target</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> and is not an instance of the same class as the current permission."},{"pos":[20542,20661],"content":"When implemented by a derived class, determines whether the current permission is a subset of the specified permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"When implemented by a derived class, determines whether the current permission is a subset of the specified permission.","pos":[0,119]}]},{"pos":[23022,23152],"content":"A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.","pos":[0,130],"nodes":[{"content":"A permission that is to be tested for the subset relationship.","pos":[0,62]},{"content":"This permission must be of the same type as the current permission.","pos":[63,130]}]}]},{"pos":[23211,23413],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the current permission is a subset of the specified permission; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current permission is a subset of the specified permission; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[23583,23739],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">target</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> and is not of the same type as the current permission.","needQuote":true,"needEscape":true,"source":"The <code>target</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> and is not of the same type as the current permission."},{"pos":[24117,24284],"content":"Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.","needQuote":true,"needEscape":true,"nodes":[{"content":"Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.","pos":[0,167]}]},{"pos":[24297,26890],"content":"> [!IMPORTANT] >  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method `A` issues a PermitOnly for a permission and then calls method `B`, method `B` can overtly override the PermitOnly by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>. The called method is always higher in the stack. Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or PermitOnly lower in the stack. Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method. In that case, the PermitOnly placed on the stack by method `A` (the calling method) is never discovered.       PermitOnly is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed. The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.       Call this method to ensure that your code can be used to access only the specified resources. The call to PermitOnly is effective until the calling code returns to its caller. Only one PermitOnly can be active on a frame. An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active PermitOnly.       PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call PermitOnly. This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"<ph id=\"ph1\">&gt; [!IMPORTANT]</ph> &gt;  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code.","pos":[0,126],"source":"> [!IMPORTANT] >  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code."},{"content":"It should not be used to protect resources from intentional misuse by untrusted code.","pos":[127,212]},{"content":"For example, if method <ph id=\"ph1\">`A`</ph> issues a PermitOnly for a permission and then calls method <ph id=\"ph2\">`B`</ph>, method <ph id=\"ph3\">`B`</ph> can overtly override the PermitOnly by issuing an &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;.","pos":[213,419],"source":" For example, if method `A` issues a PermitOnly for a permission and then calls method `B`, method `B` can overtly override the PermitOnly by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>."},{"content":"The called method is always higher in the stack.","pos":[420,468]},{"content":"Therefore, if method <ph id=\"ph1\">`B`</ph> tries to access a protected resource, the security system begins checking for permissions with it because method <ph id=\"ph2\">`B`</ph> is the immediate caller, and then walks down the stack to confirm that there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; or PermitOnly lower in the stack.","pos":[469,779],"source":" Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or PermitOnly lower in the stack."},{"content":"Method <ph id=\"ph1\">`B`</ph>, which is trying to access the resource, can stop the stack walk immediately by using the &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; method.","pos":[780,942],"source":" Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method."},{"content":"In that case, the PermitOnly placed on the stack by method <ph id=\"ph1\">`A`</ph> (the calling method) is never discovered.","pos":[943,1047],"source":" In that case, the PermitOnly placed on the stack by method `A` (the calling method) is never discovered."},{"content":"PermitOnly is similar to &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, in that both cause stack walks to fail when they would otherwise succeed.","pos":[1054,1205],"source":"       PermitOnly is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed."},{"content":"The difference is that &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.","pos":[1206,1430],"source":" The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail."},{"content":"Call this method to ensure that your code can be used to access only the specified resources.","pos":[1437,1530]},{"content":"The call to PermitOnly is effective until the calling code returns to its caller.","pos":[1531,1612]},{"content":"Only one PermitOnly can be active on a frame.","pos":[1613,1658]},{"content":"An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a &lt;xref:System.Security.SecurityException&gt;.","pos":[1659,1789],"source":" An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a <xref:System.Security.SecurityException>."},{"content":"Call &lt;xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A&gt; or &lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt; to remove an active PermitOnly.","pos":[1790,1950],"source":" Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active PermitOnly."},{"content":"PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed.","pos":[1957,2062]},{"content":"However, if code lower on the call stack later calls &lt;xref:System.Security.CodeAccessPermission.Demand%2A&gt; for that permission, a &lt;xref:System.Security.SecurityException&gt; is thrown when the stack walk reaches the code that tried to call PermitOnly.","pos":[2063,2311],"source":" However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call PermitOnly."},{"content":"This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission.","pos":[2312,2450]},{"content":"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.","pos":[2451,2586]}]},{"pos":[27148,27208],"content":"There is already an active PermitOnly for the current frame.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is already an active PermitOnly for the current frame.","pos":[0,60]}]},{"pos":[27581,27671],"content":"Causes all previous overrides for the current frame to be removed and no longer in effect.","needQuote":true,"needEscape":true,"nodes":[{"content":"Causes all previous overrides for the current frame to be removed and no longer in effect.","pos":[0,90]}]},{"pos":[27683,27955],"content":"If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"If there are no overrides (&lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt;) for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.","pos":[0,272],"source":"If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown."}]},{"pos":[28215,28421],"content":"There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert<bpt id=\"p1\">*</bpt>&gt;, &lt;xref:System.Security.CodeAccessPermission.Deny<ept id=\"p1\">*</ept>&gt;, or &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.","needQuote":true,"needEscape":true,"source":"There is no previous <xref:System.Security.CodeAccessPermission.Assert*>, <xref:System.Security.CodeAccessPermission.Deny*>, or <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame."},{"pos":[28809,28941],"content":"Causes any previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame to be removed and no longer in effect.","needQuote":true,"needEscape":true,"nodes":[{"content":"Causes any previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame to be removed and no longer in effect.","pos":[0,132],"source":"Causes any previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame to be removed and no longer in effect."}]},{"pos":[28953,29097],"content":"If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"If there is no &lt;xref:System.Security.CodeAccessPermission.Assert%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.","pos":[0,144],"source":"If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown."}]},{"pos":[29363,29458],"content":"There is no previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is no previous &lt;xref:System.Security.CodeAccessPermission.Assert*&gt; for the current frame.","pos":[0,95],"source":"There is no previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame."}]},{"pos":[29836,29966],"content":"Causes any previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame to be removed and no longer in effect.","needQuote":true,"needEscape":true,"nodes":[{"content":"Causes any previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame to be removed and no longer in effect.","pos":[0,130],"source":"Causes any previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame to be removed and no longer in effect."}]},{"pos":[29978,30120],"content":"If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"If there is no &lt;xref:System.Security.CodeAccessPermission.Deny%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.","pos":[0,142],"source":"If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown."}]},{"pos":[30382,30475],"content":"There is no previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is no previous &lt;xref:System.Security.CodeAccessPermission.Deny*&gt; for the current frame.","pos":[0,93],"source":"There is no previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame."}]},{"pos":[30883,31019],"content":"Causes any previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame to be removed and no longer in effect.","needQuote":true,"needEscape":true,"nodes":[{"content":"Causes any previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame to be removed and no longer in effect.","pos":[0,136],"source":"Causes any previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame to be removed and no longer in effect."}]},{"pos":[31031,31179],"content":"If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"If there is no &lt;xref:System.Security.CodeAccessPermission.PermitOnly%2A&gt; for the current frame, an &lt;xref:System.ExecutionEngineException&gt; is thrown.","pos":[0,148],"source":"If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown."}]},{"pos":[31453,31552],"content":"There is no previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is no previous &lt;xref:System.Security.CodeAccessPermission.PermitOnly*&gt; for the current frame.","pos":[0,99],"source":"There is no previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame."}]},{"pos":[31920,31997],"content":"Creates and returns a string representation of the current permission object.","needQuote":true,"needEscape":true,"nodes":[{"content":"Creates and returns a string representation of the current permission object.","pos":[0,77]}]},{"pos":[32009,32096],"content":"This method is useful in debugging when you need to display the permission as a string.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is useful in debugging when you need to display the permission as a string.","pos":[0,87]}]},{"pos":[32232,32289],"content":"A string representation of the current permission object.","needQuote":true,"needEscape":true,"nodes":[{"content":"A string representation of the current permission object.","pos":[0,57]}]},{"pos":[32718,32823],"content":"When overridden in a derived class, creates an XML encoding of the security object and its current state.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, creates an XML encoding of the security object and its current state.","pos":[0,105]}]},{"pos":[32835,33012],"content":"Custom code that extends security objects needs to implement the ToXml and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Custom code that extends security objects needs to implement the ToXml and &lt;xref:System.Security.CodeAccessPermission.FromXml%2A&gt; methods to make the objects security-encodable.","pos":[0,177],"source":"Custom code that extends security objects needs to implement the ToXml and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable."}]},{"pos":[33755,33827],"content":"An XML encoding of the security object, including any state information.","needQuote":true,"needEscape":true,"nodes":[{"content":"An XML encoding of the security object, including any state information.","pos":[0,72]}]},{"pos":[34344,34474],"content":"When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.","pos":[0,130]}]},{"pos":[34486,34700],"content":"The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission. Any demand that passes either permission passes their union.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission. Any demand that passes either permission passes their union.","pos":[0,214],"nodes":[{"content":"The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission.","pos":[0,153]},{"content":"Any demand that passes either permission passes their union.","pos":[154,214]}]}]},{"pos":[35468,35575],"content":"A permission to combine with the current permission. It must be of the same type as the current permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"A permission to combine with the current permission. It must be of the same type as the current permission.","pos":[0,107],"nodes":[{"content":"A permission to combine with the current permission.","pos":[0,52]},{"content":"It must be of the same type as the current permission.","pos":[53,107]}]}]},{"pos":[35647,35745],"content":"A new permission that represents the union of the current permission and the specified permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"A new permission that represents the union of the current permission and the specified permission.","pos":[0,98]}]},{"pos":[35918,36137],"content":"The <code>other</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>. This method is only supported at this level when passed <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">other</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[0,101],"source":"The <code>other</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"content":"This method is only supported at this level when passed <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[102,219],"source":" This method is only supported at this level when passed <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Security.CodeAccessPermission\n  id: CodeAccessPermission\n  children:\n  - System.Security.CodeAccessPermission.#ctor\n  - System.Security.CodeAccessPermission.Assert\n  - System.Security.CodeAccessPermission.Copy\n  - System.Security.CodeAccessPermission.Demand\n  - System.Security.CodeAccessPermission.Deny\n  - System.Security.CodeAccessPermission.Equals(System.Object)\n  - System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)\n  - System.Security.CodeAccessPermission.GetHashCode\n  - System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)\n  - System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)\n  - System.Security.CodeAccessPermission.PermitOnly\n  - System.Security.CodeAccessPermission.RevertAll\n  - System.Security.CodeAccessPermission.RevertAssert\n  - System.Security.CodeAccessPermission.RevertDeny\n  - System.Security.CodeAccessPermission.RevertPermitOnly\n  - System.Security.CodeAccessPermission.ToString\n  - System.Security.CodeAccessPermission.ToXml\n  - System.Security.CodeAccessPermission.Union(System.Security.IPermission)\n  langs:\n  - csharp\n  name: CodeAccessPermission\n  nameWithType: CodeAccessPermission\n  fullName: System.Security.CodeAccessPermission\n  type: Class\n  summary: Defines the underlying structure of all code access permissions.\n  remarks: \"Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission. If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState?displayProperty=fullName>.  \\n  \\n The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.  \\n  \\n Inheritors of the CodeAccessPermission class must be granted full trust to function correctly as permissions extending the security infrastructure. To determine that the inheritors are fully trusted, CodeAccessPermission issues an <xref:System.Security.Permissions.SecurityAction> for <xref:System.Security.Permissions.SecurityPermissionFlag> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag> = `true`.\"\n  example:\n  - \"The following code example shows a permission derived from the CodeAccessPermission class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/csharp/t-system.security.codeac_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/cpp/t-system.security.codeac_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/visualbasic/t-system.security.codeac_1.vb)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk\n  inheritance:\n  - System.Object\n  implements:\n  - System.Security.IPermission\n  - System.Security.IStackWalk\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.#ctor\n  id: '#ctor'\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: CodeAccessPermission()\n  nameWithType: CodeAccessPermission.CodeAccessPermission()\n  fullName: System.Security.CodeAccessPermission.CodeAccessPermission()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Initializes a new instance of the <xref href=\"System.Security.CodeAccessPermission\"></xref> class.\n  remarks: This constructor is called to initialize state in the type whenever an instance of the derived class is created. Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.\n  syntax:\n    content: protected CodeAccessPermission ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Assert\n  id: Assert\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Assert()\n  nameWithType: CodeAccessPermission.Assert()\n  fullName: System.Security.CodeAccessPermission.Assert()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource. Using Assert can create security issues.\n  remarks: \"The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Calling Assert prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method. Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission. An assertion is effective only if the code that calls Assert passes the security check for the permission that it is asserting.  \\n  \\n The call to Assert is effective until the calling code returns to its caller. Only one Assert can be active on a frame. An attempt to call Assert when an active Assert exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Assert.  \\n  \\n Assert is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call Assert. This happens because the code that called Assert has not been granted the permission, even though it tried to Assert it.  \\n  \\n> [!CAUTION]\\n>  Because calling Assert removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately. Therefore, it should be used with great caution.\"\n  syntax:\n    content: public void Assert ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.Assert*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: \"The calling code does not have <xref href=\\\"System.Security.Permissions.SecurityPermissionFlag\\\"></xref>.  \\n  \\n -or-  \\n  \\n There is already an active Assert for the current frame.\"\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Copy\n  id: Copy\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Copy()\n  nameWithType: CodeAccessPermission.Copy()\n  fullName: System.Security.CodeAccessPermission.Copy()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When implemented by a derived class, creates and returns an identical copy of the current permission object.\n  remarks: A copy of a permission object represents the same access to resources as the original permission object.\n  example:\n  - \"The following code example shows an override of the Copy method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/csharp/m-system.security.codeac_0_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/cpp/m-system.security.codeac_0_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/visualbasic/m-system.security.codeac_0_1.vb)]\"\n  syntax:\n    content: public abstract System.Security.IPermission Copy ();\n    parameters: []\n    return:\n      type: System.Security.IPermission\n      description: A copy of the current permission object.\n  overload: System.Security.CodeAccessPermission.Copy*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Demand\n  id: Demand\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Demand()\n  nameWithType: CodeAccessPermission.Demand()\n  fullName: System.Security.CodeAccessPermission.Demand()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Forces a <xref:System.Security.SecurityException> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.\n  remarks: \"This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls Demand for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.  \\n  \\n The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Demand succeeds only if no <xref:System.Security.SecurityException> is raised.\"\n  syntax:\n    content: public void Demand ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.Demand*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: \"A caller higher in the call stack does not have the permission specified by the current instance.  \\n  \\n -or-  \\n  \\n A caller higher in the call stack has called <xref:System.Security.CodeAccessPermission.Deny*> on the current permission object.\"\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Deny\n  id: Deny\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Deny()\n  nameWithType: CodeAccessPermission.Deny()\n  fullName: System.Security.CodeAccessPermission.Deny()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.\n  remarks: \"> [!IMPORTANT]\\n>  The Deny method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method `A` issues a Deny for a permission and then calls method `B`, method `B` can overtly override the Deny by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>. The called method is always higher in the stack. Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no Deny or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack. Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method. In that case, the Deny placed on the stack by method `A` (the calling method) is never discovered.  \\n  \\n This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.  \\n  \\n Deny can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls Deny from being used to access the resource protected by the denied permission. If a method calls Deny on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the Deny.  \\n  \\n The call to Deny is effective until the calling code returns to its caller. Only one Deny can be active on a frame. An attempt to call Deny when an active Deny exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active Deny. Deny is ignored for a permission not granted because a demand for that permission will not succeed.\"\n  syntax:\n    content: public void Deny ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.Deny*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: There is already an active Deny for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: CodeAccessPermission.Equals(Object)\n  fullName: System.Security.CodeAccessPermission.Equals(Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Determines whether the specified <xref href=\"System.Security.CodeAccessPermission\"></xref> object is equal to the current <xref href=\"System.Security.CodeAccessPermission\"></xref>.\n  remarks: For more information, see <xref:System.Object.Equals%2A>.\n  syntax:\n    content: public override bool Equals (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The <xref href=\"System.Security.CodeAccessPermission\"></xref> object to compare with the current <xref href=\"System.Security.CodeAccessPermission\"></xref>.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the specified <xref href=\"System.Security.CodeAccessPermission\"></xref> object is equal to the current <xref href=\"System.Security.CodeAccessPermission\"></xref>; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Security.CodeAccessPermission.Equals*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)\n  id: FromXml(System.Security.SecurityElement)\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: FromXml(SecurityElement)\n  nameWithType: CodeAccessPermission.FromXml(SecurityElement)\n  fullName: System.Security.CodeAccessPermission.FromXml(SecurityElement)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.\n  remarks: Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and FromXml methods to make the objects security-encodable.\n  example:\n  - \"The following code example shows an override of the FromXml method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/csharp/m-system.security.codeac_1_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/cpp/m-system.security.codeac_1_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/visualbasic/m-system.security.codeac_1_1.vb)]\"\n  syntax:\n    content: public abstract void FromXml (System.Security.SecurityElement elem);\n    parameters:\n    - id: elem\n      type: System.Security.SecurityElement\n      description: The XML encoding to use to reconstruct the security object.\n  overload: System.Security.CodeAccessPermission.FromXml*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>elem</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"The <code>elem</code> parameter does not contain the XML encoding for an instance of the same type as the current instance.  \\n  \\n -or-  \\n  \\n The version number of the <code>elem</code> parameter is not supported.\"\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.GetHashCode\n  id: GetHashCode\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: CodeAccessPermission.GetHashCode()\n  fullName: System.Security.CodeAccessPermission.GetHashCode()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Gets a hash code for the <xref href=\"System.Security.CodeAccessPermission\"></xref> object that is suitable for use in hashing algorithms and data structures such as a hash table.\n  remarks: The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.\n  syntax:\n    content: public override int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: A hash code for the current <xref href=\"System.Security.CodeAccessPermission\"></xref> object.\n  overload: System.Security.CodeAccessPermission.GetHashCode*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)\n  id: Intersect(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Intersect(IPermission)\n  nameWithType: CodeAccessPermission.Intersect(IPermission)\n  fullName: System.Security.CodeAccessPermission.Intersect(IPermission)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.\n  remarks: The intersection of two permissions is a permission that describes the set of operations they both describe in common. Only a demand that passes both original permissions will pass the intersection.\n  example:\n  - \"The following code example shows an override of the Intersect method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/csharp/m-system.security.codeac_3_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/cpp/m-system.security.codeac_3_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/visualbasic/m-system.security.codeac_3_1.vb)]\"\n  syntax:\n    content: public abstract System.Security.IPermission Intersect (System.Security.IPermission target);\n    parameters:\n    - id: target\n      type: System.Security.IPermission\n      description: A permission to intersect with the current permission. It must be of the same type as the current permission.\n    return:\n      type: System.Security.IPermission\n      description: A new permission that represents the intersection of the current permission and the specified permission. This new permission is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> if the intersection is empty.\n  overload: System.Security.CodeAccessPermission.Intersect*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>target</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> and is not an instance of the same class as the current permission.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)\n  id: IsSubsetOf(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: IsSubsetOf(IPermission)\n  nameWithType: CodeAccessPermission.IsSubsetOf(IPermission)\n  fullName: System.Security.CodeAccessPermission.IsSubsetOf(IPermission)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When implemented by a derived class, determines whether the current permission is a subset of the specified permission.\n  remarks: \"The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission. For example, a permission that represents access to C:\\\\example.txt is a subset of a permission that represents access to C:\\\\\\\\. If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.  \\n  \\n The following statements are required to be `true` for all overrides of the IsSubsetOf method. *X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState>.  \\n  \\n-   *X*.IsSubsetOf(*X*) returns `true`.  \\n  \\n-   *X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.  \\n  \\n-   If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.  \\n  \\n-   *X*.IsSubsetOf(*U*) returns `true`.  \\n  \\n-   *X*.IsSubsetOf(*N*) returns `false`.  \\n  \\n-   *N*.IsSubsetOf(*X*) returns `true`.  \\n  \\n If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`. If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.\"\n  example:\n  - \"The following code example shows an override of the IsSubsetOf method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/csharp/m-system.security.codeac_5_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/cpp/m-system.security.codeac_5_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/visualbasic/m-system.security.codeac_5_1.vb)]\"\n  syntax:\n    content: public abstract bool IsSubsetOf (System.Security.IPermission target);\n    parameters:\n    - id: target\n      type: System.Security.IPermission\n      description: A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current permission is a subset of the specified permission; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Security.CodeAccessPermission.IsSubsetOf*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>target</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> and is not of the same type as the current permission.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.PermitOnly\n  id: PermitOnly\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: PermitOnly()\n  nameWithType: CodeAccessPermission.PermitOnly()\n  fullName: System.Security.CodeAccessPermission.PermitOnly()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.\n  remarks: \"> [!IMPORTANT]\\n>  The PermitOnly method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method `A` issues a PermitOnly for a permission and then calls method `B`, method `B` can overtly override the PermitOnly by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>. The called method is always higher in the stack. Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or PermitOnly lower in the stack. Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method. In that case, the PermitOnly placed on the stack by method `A` (the calling method) is never discovered.  \\n  \\n PermitOnly is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed. The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but PermitOnly specifies the only permissions that do not cause the stack walk to fail.  \\n  \\n Call this method to ensure that your code can be used to access only the specified resources. The call to PermitOnly is effective until the calling code returns to its caller. Only one PermitOnly can be active on a frame. An attempt to call PermitOnly when an active PermitOnly exists on the frame results in a <xref:System.Security.SecurityException>. Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active PermitOnly.  \\n  \\n PermitOnly is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call PermitOnly. This is because the code that called PermitOnly has not been granted the permission, even though it called PermitOnly for that permission. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.\"\n  syntax:\n    content: public void PermitOnly ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.PermitOnly*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: There is already an active PermitOnly for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.RevertAll\n  id: RevertAll\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: RevertAll()\n  nameWithType: CodeAccessPermission.RevertAll()\n  fullName: System.Security.CodeAccessPermission.RevertAll()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Causes all previous overrides for the current frame to be removed and no longer in effect.\n  remarks: If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.\n  syntax:\n    content: public static void RevertAll ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.RevertAll*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: There is no previous <xref:System.Security.CodeAccessPermission.Assert*>, <xref:System.Security.CodeAccessPermission.Deny*>, or <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.RevertAssert\n  id: RevertAssert\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: RevertAssert()\n  nameWithType: CodeAccessPermission.RevertAssert()\n  fullName: System.Security.CodeAccessPermission.RevertAssert()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Causes any previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame to be removed and no longer in effect.\n  remarks: If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.\n  syntax:\n    content: public static void RevertAssert ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.RevertAssert*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: There is no previous <xref:System.Security.CodeAccessPermission.Assert*> for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.RevertDeny\n  id: RevertDeny\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: RevertDeny()\n  nameWithType: CodeAccessPermission.RevertDeny()\n  fullName: System.Security.CodeAccessPermission.RevertDeny()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Causes any previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame to be removed and no longer in effect.\n  remarks: If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.\n  syntax:\n    content: public static void RevertDeny ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.RevertDeny*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: There is no previous <xref:System.Security.CodeAccessPermission.Deny*> for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.RevertPermitOnly\n  id: RevertPermitOnly\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: RevertPermitOnly()\n  nameWithType: CodeAccessPermission.RevertPermitOnly()\n  fullName: System.Security.CodeAccessPermission.RevertPermitOnly()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Causes any previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame to be removed and no longer in effect.\n  remarks: If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.\n  syntax:\n    content: public static void RevertPermitOnly ();\n    parameters: []\n  overload: System.Security.CodeAccessPermission.RevertPermitOnly*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: There is no previous <xref:System.Security.CodeAccessPermission.PermitOnly*> for the current frame.\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.ToString\n  id: ToString\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: ToString()\n  nameWithType: CodeAccessPermission.ToString()\n  fullName: System.Security.CodeAccessPermission.ToString()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Creates and returns a string representation of the current permission object.\n  remarks: This method is useful in debugging when you need to display the permission as a string.\n  syntax:\n    content: public override string ToString ();\n    parameters: []\n    return:\n      type: System.String\n      description: A string representation of the current permission object.\n  overload: System.Security.CodeAccessPermission.ToString*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.ToXml\n  id: ToXml\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: ToXml()\n  nameWithType: CodeAccessPermission.ToXml()\n  fullName: System.Security.CodeAccessPermission.ToXml()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When overridden in a derived class, creates an XML encoding of the security object and its current state.\n  remarks: Custom code that extends security objects needs to implement the ToXml and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.\n  example:\n  - \"The following code example shows an override of the ToXml method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/csharp/m-system.security.codeac_4_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/cpp/m-system.security.codeac_4_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/visualbasic/m-system.security.codeac_4_1.vb)]\"\n  syntax:\n    content: public abstract System.Security.SecurityElement ToXml ();\n    parameters: []\n    return:\n      type: System.Security.SecurityElement\n      description: An XML encoding of the security object, including any state information.\n  overload: System.Security.CodeAccessPermission.ToXml*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.CodeAccessPermission.Union(System.Security.IPermission)\n  id: Union(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  langs:\n  - csharp\n  name: Union(IPermission)\n  nameWithType: CodeAccessPermission.Union(IPermission)\n  fullName: System.Security.CodeAccessPermission.Union(IPermission)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.\n  remarks: The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission. Any demand that passes either permission passes their union.\n  example:\n  - \"The following code example shows an override of the Union method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \\n  \\n [!code-cs[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/csharp/m-system.security.codeac_2_1.cs)]\\n [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/cpp/m-system.security.codeac_2_1.cpp)]\\n [!code-vb[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/visualbasic/m-system.security.codeac_2_1.vb)]\"\n  syntax:\n    content: public virtual System.Security.IPermission Union (System.Security.IPermission other);\n    parameters:\n    - id: other\n      type: System.Security.IPermission\n      description: A permission to combine with the current permission. It must be of the same type as the current permission.\n    return:\n      type: System.Security.IPermission\n      description: A new permission that represents the union of the current permission and the specified permission.\n  overload: System.Security.CodeAccessPermission.Union*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <code>other</code> parameter is not <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>. This method is only supported at this level when passed <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.Security.SecurityException\n  isExternal: true\n  name: System.Security.SecurityException\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.NotSupportedException\n  isExternal: true\n  name: System.NotSupportedException\n- uid: System.Security.CodeAccessPermission.#ctor\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: CodeAccessPermission()\n  nameWithType: CodeAccessPermission.CodeAccessPermission()\n  fullName: System.Security.CodeAccessPermission.CodeAccessPermission()\n- uid: System.Security.CodeAccessPermission.Assert\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Assert()\n  nameWithType: CodeAccessPermission.Assert()\n  fullName: System.Security.CodeAccessPermission.Assert()\n- uid: System.Security.CodeAccessPermission.Copy\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Copy()\n  nameWithType: CodeAccessPermission.Copy()\n  fullName: System.Security.CodeAccessPermission.Copy()\n- uid: System.Security.IPermission\n  parent: System.Security\n  isExternal: false\n  name: IPermission\n  nameWithType: IPermission\n  fullName: System.Security.IPermission\n- uid: System.Security.CodeAccessPermission.Demand\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Demand()\n  nameWithType: CodeAccessPermission.Demand()\n  fullName: System.Security.CodeAccessPermission.Demand()\n- uid: System.Security.CodeAccessPermission.Deny\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Deny()\n  nameWithType: CodeAccessPermission.Deny()\n  fullName: System.Security.CodeAccessPermission.Deny()\n- uid: System.Security.CodeAccessPermission.Equals(System.Object)\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: CodeAccessPermission.Equals(Object)\n  fullName: System.Security.CodeAccessPermission.Equals(Object)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: FromXml(SecurityElement)\n  nameWithType: CodeAccessPermission.FromXml(SecurityElement)\n  fullName: System.Security.CodeAccessPermission.FromXml(SecurityElement)\n- uid: System.Security.SecurityElement\n  parent: System.Security\n  isExternal: false\n  name: SecurityElement\n  nameWithType: SecurityElement\n  fullName: System.Security.SecurityElement\n- uid: System.Security.CodeAccessPermission.GetHashCode\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: CodeAccessPermission.GetHashCode()\n  fullName: System.Security.CodeAccessPermission.GetHashCode()\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Intersect(IPermission)\n  nameWithType: CodeAccessPermission.Intersect(IPermission)\n  fullName: System.Security.CodeAccessPermission.Intersect(IPermission)\n- uid: System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: IsSubsetOf(IPermission)\n  nameWithType: CodeAccessPermission.IsSubsetOf(IPermission)\n  fullName: System.Security.CodeAccessPermission.IsSubsetOf(IPermission)\n- uid: System.Security.CodeAccessPermission.PermitOnly\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: PermitOnly()\n  nameWithType: CodeAccessPermission.PermitOnly()\n  fullName: System.Security.CodeAccessPermission.PermitOnly()\n- uid: System.Security.CodeAccessPermission.RevertAll\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertAll()\n  nameWithType: CodeAccessPermission.RevertAll()\n  fullName: System.Security.CodeAccessPermission.RevertAll()\n- uid: System.Security.CodeAccessPermission.RevertAssert\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertAssert()\n  nameWithType: CodeAccessPermission.RevertAssert()\n  fullName: System.Security.CodeAccessPermission.RevertAssert()\n- uid: System.Security.CodeAccessPermission.RevertDeny\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertDeny()\n  nameWithType: CodeAccessPermission.RevertDeny()\n  fullName: System.Security.CodeAccessPermission.RevertDeny()\n- uid: System.Security.CodeAccessPermission.RevertPermitOnly\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertPermitOnly()\n  nameWithType: CodeAccessPermission.RevertPermitOnly()\n  fullName: System.Security.CodeAccessPermission.RevertPermitOnly()\n- uid: System.Security.CodeAccessPermission.ToString\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: ToString()\n  nameWithType: CodeAccessPermission.ToString()\n  fullName: System.Security.CodeAccessPermission.ToString()\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Security.CodeAccessPermission.ToXml\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: ToXml()\n  nameWithType: CodeAccessPermission.ToXml()\n  fullName: System.Security.CodeAccessPermission.ToXml()\n- uid: System.Security.CodeAccessPermission.Union(System.Security.IPermission)\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Union(IPermission)\n  nameWithType: CodeAccessPermission.Union(IPermission)\n  fullName: System.Security.CodeAccessPermission.Union(IPermission)\n- uid: System.Security.CodeAccessPermission.#ctor*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: CodeAccessPermission\n  nameWithType: CodeAccessPermission.CodeAccessPermission\n- uid: System.Security.CodeAccessPermission.Assert*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Assert\n  nameWithType: CodeAccessPermission.Assert\n- uid: System.Security.CodeAccessPermission.Copy*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Copy\n  nameWithType: CodeAccessPermission.Copy\n- uid: System.Security.CodeAccessPermission.Demand*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Demand\n  nameWithType: CodeAccessPermission.Demand\n- uid: System.Security.CodeAccessPermission.Deny*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Deny\n  nameWithType: CodeAccessPermission.Deny\n- uid: System.Security.CodeAccessPermission.Equals*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Equals\n  nameWithType: CodeAccessPermission.Equals\n- uid: System.Security.CodeAccessPermission.FromXml*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: FromXml\n  nameWithType: CodeAccessPermission.FromXml\n- uid: System.Security.CodeAccessPermission.GetHashCode*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: GetHashCode\n  nameWithType: CodeAccessPermission.GetHashCode\n- uid: System.Security.CodeAccessPermission.Intersect*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Intersect\n  nameWithType: CodeAccessPermission.Intersect\n- uid: System.Security.CodeAccessPermission.IsSubsetOf*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: IsSubsetOf\n  nameWithType: CodeAccessPermission.IsSubsetOf\n- uid: System.Security.CodeAccessPermission.PermitOnly*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: PermitOnly\n  nameWithType: CodeAccessPermission.PermitOnly\n- uid: System.Security.CodeAccessPermission.RevertAll*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertAll\n  nameWithType: CodeAccessPermission.RevertAll\n- uid: System.Security.CodeAccessPermission.RevertAssert*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertAssert\n  nameWithType: CodeAccessPermission.RevertAssert\n- uid: System.Security.CodeAccessPermission.RevertDeny*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertDeny\n  nameWithType: CodeAccessPermission.RevertDeny\n- uid: System.Security.CodeAccessPermission.RevertPermitOnly*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: RevertPermitOnly\n  nameWithType: CodeAccessPermission.RevertPermitOnly\n- uid: System.Security.CodeAccessPermission.ToString*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: ToString\n  nameWithType: CodeAccessPermission.ToString\n- uid: System.Security.CodeAccessPermission.ToXml*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: ToXml\n  nameWithType: CodeAccessPermission.ToXml\n- uid: System.Security.CodeAccessPermission.Union*\n  parent: System.Security.CodeAccessPermission\n  isExternal: false\n  name: Union\n  nameWithType: CodeAccessPermission.Union\n"}