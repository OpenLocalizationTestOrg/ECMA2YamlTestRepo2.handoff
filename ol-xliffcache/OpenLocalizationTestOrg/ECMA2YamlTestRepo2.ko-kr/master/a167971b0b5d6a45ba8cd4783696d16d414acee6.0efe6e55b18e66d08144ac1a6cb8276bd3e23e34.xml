{"nodes":[{"pos":[5479,5533],"content":"Provides a generic interface to a sequence of records.","needQuote":true,"needEscape":true,"nodes":[{"content":"Provides a generic interface to a sequence of records.","pos":[0,54]}]},{"pos":[5546,8203],"content":"The IRecordSequence interface provides an abstract interface to a record-oriented stream. A IRecordSequence instance can be used to read and write log records.       The IRecordSequence interface provides the following capabilities,      -   Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.      -   Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.      -   Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.      -   Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.      -   Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.      -   Reserve space for appending records.      -   Free log space by advancing the base of the log.      -   Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.       Log records are appended to a IRecordSequence instance, and each log record is given a unique sequence number. Sequence numbers are strictly monotonically increasing within a given record sequence. A log record consists of opaque data, supplied to the IRecordSequence instance in an <xref:System.Collections.IList> of ArraySegments of bytes.       The IRecordSequence interface also exposes a few basic properties which provides information about log boundaries.      -   The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.      -   The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.      -   The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.      -   The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.      -   The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.      -   If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The IRecordSequence interface provides an abstract interface to a record-oriented stream.","pos":[0,89]},{"content":"A IRecordSequence instance can be used to read and write log records.","pos":[90,159]},{"content":"The IRecordSequence interface provides the following capabilities,      -   Append log records using the &lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt; methods.","pos":[166,326],"source":"       The IRecordSequence interface provides the following capabilities,      -   Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods."},{"content":"-   Read the appended records using the &lt;xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A&gt; method.","pos":[332,434],"source":"      -   Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method."},{"content":"-   Write a special restart record using the &lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt; method.","pos":[440,549],"source":"      -   Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method."},{"content":"-   Read restart records from the most recently written restart record using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[555,700],"source":"      -   Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"-   Flush the records to durable store using the  &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[706,809],"source":"      -   Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method."},{"content":"-   Reserve space for appending records.","pos":[815,855]},{"content":"-   Free log space by advancing the base of the log.","pos":[861,913]},{"content":"-   Receive &lt;xref:System.IO.Log.IRecordSequence.TailPinned&gt; event notifications to move the base of the log to free space.","pos":[919,1041],"source":"      -   Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space."},{"content":"Log records are appended to a IRecordSequence instance, and each log record is given a unique sequence number.","pos":[1048,1158]},{"content":"Sequence numbers are strictly monotonically increasing within a given record sequence.","pos":[1159,1245]},{"content":"A log record consists of opaque data, supplied to the IRecordSequence instance in an &lt;xref:System.Collections.IList&gt; of ArraySegments of bytes.","pos":[1246,1389],"source":" A log record consists of opaque data, supplied to the IRecordSequence instance in an <xref:System.Collections.IList> of ArraySegments of bytes."},{"content":"The IRecordSequence interface also exposes a few basic properties which provides information about log boundaries.","pos":[1396,1510]},{"content":"-   The &lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt; property contains the sequence number of the first valid record in the record sequence.","pos":[1516,1670],"source":"      -   The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence."},{"content":"-   The &lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt; property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.","pos":[1676,1864],"source":"      -   The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record."},{"content":"-   The &lt;xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A&gt; property contains the sequence number of the last written restart area.","pos":[1870,2011],"source":"      -   The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area."},{"content":"-   The &lt;xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A&gt; property contains the size of the largest record that can be appended to, or read from the sequence.","pos":[2017,2185],"source":"      -   The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence."},{"content":"-   The &lt;xref:System.IO.Log.IRecordSequence.ReservedBytes%2A&gt; property contains the total size of all reservations made in this record sequence.","pos":[2191,2335],"source":"      -   The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence."},{"content":"-   If the &lt;xref:System.IO.Log.IRecordSequence.RetryAppend%2A&gt; property is set to <ph id=\"ph1\">`true`</ph>, and an &lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt; operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.","pos":[2341,2623],"source":"      -   If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation."}]},{"pos":[8845,8895],"content":"Moves the base sequence number of the log forward.","needQuote":true,"needEscape":true,"nodes":[{"content":"Moves the base sequence number of the log forward.","pos":[0,50]}]},{"pos":[8907,9195],"content":"When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty. Freeing extents partially is not supported.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty. Freeing extents partially is not supported.","pos":[0,288],"nodes":[{"content":"When you use a &lt;xref:System.IO.Log.LogRecordSequence&gt; instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.","pos":[0,244],"source":"When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty."},{"content":"Freeing extents partially is not supported.","pos":[245,288]}]}]},{"pos":[9419,9471],"content":"The new base sequence number of the record sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number of the record sequence.","pos":[0,52]}]},{"pos":[9649,9695],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>newBaseSequenceNumber</code> is invalid."},{"pos":[9810,9870],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph> is not active in the log.","needQuote":true,"needEscape":true,"source":"<code>newBaseSequenceNumber</code> is not active in the log."},{"pos":[9959,10010],"content":"An I/O error occurred while modifying the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while modifying the sequence.","pos":[0,51]}]},{"pos":[10117,10179],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[10296,10324],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[11115,11229],"content":"When overridden in a derived class, writes a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[11242,11746],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"Normally, this method completes before the record has been written.","pos":[219,286]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[287,502],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[12081,12164],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[12250,12317],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[12403,12460],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[12556,12674],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[12747,12794],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[12953,12993],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[13082,13131],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[13248,13327],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[13434,13496],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[14376,14491],"content":"When overridden in a derived class, appends a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[14504,15008],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"Normally, this method completes before the record has been written.","pos":[219,286]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[287,502],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[15411,15494],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[15580,15647],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[15733,15790],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[15886,16004],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[16077,16124],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[16283,16323],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[16412,16461],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[16578,16657],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[16764,16826],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[17755,17919],"content":"When overridden in a derived class, appends a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>, using space previously reserved in the sequence."},{"pos":[17932,18738],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[219,355],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[356,512]},{"content":"Normally, this method completes before the record has been written.","pos":[519,586]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[587,802],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[19123,19206],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[19292,19359],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[19445,19502],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[19598,19716],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[19807,19932],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[20005,20052],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[20211,20251],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[20340,20389],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[20506,20585],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[20692,20754],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[21772,21936],"content":"When overridden in a derived class, appends a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>, using space previously reserved in the sequence."},{"pos":[21949,22755],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[219,355],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[356,512]},{"content":"Normally, this method completes before the record has been written.","pos":[519,586]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[587,802],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[23208,23291],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[23377,23444],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[23530,23587],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[23683,23801],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[23892,24017],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[24090,24137],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[24296,24336],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[24425,24474],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[24591,24670],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[24777,24839],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[25230,25383],"content":"When overridden in a derived class, gets the sequence number of the first valid record in the current <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, gets the sequence number of the first valid record in the current <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[25396,25739],"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.       The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.       The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.","pos":[0,341],"nodes":[{"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than &lt;xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A&gt;.","pos":[0,144],"source":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>."},{"content":"The value of this property can be changed by calling the &lt;xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A&gt; or &lt;xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A&gt; method.","pos":[151,341],"source":"       The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method."}]}]},{"pos":[25900,26020],"content":"The lowest sequence number that corresponds to a valid record in the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The lowest sequence number that corresponds to a valid record in the <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[26203,26269],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[27218,27294],"content":"When overridden in a derived class, begins an asynchronous append operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous append operation.","pos":[0,76]}]},{"pos":[27307,28267],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,226],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[227,447],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[454,567],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[568,666]},{"content":"Normally, this method completes before the record has been written.","pos":[673,740]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[741,956],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[28629,28712],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[28798,28865],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[28951,29008],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[29104,29222],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[29294,29370],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[29432,29538],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[29602,29702],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[29866,29906],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[29995,30044],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[30161,30240],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[30347,30409],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[31447,31572],"content":"When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.","pos":[0,125]}]},{"pos":[31585,32545],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,226],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[227,447],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[454,567],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[568,666]},{"content":"Normally, this method completes before the record has been written.","pos":[673,740]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[741,956],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[32975,33058],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[33144,33211],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[33297,33354],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[33450,33568],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[33640,33716],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[33778,33884],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[33948,34048],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[34212,34252],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[34341,34390],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[34507,34586],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[34693,34755],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[35842,35966],"content":"When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.","pos":[0,124]}]},{"pos":[35979,37241],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,226],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[227,447],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[454,567],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[568,666]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[673,809],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[810,966]},{"content":"Normally, this method completes before the record has been written.","pos":[973,1040]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[1041,1256],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[37653,37736],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[37822,37889],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[37975,38032],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[38128,38246],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[38337,38462],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[38534,38610],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[38672,38778],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[38842,38942],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[39106,39146],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[39235,39284],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[39401,39480],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[39587,39649],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[40825,40950],"content":"When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.","pos":[0,125]}]},{"pos":[40963,42225],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,226],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[227,447],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[454,567],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[568,666]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[673,809],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[810,966]},{"content":"Normally, this method completes before the record has been written.","pos":[973,1040]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[1041,1256],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[42709,42792],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[42878,42945],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[43035,43092],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[43188,43306],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[43397,43522],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[43594,43670],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[43732,43838],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[43902,44002],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[44166,44206],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[44295,44344],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[44461,44540],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[44647,44709],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[45299,45423],"content":"When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.","pos":[0,124]}]},{"pos":[45436,46375],"content":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.","pos":[0,935],"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by the current method to the &lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt; method to ensure that the flush completes and resources are freed appropriately.","pos":[0,214],"source":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately."},{"content":"If an error occurs during an asynchronous flush, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[215,427],"source":" If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.IRecordSequence&gt; are durably written.","pos":[434,567],"source":"       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[574,709]},{"content":"Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndFlush%2A&gt; method is called.","pos":[710,935],"source":" Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called."}]}]},{"pos":[46617,46783],"content":"The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the latest record that must be written.","pos":[0,62]},{"content":"If this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.SequenceNumber\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is invalid, then all records must be written.","pos":[63,166],"source":" If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written."}]},{"pos":[46855,46930],"content":"An optional asynchronous callback, to be called when the flush is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the flush is complete.","pos":[0,75]}]},{"pos":[46992,47097],"content":"A user-provided object that distinguishes this particular asynchronous flush request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous flush request from other requests.","pos":[0,105]}]},{"pos":[47161,47270],"content":"An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous flush operation, which could still be pending.","pos":[0,109],"source":"An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending."}]},{"pos":[47433,47473],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[47562,47608],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[47715,47777],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[48968,49056],"content":"When overridden in a derived class, begins an asynchronous reserve and append operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous reserve and append operation.","pos":[0,88]}]},{"pos":[49069,50616],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,236],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[237,467],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[474,587],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[588,686]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[693,823]},{"content":"If the append fails, no space is reserved.","pos":[824,866]},{"content":"Normally, this method may complete before the record has been written.","pos":[873,943]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[944,1159],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1166,1301]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1302,1539],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called."}]},{"pos":[51068,51151],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[51237,51304],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[51390,51447],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[51543,51661],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[51761,51812],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[51882,51917],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[51989,52065],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[52127,52233],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[52297,52401],"content":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.","pos":[0,104],"source":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."}]},{"pos":[52575,52615],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[52704,52753],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[52870,52977],"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","pos":[0,107]}]},{"pos":[53084,53146],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[54426,54514],"content":"When overridden in a derived class, begins an asynchronous reserve and append operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous reserve and append operation.","pos":[0,88]}]},{"pos":[54527,56074],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,236],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[237,467],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[474,587],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[588,686]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[693,823]},{"content":"If the append fails, no space is reserved.","pos":[824,866]},{"content":"Normally, this method may complete before the record has been written.","pos":[873,943]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[944,1159],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1166,1301]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1302,1539],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called."}]},{"pos":[56594,56677],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[56763,56830],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[56916,56973],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[57069,57187],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[57287,57338],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[57408,57443],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[57515,57591],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[57653,57759],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[57823,57927],"content":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.","pos":[0,104],"source":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."}]},{"pos":[58101,58141],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[58230,58279],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[58396,58503],"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","pos":[0,107]}]},{"pos":[58610,58672],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[59578,59715],"content":"When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.","pos":[0,137]}]},{"pos":[59728,61367],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method, to assure that the restart area write operation has completed and resources can be freed appropriately.","pos":[0,249],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[250,502],"source":" If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[509,622],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[623,721]},{"content":"When the operation successfully completes, the base sequence number has been updated.","pos":[728,813]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[814,908]},{"content":"If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[915,1104],"source":"       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection."},{"content":"If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.","pos":[1105,1251]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1258,1393]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method is called.","pos":[1394,1631],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called."}]},{"pos":[61695,61778],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[61871,61997],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[62087,62218],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[62290,62378],"content":"An optional asynchronous callback, to be called when the restart area write is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the restart area write is complete.","pos":[0,88]}]},{"pos":[62440,62558],"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","pos":[0,118]}]},{"pos":[62622,62744],"content":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.","pos":[0,122],"source":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."}]},{"pos":[63821,63958],"content":"When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.","pos":[0,137]}]},{"pos":[63971,65609],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method to ensure that the restart area write operation has completed and resources can be freed appropriately.","pos":[0,248],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[249,501],"source":" If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[508,621],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[622,720]},{"content":"When the operation successfully completes, the base sequence number has been updated.","pos":[727,812]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[813,907]},{"content":"If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[914,1103],"source":"       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection."},{"content":"If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.","pos":[1104,1250]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1257,1392]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A&gt; method is called.","pos":[1393,1630],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called."}]},{"pos":[66005,66088],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[66181,66307],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[66397,66528],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[66600,66688],"content":"An optional asynchronous callback, to be called when the restart area write is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the restart area write is complete.","pos":[0,88]}]},{"pos":[66750,66868],"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","pos":[0,118]}]},{"pos":[66932,67054],"content":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.","pos":[0,122],"source":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."}]},{"pos":[67228,67268],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[67357,67410],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[67527,67606],"content":"The record sequence could not make enough free space to contain the new record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record.","pos":[0,79]}]},{"pos":[67713,67775],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[68215,68322],"content":"When overridden in a derived class, creates a new <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, creates a new <xref href=\"System.IO.Log.ReservationCollection\"></xref>."},{"pos":[68519,68594],"content":"The newly created <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The newly created <xref href=\"System.IO.Log.ReservationCollection\"></xref>."},{"pos":[68786,68848],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[69276,69350],"content":"When overridden in a derived class, ends an asynchronous append operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ends an asynchronous append operation.","pos":[0,74]}]},{"pos":[69363,69724],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.","pos":[0,359],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.","pos":[58,201]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.IRecordSequence.BeginAppend%2A&gt; method.","pos":[208,359],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method."}]}]},{"pos":[69902,69958],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[70031,70078],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[70240,70280],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[70387,70449],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[70872,70945],"content":"When overridden in a derived class, ends an asynchronous flush operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ends an asynchronous flush operation.","pos":[0,73]}]},{"pos":[70958,71317],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.","pos":[0,357],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.","pos":[58,200]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.IRecordSequence.BeginFlush%2A&gt; method.","pos":[207,357],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method."}]}]},{"pos":[71494,71550],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[71623,71670],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[71831,71871],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[71978,72040],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[72518,72604],"content":"When overridden in a derived class, ends an asynchronous reserve and append operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ends an asynchronous reserve and append operation.","pos":[0,86]}]},{"pos":[72617,72998],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.","pos":[0,379],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.","pos":[58,211]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A&gt; method.","pos":[218,379],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method."}]}]},{"pos":[73186,73242],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[73315,73362],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[73534,73574],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[73681,73743],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[74221,74307],"content":"When overridden in a derived class, ends an asynchronous restart area write operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ends an asynchronous restart area write operation.","pos":[0,86]}]},{"pos":[74320,74701],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.","pos":[0,379],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.","pos":[58,211]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A&gt; method.","pos":[218,379],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method."}]}]},{"pos":[74889,74945],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[75018,75064],"content":"The sequence number of the written log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written log record.","pos":[0,46]}]},{"pos":[75236,75276],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[75383,75445],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[75775,75863],"content":"When overridden in a derived class, ensures that all appended records have been written.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ensures that all appended records have been written.","pos":[0,88]}]},{"pos":[75875,76014],"content":"Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.IRecordSequence&gt; have been durably written.","pos":[0,139],"source":"Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written."}]},{"pos":[76175,76222],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[76374,76420],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[76527,76589],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[77021,77183],"content":"When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.","pos":[0,162]}]},{"pos":[77195,77338],"content":"Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.","pos":[0,143]}]},{"pos":[77552,77718],"content":"The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the latest record that must be written.","pos":[0,62]},{"content":"If this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.SequenceNumber\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is invalid, then all records must be written.","pos":[63,166],"source":" If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written."}]},{"pos":[77791,77838],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[77996,78036],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[78125,78171],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[78278,78340],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[78731,78839],"content":"When overridden in a derived class, gets the sequence number which is greater than the last record appended.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, gets the sequence number which is greater than the last record appended.","pos":[0,108]}]},{"pos":[78852,79476],"content":"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber.      > [!NOTE] >  When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log. See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records..","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.","pos":[0,126]},{"content":"Valid sequence numbers are greater than or equal to &lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt; and less than LastSequenceNumber.","pos":[127,271],"source":" Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  When using a &lt;xref:System.IO.Log.LogRecordSequence&gt; instance, the &lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt; value can become out of date until records are flushed to the log.","pos":[277,483],"source":"      > [!NOTE] >  When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log."},{"content":"See &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; and &lt;xref:System.IO.Log.RecordAppendOptions&gt; for more information on flushing records..","pos":[484,621],"source":" See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records.."}]},{"pos":[79637,79702],"content":"A sequence number which is greater than the last record appended.","needQuote":true,"needEscape":true,"nodes":[{"content":"A sequence number which is greater than the last record appended.","pos":[0,65]}]},{"pos":[79885,79951],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[80347,80480],"content":"When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.","pos":[0,133]}]},{"pos":[80601,80693],"content":"The size of the largest record that can be appended to or read from this sequence, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the largest record that can be appended to or read from this sequence, in bytes.","pos":[0,92]}]},{"pos":[80877,80943],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[81568,81664],"content":"When overridden in a derived class, returns an enumerable collection of records in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, returns an enumerable collection of records in the sequence.","pos":[0,96]}]},{"pos":[81676,81863],"content":"When overridden in a derived class, returns an enumerable collection of records in the sequence. The order of the enumerated records depends on the value of the `logRecordEnum` parameter.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"When overridden in a derived class, returns an enumerable collection of records in the sequence.","pos":[0,96]},{"content":"The order of the enumerated records depends on the value of the <ph id=\"ph1\">`logRecordEnum`</ph> parameter.","pos":[97,187],"source":" The order of the enumerated records depends on the value of the `logRecordEnum` parameter."}]},{"pos":[85689,85754],"content":"The sequence number of the first record where the reading starts.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the first record where the reading starts.","pos":[0,65]}]},{"pos":[85848,86070],"content":"A valid <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.LogRecordEnumeratorType\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value that specifies the manner (that is, forward or backward) in which records should be read from a <bpt id=\"p2\">&lt;xref href=\"System.IO.Log.LogRecordSequence\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"A valid <xref href=\"System.IO.Log.LogRecordEnumeratorType\"></xref> value that specifies the manner (that is, forward or backward) in which records should be read from a <xref href=\"System.IO.Log.LogRecordSequence\"></xref>."},{"pos":[86178,86230],"content":"An enumerable collection of records in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An enumerable collection of records in the sequence.","pos":[0,52]}]},{"pos":[86397,86437],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[86526,86573],"content":"An I/O error occurred while reading the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while reading the record.","pos":[0,47]}]},{"pos":[86680,86742],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[87127,87233],"content":"When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.","pos":[0,106]}]},{"pos":[87246,87843],"content":"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.      > [!NOTE] >  If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message \"The request could not be performed because of an unexpected I/O exception. The following error code was returned: '80070026'\".","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.","pos":[0,139]},{"content":"Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.","pos":[140,258]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  If the log extent containing the &lt;xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A&gt; becomes corrupted, this method can throw an &lt;xref:System.IO.IOException&gt; with the error message \"The request could not be performed because of an unexpected I/O exception.","pos":[264,540],"source":"      > [!NOTE] >  If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message \"The request could not be performed because of an unexpected I/O exception."},{"content":"The following error code was returned: '80070026'\".","pos":[541,592]}]},{"pos":[88086,88148],"content":"An enumerable collection of the restart areas in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An enumerable collection of the restart areas in the sequence.","pos":[0,62]}]},{"pos":[88317,88357],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[88446,88493],"content":"An I/O error occurred while reading the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while reading the record.","pos":[0,47]}]},{"pos":[88600,88662],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[89695,89809],"content":"When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.","pos":[0,114]}]},{"pos":[89822,90511],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[219,349]},{"content":"If the append fails, no space is reserved.","pos":[350,392]},{"content":"Normally, this method may complete before the record has been written.","pos":[399,469]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[470,685],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[90936,91019],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[91105,91172],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[91258,91315],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[91411,91529],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[91629,91741],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the collection to make reservations in.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the collection to make reservations in."},{"pos":[91811,91846],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[91919,91966],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[92135,92175],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[92264,92313],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[92430,92537],"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","pos":[0,107]}]},{"pos":[92644,92706],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[93828,93942],"content":"When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.","pos":[0,114]}]},{"pos":[93955,94644],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[219,349]},{"content":"If the append fails, no space is reserved.","pos":[350,392]},{"content":"Normally, this method may complete before the record has been written.","pos":[399,469]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt; method.","pos":[470,685],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method."}]},{"pos":[95137,95220],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[95306,95373],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[95459,95516],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[95612,95730],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[95830,95881],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[95951,95986],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[96059,96106],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[96275,96315],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[96404,96453],"content":"An I/O error occurred while appending the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while appending the record.","pos":[0,49]}]},{"pos":[96570,96677],"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new record, or to make the reservation.","pos":[0,107]}]},{"pos":[96784,96846],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[97212,97303],"content":"When overridden in a derived class, gets the total number of bytes that have been reserved.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, gets the total number of bytes that have been reserved.","pos":[0,91]}]},{"pos":[97418,97482],"content":"The total size of all reservations made in this record sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"The total size of all reservations made in this record sequence.","pos":[0,64]}]},{"pos":[97660,97726],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[98132,98235],"content":"When overridden in a derived class, gets the sequence number of the most recently written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"When overridden in a derived class, gets the sequence number of the most recently written restart area.","pos":[0,103]}]},{"pos":[98247,98602],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[0,355],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]}]}]},{"pos":[98765,98827],"content":"The sequence number of the most recently written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the most recently written restart area.","pos":[0,62]}]},{"pos":[99013,99079],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[99435,99528],"content":"Gets or sets a value indicating whether appends are automatically retried if the log is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets a value indicating whether appends are automatically retried if the log is full.","pos":[0,93]}]},{"pos":[99540,99761],"content":"If the value of this property is <ph id=\"ph1\">`true`</ph>, and an &lt;xref:System.IO.Log.IRecordSequence.Append%2A&gt; call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.","needQuote":true,"needEscape":true,"extradata":"MT","source":"If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append."},{"pos":[99881,100150],"content":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>. The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.","needQuote":true,"needEscape":true,"nodes":[{"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if appends are automatically retried if the log is full; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[0,192],"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"content":"The default is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[193,269],"source":" The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>."}]},{"pos":[100326,100392],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[100740,100819],"content":"Occurs when the record sequence determines that the tail must be moved forward.","needQuote":true,"needEscape":true,"nodes":[{"content":"Occurs when the record sequence determines that the tail must be moved forward.","pos":[0,79]}]},{"pos":[100831,101023],"content":"You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","pos":[0,192],"nodes":[{"content":"You can fire this event when the record sequence has run out of space.","pos":[0,70]},{"content":"When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","pos":[71,192]}]}]},{"pos":[101218,101230],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[101754,101870],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[101883,102681],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","pos":[0,794],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.","pos":[105,229]},{"content":"When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.","pos":[230,344]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[345,473]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[480,581],"source":"       A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"The data in the byte array segments will be concatenated into a single byte array for appending as the record.","pos":[588,698]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[699,794]}]}]},{"pos":[102881,102964],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[103037,103085],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[103254,103294],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[103383,103436],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[103553,103638],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[103745,103807],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[104403,104519],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>."},{"pos":[104532,105204],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","pos":[0,670],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[356,457],"source":" A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"The data in the byte array segments will be concatenated into a single byte array for appending as the record.","pos":[464,574]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[575,670]}]}]},{"pos":[105472,105555],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[105628,105676],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[105845,105885],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[105974,106027],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[106144,106229],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[106336,106398],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[107008,107160],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and updates the base sequence number","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> and updates the base sequence number"},{"pos":[107173,108060],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[0,883],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[356,457],"source":" A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[464,602]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[603,698]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[705,788]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[789,883]}]}]},{"pos":[108312,108395],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[108488,108614],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[108687,108735],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[108904,108944],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[109033,109086],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[109203,109288],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[109395,109457],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[110156,110309],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and updates the base sequence number.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> and updates the base sequence number."},{"pos":[110322,111209],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[0,883],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[356,457],"source":" A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[464,602]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[603,698]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[705,788]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[789,883]}]}]},{"pos":[111529,111612],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[111705,111831],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[111904,111952],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[112121,112161],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[112250,112303],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[112420,112505],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[112612,112674],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[113422,113595],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> using a reservation, and updates the base sequence number","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> using a reservation, and updates the base sequence number"},{"pos":[113608,115194],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","pos":[0,1578],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[356,457],"source":" A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[464,602]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[603,698]},{"content":"If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[705,863]},{"content":"If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.","pos":[864,1013]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[1020,1103]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[1104,1198]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1205,1340]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1341,1578],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called."}]}]},{"pos":[115495,115578],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[115671,115797],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[115887,116018],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[116091,116139],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[116308,116348],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[116437,116490],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[116607,116692],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[116799,116861],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[117698,117872],"content":"When overridden in a derived class, writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> using a reservation, and updates the base sequence number.","needQuote":true,"needEscape":true,"source":"When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> using a reservation, and updates the base sequence number."},{"pos":[117885,119471],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.","pos":[0,1578],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.","pos":[105,226]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[227,355]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[356,457],"source":" A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[464,602]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[603,698]},{"content":"If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[705,863]},{"content":"If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.","pos":[864,1013]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[1020,1103]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[1104,1198]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1205,1340]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1341,1578],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called."}]}]},{"pos":[119840,119923],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[120016,120142],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[120232,120363],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[120436,120484],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[120653,120693],"content":"One or more of the arguments is invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]}]},{"pos":[120782,120835],"content":"An I/O error occurred while writing the restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while writing the restart area.","pos":[0,53]}]},{"pos":[120952,121037],"content":"The record sequence could not make enough free space to contain the new restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence could not make enough free space to contain the new restart area.","pos":[0,85]}]},{"pos":[121144,121206],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.IO.Log.IRecordSequence\n  id: IRecordSequence\n  children:\n  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  - System.IO.Log.IRecordSequence.BaseSequenceNumber\n  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.IRecordSequence.CreateReservationCollection\n  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)\n  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)\n  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  - System.IO.Log.IRecordSequence.Flush\n  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  - System.IO.Log.IRecordSequence.LastSequenceNumber\n  - System.IO.Log.IRecordSequence.MaximumRecordLength\n  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  - System.IO.Log.IRecordSequence.ReadRestartAreas\n  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  - System.IO.Log.IRecordSequence.ReservedBytes\n  - System.IO.Log.IRecordSequence.RestartSequenceNumber\n  - System.IO.Log.IRecordSequence.RetryAppend\n  - System.IO.Log.IRecordSequence.TailPinned\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  langs:\n  - csharp\n  name: IRecordSequence\n  nameWithType: IRecordSequence\n  fullName: System.IO.Log.IRecordSequence\n  type: Interface\n  summary: Provides a generic interface to a sequence of records.\n  remarks: \"The IRecordSequence interface provides an abstract interface to a record-oriented stream. A IRecordSequence instance can be used to read and write log records.  \\n  \\n The IRecordSequence interface provides the following capabilities,  \\n  \\n-   Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.  \\n  \\n-   Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.  \\n  \\n-   Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.  \\n  \\n-   Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n-   Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.  \\n  \\n-   Reserve space for appending records.  \\n  \\n-   Free log space by advancing the base of the log.  \\n  \\n-   Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.  \\n  \\n Log records are appended to a IRecordSequence instance, and each log record is given a unique sequence number. Sequence numbers are strictly monotonically increasing within a given record sequence. A log record consists of opaque data, supplied to the IRecordSequence instance in an <xref:System.Collections.IList> of ArraySegments of bytes.  \\n  \\n The IRecordSequence interface also exposes a few basic properties which provides information about log boundaries.  \\n  \\n-   The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.  \\n  \\n-   The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.  \\n  \\n-   The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.  \\n  \\n-   The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.  \\n  \\n-   The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.  \\n  \\n-   If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.\"\n  syntax:\n    content: 'public interface IRecordSequence : IDisposable'\n  implements:\n  - System.IDisposable\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: AdvanceBaseSequenceNumber(SequenceNumber)\n  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Moves the base sequence number of the log forward.\n  remarks: When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty. Freeing extents partially is not supported.\n  syntax:\n    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);\n    parameters:\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number of the record sequence.\n  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>newBaseSequenceNumber</code> is invalid.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>newBaseSequenceNumber</code> is not active in the log.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while modifying the sequence.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>, using space previously reserved in the sequence.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, appends a log record to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>, using space previously reserved in the sequence.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber\n  id: BaseSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BaseSequenceNumber\n  nameWithType: IRecordSequence.BaseSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, gets the sequence number of the first valid record in the current <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  remarks: \"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  \\n  \\n The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The lowest sequence number that corresponds to a valid record in the <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous append operation.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginFlush(SequenceNumber,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);\n    parameters:\n    - id: sequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the flush is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous flush request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginFlush*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous reserve and append operation.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record, or to make the reservation.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous reserve and append operation.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record, or to make the reservation.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the restart area write is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the restart area write is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.\n  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.CreateReservationCollection\n  id: CreateReservationCollection\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: CreateReservationCollection()\n  nameWithType: IRecordSequence.CreateReservationCollection()\n  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, creates a new <xref href=\"System.IO.Log.ReservationCollection\"></xref>.\n  syntax:\n    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();\n    parameters: []\n    return:\n      type: System.IO.Log.ReservationCollection\n      description: The newly created <xref href=\"System.IO.Log.ReservationCollection\"></xref>.\n  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)\n  id: EndAppend(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: EndAppend(IAsyncResult)\n  nameWithType: IRecordSequence.EndAppend(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ends an asynchronous append operation.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.EndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)\n  id: EndFlush(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: EndFlush(IAsyncResult)\n  nameWithType: IRecordSequence.EndFlush(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ends an asynchronous flush operation.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.IRecordSequence.EndFlush*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  id: EndReserveAndAppend(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: EndReserveAndAppend(IAsyncResult)\n  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ends an asynchronous reserve and append operation.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  id: EndWriteRestartArea(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: EndWriteRestartArea(IAsyncResult)\n  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ends an asynchronous restart area write operation.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written log record.\n  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Flush\n  id: Flush\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Flush()\n  nameWithType: IRecordSequence.Flush()\n  fullName: System.IO.Log.IRecordSequence.Flush()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ensures that all appended records have been written.\n  remarks: Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.\n  syntax:\n    content: public System.IO.Log.SequenceNumber Flush ();\n    parameters: []\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.IRecordSequence.Flush*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  id: Flush(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: Flush(SequenceNumber)\n  nameWithType: IRecordSequence.Flush(SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.\n  remarks: Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.\n  syntax:\n    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);\n    parameters:\n    - id: sequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.IRecordSequence.Flush*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.LastSequenceNumber\n  id: LastSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: LastSequenceNumber\n  nameWithType: IRecordSequence.LastSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, gets the sequence number which is greater than the last record appended.\n  remarks: \"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber.  \\n  \\n> [!NOTE]\\n>  When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log. See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records..\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: A sequence number which is greater than the last record appended.\n  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.MaximumRecordLength\n  id: MaximumRecordLength\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: MaximumRecordLength\n  nameWithType: IRecordSequence.MaximumRecordLength\n  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.\n  syntax:\n    content: public long MaximumRecordLength { get; }\n    return:\n      type: System.Int64\n      description: The size of the largest record that can be appended to or read from this sequence, in bytes.\n  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, returns an enumerable collection of records in the sequence.\n  remarks: When overridden in a derived class, returns an enumerable collection of records in the sequence. The order of the enumerated records depends on the value of the `logRecordEnum` parameter.\n  example:\n  - \"This sample demonstrates the use of the ReadLogRecords method.  \\n  \\n```c#  \\nusing System;  \\n using System.IO;  \\n using System.IO.Log;  \\n  \\n class ReadRecordsSample  \\n {  \\n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \\n                                        string message,  \\n                                        SequenceNumber user,  \\n                                        SequenceNumber previous)  \\n     {  \\n         MemoryStream data = new MemoryStream();  \\n         BinaryWriter writer = new BinaryWriter(data);  \\n         writer.Write(message);  \\n  \\n         ArraySegment<byte>[] segments;  \\n         segments = new ArraySegment<byte>[1];  \\n         segments[0] = new ArraySegment(data.GetBuffer(),  \\n                                        0,  \\n                                        Data.Length);  \\n  \\n         return sequence.Append(segments,  \\n                                user,  \\n                                previous,  \\n                                WriteFlags.None);  \\n     }  \\n  \\n     public static void Main(string[] args)  \\n     {  \\n         IRecordSequence sequence;  \\n         sequence = new FileIRecordSequence(args[0]);  \\n  \\n         SequenceNumber a, b, c, d;  \\n  \\n         a = AppendRecord(sequence,  \\n                          \\\"This is record A\\\",  \\n                          SequenceNumber.Invalid,  \\n                          SequenceNumber.Invalid);  \\n         Console.WriteLine(\\\"Record A has sequence number System.IO.Log\\\", a);  \\n  \\n         b = AppendRecord(sequence,  \\n                          \\\"This is record B\\\",  \\n                          a,  \\n                          a);  \\n         Console.WriteLine(\\\"Record B has sequence number System.IO.Log\\\", b);  \\n  \\n         c = AppendRecord(sequence,  \\n                          \\\"This is record C\\\",  \\n                          a,  \\n                          a);  \\n         Console.WriteLine(\\\"Record C has sequence number System.IO.Log\\\", c);  \\n  \\n         d = AppendRecord(sequence,  \\n                          \\\"This is record D\\\",  \\n                          b,  \\n                          c);  \\n         Console.WriteLine(\\\"Record D has sequence number System.IO.Log\\\", d);  \\n  \\n         foreach(LogRecord record in  \\n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \\n         {  \\n             BinaryReader reader = new BinaryReader(record.Data);  \\n             Console.WriteLine(\\\"System.IO.Log: T:System.IO.Log.IRecordSequence\\\",  \\n                               record.SequenceNumber,  \\n                               reader.ReadString());  \\n         }  \\n  \\n         foreach(LogRecord record in  \\n                 sequence.ReadLogRecords(d, ReadDirection.User))  \\n         {  \\n             BinaryReader reader = new BinaryReader(record.Data);  \\n             Console.WriteLine(\\\"System.IO.Log: T:System.IO.Log.IRecordSequence\\\",  \\n                               record.SequenceNumber,  \\n                               reader.ReadString());  \\n         }  \\n  \\n         foreach(LogRecord record in  \\n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \\n         {  \\n             BinaryReader reader = new BinaryReader(record.Data);  \\n             Console.WriteLine(\\\"System.IO.Log: T:System.IO.Log.IRecordSequence\\\",  \\n                               record.SequenceNumber,  \\n                               reader.ReadString());  \\n         }  \\n     }  \\n       }  \\n```\"\n  syntax:\n    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);\n    parameters:\n    - id: start\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the first record where the reading starts.\n    - id: logRecordEnum\n      type: System.IO.Log.LogRecordEnumeratorType\n      description: A valid <xref href=\"System.IO.Log.LogRecordEnumeratorType\"></xref> value that specifies the manner (that is, forward or backward) in which records should be read from a <xref href=\"System.IO.Log.LogRecordSequence\"></xref>.\n    return:\n      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n      description: An enumerable collection of records in the sequence.\n  overload: System.IO.Log.IRecordSequence.ReadLogRecords*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while reading the record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.ReadRestartAreas\n  id: ReadRestartAreas\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: ReadRestartAreas()\n  nameWithType: IRecordSequence.ReadRestartAreas()\n  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.\n  remarks: \"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.  \\n  \\n> [!NOTE]\\n>  If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message \\\"The request could not be performed because of an unexpected I/O exception. The following error code was returned: '80070026'\\\".\"\n  syntax:\n    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();\n    parameters: []\n    return:\n      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n      description: An enumerable collection of the restart areas in the sequence.\n  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while reading the record.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record, or to make the reservation.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while appending the record.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new record, or to make the reservation.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.ReservedBytes\n  id: ReservedBytes\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: ReservedBytes\n  nameWithType: IRecordSequence.ReservedBytes\n  fullName: System.IO.Log.IRecordSequence.ReservedBytes\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, gets the total number of bytes that have been reserved.\n  syntax:\n    content: public long ReservedBytes { get; }\n    return:\n      type: System.Int64\n      description: The total size of all reservations made in this record sequence.\n  overload: System.IO.Log.IRecordSequence.ReservedBytes*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber\n  id: RestartSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: RestartSequenceNumber\n  nameWithType: IRecordSequence.RestartSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, gets the sequence number of the most recently written restart area.\n  remarks: A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.\n  syntax:\n    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the most recently written restart area.\n  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.RetryAppend\n  id: RetryAppend\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: RetryAppend\n  nameWithType: IRecordSequence.RetryAppend\n  fullName: System.IO.Log.IRecordSequence.RetryAppend\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets or sets a value indicating whether appends are automatically retried if the log is full.\n  remarks: If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.\n  syntax:\n    content: public bool RetryAppend { get; set; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>. The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.\n  overload: System.IO.Log.IRecordSequence.RetryAppend*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.TailPinned\n  id: TailPinned\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: TailPinned\n  nameWithType: IRecordSequence.TailPinned\n  fullName: System.IO.Log.IRecordSequence.TailPinned\n  type: Event\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Occurs when the record sequence determines that the tail must be moved forward.\n  remarks: You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.\n  syntax:\n    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;\n    return:\n      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  id: WriteRestartArea(System.ArraySegment{System.Byte})\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref>.\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> and updates the base sequence number\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> and updates the base sequence number.\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> using a reservation, and updates the base sequence number\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: When overridden in a derived class, writes a restart area to the <xref href=\"System.IO.Log.IRecordSequence\"></xref> using a reservation, and updates the base sequence number.\n  remarks: \"A restart area is used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process. A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.IRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: One or more of the arguments is invalid.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while writing the restart area.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence could not make enough free space to contain the new restart area.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  platform:\n  - net462\nreferences:\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.IO.IOException\n  isExternal: true\n  name: System.IO.IOException\n- uid: System.ObjectDisposedException\n  isExternal: true\n  name: System.ObjectDisposedException\n- uid: System.IO.Log.SequenceFullException\n  parent: System.IO.Log\n  isExternal: false\n  name: SequenceFullException\n  nameWithType: SequenceFullException\n  fullName: System.IO.Log.SequenceFullException\n- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: AdvanceBaseSequenceNumber(SequenceNumber)\n  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n- uid: System.IO.Log.SequenceNumber\n  parent: System.IO.Log\n  isExternal: false\n  name: SequenceNumber\n  nameWithType: SequenceNumber\n  fullName: System.IO.Log.SequenceNumber\n- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n- uid: System.ArraySegment{System.Byte}\n  parent: System\n  isExternal: true\n  name: ArraySegment<Byte>\n  nameWithType: ArraySegment<Byte>\n  fullName: System.ArraySegment<System.Byte>\n  spec.csharp:\n  - uid: System.ArraySegment`1\n    name: ArraySegment\n    nameWithType: ArraySegment\n    fullName: ArraySegment<System.Byte>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.RecordAppendOptions\n  parent: System.IO.Log\n  isExternal: false\n  name: RecordAppendOptions\n  nameWithType: RecordAppendOptions\n  fullName: System.IO.Log.RecordAppendOptions\n- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n  parent: System.Collections.Generic\n  isExternal: true\n  name: IList<ArraySegment<Byte>>\n  nameWithType: IList<ArraySegment<Byte>>\n  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    nameWithType: IList\n    fullName: IList<System.ArraySegment<System.Byte>>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.ArraySegment`1\n    name: ArraySegment\n    nameWithType: ArraySegment\n    fullName: ArraySegment<System.Byte>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n- uid: System.IO.Log.ReservationCollection\n  parent: System.IO.Log\n  isExternal: false\n  name: ReservationCollection\n  nameWithType: ReservationCollection\n  fullName: System.IO.Log.ReservationCollection\n- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BaseSequenceNumber\n  nameWithType: IRecordSequence.BaseSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: true\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: true\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.Object\n  parent: System\n  isExternal: true\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginFlush(SequenceNumber,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n- uid: System.Int64[]\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64[]\n  spec.csharp:\n  - uid: System.Int64\n    name: Int64\n    nameWithType: Int64\n    fullName: Int64[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.IRecordSequence.CreateReservationCollection\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: CreateReservationCollection()\n  nameWithType: IRecordSequence.CreateReservationCollection()\n  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()\n- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndAppend(IAsyncResult)\n  nameWithType: IRecordSequence.EndAppend(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)\n- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndFlush(IAsyncResult)\n  nameWithType: IRecordSequence.EndFlush(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)\n- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndReserveAndAppend(IAsyncResult)\n  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)\n- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndWriteRestartArea(IAsyncResult)\n  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)\n  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)\n- uid: System.IO.Log.IRecordSequence.Flush\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Flush()\n  nameWithType: IRecordSequence.Flush()\n  fullName: System.IO.Log.IRecordSequence.Flush()\n- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Flush(SequenceNumber)\n  nameWithType: IRecordSequence.Flush(SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)\n- uid: System.IO.Log.IRecordSequence.LastSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: LastSequenceNumber\n  nameWithType: IRecordSequence.LastSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber\n- uid: System.IO.Log.IRecordSequence.MaximumRecordLength\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: MaximumRecordLength\n  nameWithType: IRecordSequence.MaximumRecordLength\n  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength\n- uid: System.Int64\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n  parent: System.Collections.Generic\n  isExternal: true\n  name: IEnumerable<LogRecord>\n  nameWithType: IEnumerable<LogRecord>\n  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    nameWithType: IEnumerable\n    fullName: IEnumerable<System.IO.Log.LogRecord>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.IO.Log.LogRecord\n    name: LogRecord\n    nameWithType: LogRecord\n    fullName: LogRecord\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.LogRecordEnumeratorType\n  parent: System.IO.Log\n  isExternal: false\n  name: LogRecordEnumeratorType\n  nameWithType: LogRecordEnumeratorType\n  fullName: System.IO.Log.LogRecordEnumeratorType\n- uid: System.IO.Log.IRecordSequence.ReadRestartAreas\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReadRestartAreas()\n  nameWithType: IRecordSequence.ReadRestartAreas()\n  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()\n- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n- uid: System.IO.Log.IRecordSequence.ReservedBytes\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReservedBytes\n  nameWithType: IRecordSequence.ReservedBytes\n  fullName: System.IO.Log.IRecordSequence.ReservedBytes\n- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: RestartSequenceNumber\n  nameWithType: IRecordSequence.RestartSequenceNumber\n  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber\n- uid: System.IO.Log.IRecordSequence.RetryAppend\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: RetryAppend\n  nameWithType: IRecordSequence.RetryAppend\n  fullName: System.IO.Log.IRecordSequence.RetryAppend\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.IO.Log.IRecordSequence.TailPinned\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: TailPinned\n  nameWithType: IRecordSequence.TailPinned\n  fullName: System.IO.Log.IRecordSequence.TailPinned\n- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}\n  parent: System\n  isExternal: true\n  name: EventHandler<TailPinnedEventArgs>\n  nameWithType: EventHandler<TailPinnedEventArgs>\n  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>\n  spec.csharp:\n  - uid: System.EventHandler`1\n    name: EventHandler\n    nameWithType: EventHandler\n    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.IO.Log.TailPinnedEventArgs\n    name: TailPinnedEventArgs\n    nameWithType: TailPinnedEventArgs\n    fullName: TailPinnedEventArgs\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: AdvanceBaseSequenceNumber\n  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber\n- uid: System.IO.Log.IRecordSequence.Append*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Append\n  nameWithType: IRecordSequence.Append\n- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BaseSequenceNumber\n  nameWithType: IRecordSequence.BaseSequenceNumber\n- uid: System.IO.Log.IRecordSequence.BeginAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginAppend\n  nameWithType: IRecordSequence.BeginAppend\n- uid: System.IO.Log.IRecordSequence.BeginFlush*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginFlush\n  nameWithType: IRecordSequence.BeginFlush\n- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend\n  nameWithType: IRecordSequence.BeginReserveAndAppend\n- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea\n  nameWithType: IRecordSequence.BeginWriteRestartArea\n- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: CreateReservationCollection\n  nameWithType: IRecordSequence.CreateReservationCollection\n- uid: System.IO.Log.IRecordSequence.EndAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndAppend\n  nameWithType: IRecordSequence.EndAppend\n- uid: System.IO.Log.IRecordSequence.EndFlush*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndFlush\n  nameWithType: IRecordSequence.EndFlush\n- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndReserveAndAppend\n  nameWithType: IRecordSequence.EndReserveAndAppend\n- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: EndWriteRestartArea\n  nameWithType: IRecordSequence.EndWriteRestartArea\n- uid: System.IO.Log.IRecordSequence.Flush*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: Flush\n  nameWithType: IRecordSequence.Flush\n- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: LastSequenceNumber\n  nameWithType: IRecordSequence.LastSequenceNumber\n- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: MaximumRecordLength\n  nameWithType: IRecordSequence.MaximumRecordLength\n- uid: System.IO.Log.IRecordSequence.ReadLogRecords*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReadLogRecords\n  nameWithType: IRecordSequence.ReadLogRecords\n- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReadRestartAreas\n  nameWithType: IRecordSequence.ReadRestartAreas\n- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReserveAndAppend\n  nameWithType: IRecordSequence.ReserveAndAppend\n- uid: System.IO.Log.IRecordSequence.ReservedBytes*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: ReservedBytes\n  nameWithType: IRecordSequence.ReservedBytes\n- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: RestartSequenceNumber\n  nameWithType: IRecordSequence.RestartSequenceNumber\n- uid: System.IO.Log.IRecordSequence.RetryAppend*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: RetryAppend\n  nameWithType: IRecordSequence.RetryAppend\n- uid: System.IO.Log.IRecordSequence.WriteRestartArea*\n  parent: System.IO.Log.IRecordSequence\n  isExternal: false\n  name: WriteRestartArea\n  nameWithType: IRecordSequence.WriteRestartArea\n"}