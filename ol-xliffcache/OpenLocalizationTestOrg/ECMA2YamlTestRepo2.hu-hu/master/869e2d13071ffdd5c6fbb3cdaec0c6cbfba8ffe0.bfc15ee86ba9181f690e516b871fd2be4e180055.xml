{"nodes":[{"pos":[1649,1751],"content":"Adds a buffering layer to read and write operations on another stream. This class cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Adds a buffering layer to read and write operations on another stream. This class cannot be inherited.","pos":[0,102],"nodes":[{"content":"Adds a buffering layer to read and write operations on another stream.","pos":[0,70]},{"content":"This class cannot be inherited.","pos":[71,102]}]}]},{"pos":[5555,5682],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.IO.BufferedStream\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with a default buffer size of 4096 bytes.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.IO.BufferedStream\"></xref> class with a default buffer size of 4096 bytes."},{"pos":[5694,5909],"content":"A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor. The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"A shared read/write buffer is allocated the first time a <ph id=\"ph1\">`BufferedStream`</ph> object is initialized with this constructor.","pos":[0,118],"source":"A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor."},{"content":"The shared buffer is not used if all reads and writes are greater than or equal to <ph id=\"ph1\">`bufferSize`</ph>.","pos":[119,215],"source":" The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`."}]},{"pos":[6063,6082],"content":"The current stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The current stream.","pos":[0,19]}]},{"pos":[6243,6327],"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[6764,6881],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.IO.BufferedStream\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with the specified buffer size.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.IO.BufferedStream\"></xref> class with the specified buffer size."},{"pos":[6893,7108],"content":"A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor. The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"A shared read/write buffer is allocated the first time a <ph id=\"ph1\">`BufferedStream`</ph> object is initialized with this constructor.","pos":[0,118],"source":"A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor."},{"content":"The shared buffer is not used if all reads and writes are greater than or equal to <ph id=\"ph1\">`bufferSize`</ph>.","pos":[119,215],"source":" The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`."}]},{"pos":[7707,7726],"content":"The current stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The current stream.","pos":[0,19]}]},{"pos":[7792,7817],"content":"The buffer size in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer size in bytes.","pos":[0,25]}]},{"pos":[7978,8062],"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[8177,8213],"content":"<ph id=\"ph1\">&lt;code&gt;bufferSize&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>bufferSize</code> is negative."},{"pos":[8807,8939],"content":"Begins an asynchronous read operation. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous read operation. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)","pos":[0,132],"nodes":[{"content":"Begins an asynchronous read operation.","pos":[0,38]},{"content":"(Consider using &lt;xref:System.IO.BufferedStream.ReadAsync*&gt; instead; see the Remarks section.)","pos":[39,132],"source":" (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)"}]}]},{"pos":[8952,10017],"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.       <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to BeginRead. Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.      > [!NOTE] >  Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.       <xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as &lt;xref:System.IO.Stream.BeginRead%2A&gt; and &lt;xref:System.IO.Stream.EndRead%2A&gt; to implement asynchronous file operations.","pos":[0,196],"source":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations."},{"content":"These methods are still available in the <ph id=\"ph1\">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> to support legacy code; however, the new async methods, such as &lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;, &lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;, and &lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;, help you implement asynchronous file operations more easily.","pos":[197,565],"source":" These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily."},{"content":"&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt; must be called exactly once for every call to BeginRead.","pos":[572,672],"source":"       <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to BeginRead."},{"content":"Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.","pos":[673,781]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Use the &lt;xref:System.IO.BufferedStream.CanRead%2A&gt; property to determine whether the current instance supports reading.","pos":[787,919],"source":"      > [!NOTE] >  Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading."},{"content":"&lt;xref:System.IO.BufferedStream.EndRead%2A&gt; must be called with this &lt;xref:System.IAsyncResult&gt; to find out how many bytes were read.","pos":[926,1058],"source":"       <xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read."}]},{"pos":[10237,10270],"content":"The buffer to read the data into.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer to read the data into.","pos":[0,33]}]},{"pos":[10332,10412],"content":"The byte offset in <ph id=\"ph1\">`buffer`</ph> at which to begin writing data read from the stream.","needQuote":true,"needEscape":true,"source":"The byte offset in `buffer` at which to begin writing data read from the stream."},{"pos":[10473,10509],"content":"The maximum number of bytes to read.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of bytes to read.","pos":[0,36]}]},{"pos":[10581,10655],"content":"An optional asynchronous callback, to be called when the read is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the read is complete.","pos":[0,74]}]},{"pos":[10717,10821],"content":"A user-provided object that distinguishes this particular asynchronous read request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous read request from other requests.","pos":[0,104]}]},{"pos":[10885,10963],"content":"An object that represents the asynchronous read, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object that represents the asynchronous read, which could still be pending.","pos":[0,78]}]},{"pos":[11128,11212],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[11327,11381],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[11470,11528],"content":"Attempted an asynchronous read past the end of the stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"Attempted an asynchronous read past the end of the stream.","pos":[0,58]}]},{"pos":[11623,11699],"content":"The buffer length minus <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">offset</ph><ept id=\"p1\">&lt;/code&gt;</ept> is less than <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">count</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The buffer length minus <code>offset</code> is less than <code>count</code>."},{"pos":[11802,11857],"content":"The current stream does not support the read operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The current stream does not support the read operation.","pos":[0,55]}]},{"pos":[12456,12590],"content":"Begins an asynchronous write operation. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous write operation. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)","pos":[0,134],"nodes":[{"content":"Begins an asynchronous write operation.","pos":[0,39]},{"content":"(Consider using &lt;xref:System.IO.BufferedStream.WriteAsync*&gt; instead; see the Remarks section.)","pos":[40,134],"source":" (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)"}]}]},{"pos":[12603,13397],"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.       <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from BeginWrite. <xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as &lt;xref:System.IO.Stream.BeginWrite%2A&gt; and &lt;xref:System.IO.Stream.EndWrite%2A&gt; to implement asynchronous file operations.","pos":[0,198],"source":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations."},{"content":"These methods are still available in the <ph id=\"ph1\">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> to support legacy code; however, the new async methods, such as &lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;, &lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;, and &lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;, help you implement asynchronous file operations more easily.","pos":[199,567],"source":" These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily."},{"content":"&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt; must be called exactly once on every &lt;xref:System.IAsyncResult&gt; from BeginWrite.","pos":[574,698],"source":"       <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from BeginWrite."},{"content":"&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt; will block until the I/O operation has completed.","pos":[699,792],"source":" <xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed."}]},{"pos":[13618,13676],"content":"The buffer containing data to write to the current stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer containing data to write to the current stream.","pos":[0,58]}]},{"pos":[13738,13831],"content":"The zero-based byte offset in <ph id=\"ph1\">`buffer`</ph> at which to begin copying bytes to the current stream.","needQuote":true,"needEscape":true,"source":"The zero-based byte offset in `buffer` at which to begin copying bytes to the current stream."},{"pos":[13892,13929],"content":"The maximum number of bytes to write.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of bytes to write.","pos":[0,37]}]},{"pos":[14001,14076],"content":"The method to be called when the asynchronous write operation is completed.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method to be called when the asynchronous write operation is completed.","pos":[0,75]}]},{"pos":[14138,14243],"content":"A user-provided object that distinguishes this particular asynchronous write request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous write request from other requests.","pos":[0,105]}]},{"pos":[14307,14385],"content":"An object that references the asynchronous write which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object that references the asynchronous write which could still be pending.","pos":[0,78]}]},{"pos":[14543,14628],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> length minus <ph id=\"ph2\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than <ph id=\"ph3\">&lt;code&gt;count&lt;/code&gt;</ph>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> length minus <code>offset</code> is less than <code>count</code>."},{"pos":[14731,14815],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[14930,14984],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[15087,15123],"content":"The stream does not support writing.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support writing.","pos":[0,36]}]},{"pos":[15434,15502],"content":"Gets a value indicating whether the current stream supports reading.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating whether the current stream supports reading.","pos":[0,68]}]},{"pos":[15515,15990],"content":"If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.       If the stream is closed, this property returns `false`.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"If a class derived from &lt;xref:System.IO.Stream&gt; does not support reading, calls to the &lt;xref:System.IO.BufferedStream.Read%2A&gt;, &lt;xref:System.IO.BufferedStream.ReadByte%2A&gt;, &lt;xref:System.IO.Stream.BeginRead%2A&gt;, &lt;xref:System.IO.Stream.EndRead%2A&gt;, and the <ph id=\"ph1\">`Peek`</ph> methods of &lt;xref:System.IO.StreamReader&gt;, &lt;xref:System.IO.StringReader&gt;, and &lt;xref:System.IO.TextReader&gt; throw a &lt;xref:System.NotSupportedException&gt;.","pos":[0,411],"source":"If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>."},{"content":"If the stream is closed, this property returns <ph id=\"ph1\">`false`</ph>.","pos":[418,473],"source":"       If the stream is closed, this property returns `false`."}]},{"pos":[16540,16757],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the stream supports reading; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> if the stream is closed or was opened with write-only access.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports reading; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or was opened with write-only access."},{"pos":[17131,17199],"content":"Gets a value indicating whether the current stream supports seeking.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating whether the current stream supports seeking.","pos":[0,68]}]},{"pos":[17212,17581],"content":"If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.       If the stream is closed, this property returns `false`.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"If a class derived from &lt;xref:System.IO.Stream&gt; does not support seeking, calls to &lt;xref:System.IO.BufferedStream.Length%2A&gt;, &lt;xref:System.IO.BufferedStream.SetLength%2A&gt;, &lt;xref:System.IO.BufferedStream.Position%2A&gt;, and &lt;xref:System.IO.BufferedStream.Seek%2A&gt; throw a &lt;xref:System.NotSupportedException&gt;.","pos":[0,305],"source":"If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>."},{"content":"If the stream is closed, this property returns <ph id=\"ph1\">`false`</ph>.","pos":[312,367],"source":"       If the stream is closed, this property returns `false`."}]},{"pos":[18131,18416],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the stream supports seeking; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports seeking; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console."},{"pos":[18795,18863],"content":"Gets a value indicating whether the current stream supports writing.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating whether the current stream supports writing.","pos":[0,68]}]},{"pos":[18876,19205],"content":"If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.       If the stream is closed, this property returns `false`.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"If a class derived from &lt;xref:System.IO.Stream&gt; does not support writing, a call to &lt;xref:System.IO.BufferedStream.SetLength%2A&gt;, &lt;xref:System.IO.BufferedStream.Write%2A&gt;, or &lt;xref:System.IO.BufferedStream.WriteByte%2A&gt; throws a &lt;xref:System.NotSupportedException&gt;.","pos":[0,265],"source":"If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>."},{"content":"If the stream is closed, this property returns <ph id=\"ph1\">`false`</ph>.","pos":[272,327],"source":"       If the stream is closed, this property returns `false`."}]},{"pos":[19756,19972],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the stream supports writing; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> if the stream is closed or was opened with read-only access.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports writing; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or was opened with read-only access."},{"pos":[20548,20560],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[21016,21172],"content":"Waits for the pending asynchronous read operation to complete. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)","needQuote":true,"needEscape":true,"nodes":[{"content":"Waits for the pending asynchronous read operation to complete. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)","pos":[0,156],"nodes":[{"content":"Waits for the pending asynchronous read operation to complete.","pos":[0,62]},{"content":"(Consider using &lt;xref:System.IO.BufferedStream.ReadAsync*&gt; instead; see the Remarks section.)","pos":[63,156],"source":" (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)"}]}]},{"pos":[21185,21856],"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.       EndRead must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as &lt;xref:System.IO.Stream.BeginRead%2A&gt; and &lt;xref:System.IO.Stream.EndRead%2A&gt; to implement asynchronous file operations.","pos":[0,196],"source":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations."},{"content":"These methods are still available in the <ph id=\"ph1\">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> to support legacy code; however, the new async methods, such as &lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;, &lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;, and &lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;, help you implement asynchronous file operations more easily.","pos":[197,565],"source":" These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily."},{"content":"EndRead must be called with this &lt;xref:System.IAsyncResult&gt; to find out how many bytes were read.","pos":[572,669],"source":"       EndRead must be called with this <xref:System.IAsyncResult> to find out how many bytes were read."}]},{"pos":[22026,22088],"content":"The reference to the pending asynchronous request to wait for.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reference to the pending asynchronous request to wait for.","pos":[0,62]}]},{"pos":[22145,22360],"content":"The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested. Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested. Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.","pos":[0,215],"nodes":[{"content":"The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.","pos":[0,97]},{"content":"Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.","pos":[98,215]}]}]},{"pos":[22523,22612],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>asyncResult</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[22707,22830],"content":"This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginRead*> on this class.","needQuote":true,"needEscape":true,"nodes":[{"content":"This &lt;xref:System.IAsyncResult&gt; object was not created by calling &lt;xref:System.IO.BufferedStream.BeginRead*&gt; on this class.","pos":[0,123],"source":"This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginRead*> on this class."}]},{"pos":[23228,23407],"content":"Ends an asynchronous write operation and blocks until the I/O operation is complete. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)","needQuote":true,"needEscape":true,"nodes":[{"content":"Ends an asynchronous write operation and blocks until the I/O operation is complete. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)","pos":[0,179],"nodes":[{"content":"Ends an asynchronous write operation and blocks until the I/O operation is complete.","pos":[0,84]},{"content":"(Consider using &lt;xref:System.IO.BufferedStream.WriteAsync*&gt; instead; see the Remarks section.)","pos":[85,179],"source":" (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)"}]}]},{"pos":[23420,24216],"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.       EndWrite must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>. Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"In the .NET Framework 4 and earlier versions, you have to use methods such as &lt;xref:System.IO.Stream.BeginWrite%2A&gt; and &lt;xref:System.IO.Stream.EndWrite%2A&gt; to implement asynchronous file operations.","pos":[0,198],"source":"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations."},{"content":"These methods are still available in the <ph id=\"ph1\">[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]</ph> to support legacy code; however, the new async methods, such as &lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;, &lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;, and &lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;, help you implement asynchronous file operations more easily.","pos":[199,567],"source":" These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily."},{"content":"EndWrite must be called exactly once for every call to &lt;xref:System.IO.BufferedStream.BeginRead%2A&gt;.","pos":[574,674],"source":"       EndWrite must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>."},{"content":"Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.","pos":[675,794]}]},{"pos":[24388,24421],"content":"The pending asynchronous request.","needQuote":true,"needEscape":true,"nodes":[{"content":"The pending asynchronous request.","pos":[0,33]}]},{"pos":[24585,24674],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>asyncResult</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[24769,24893],"content":"This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginWrite*> on this class.","needQuote":true,"needEscape":true,"nodes":[{"content":"This &lt;xref:System.IAsyncResult&gt; object was not created by calling &lt;xref:System.IO.BufferedStream.BeginWrite*&gt; on this class.","pos":[0,124],"source":"This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginWrite*> on this class."}]},{"pos":[25198,25301],"content":"Clears all buffers for this stream and causes any buffered data to be written to the underlying device.","needQuote":true,"needEscape":true,"nodes":[{"content":"Clears all buffers for this stream and causes any buffered data to be written to the underlying device.","pos":[0,103]}]},{"pos":[25314,25980],"content":"Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.       If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size. For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.       All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Flushing the stream will not flush its underlying encoder unless you explicitly call <ph id=\"ph1\">`Flush`</ph> or &lt;xref:System.IO.Stream.Close%2A&gt;.","pos":[0,129],"source":"Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>."},{"content":"If you use the &lt;xref:System.IO.BufferedStream.%23ctor%2A&gt; constructor, thus specifying the buffer size while creating the <ph id=\"ph1\">`BufferedStream`</ph> object, the content is flushed when it reaches the buffer size.","pos":[136,338],"source":"       If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size."},{"content":"For example, code such as <ph id=\"ph1\">`BufferedStream bs = new BufferedStream(bs, 5)`</ph> will flush the content when the buffer size reaches 5 bytes.","pos":[339,473],"source":" For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes."},{"content":"All the read and write methods of <ph id=\"ph1\">`BufferedStream`</ph> automatically maintain the buffer, so there is no need to invoke <ph id=\"ph2\">`Flush`</ph> when switching back and forth between reading and writing.","pos":[480,662],"source":"       All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing."}]},{"pos":[26648,26677],"content":"The stream has been disposed.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream has been disposed.","pos":[0,29]}]},{"pos":[26766,26808],"content":"The data source or repository is not open.","needQuote":true,"needEscape":true,"nodes":[{"content":"The data source or repository is not open.","pos":[0,42]}]},{"pos":[27261,27412],"content":"Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.","pos":[0,151]}]},{"pos":[27657,27704],"content":"The token to monitor for cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"The token to monitor for cancellation requests.","pos":[0,47]}]},{"pos":[27776,27832],"content":"A task that represents the asynchronous flush operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"A task that represents the asynchronous flush operation.","pos":[0,56]}]},{"pos":[28002,28031],"content":"The stream has been disposed.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream has been disposed.","pos":[0,29]}]},{"pos":[28337,28369],"content":"Gets the stream length in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the stream length in bytes.","pos":[0,32]}]},{"pos":[28486,28513],"content":"The stream length in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream length in bytes.","pos":[0,27]}]},{"pos":[28661,28757],"content":"The underlying stream is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> or closed.","needQuote":true,"needEscape":true,"source":"The underlying stream is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> or closed."},{"pos":[28860,28896],"content":"The stream does not support seeking.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support seeking.","pos":[0,36]}]},{"pos":[29003,29051],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[29367,29411],"content":"Gets the position within the current stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the position within the current stream.","pos":[0,44]}]},{"pos":[29424,29869],"content":"The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.       The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.       Seeking to any location beyond the length of the stream is supported.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The <ph id=\"ph1\">`get`</ph> accessor invokes &lt;xref:System.IO.BufferedStream.Seek%2A&gt; to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.","pos":[0,207],"source":"The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer."},{"content":"The <ph id=\"ph1\">`set`</ph> accessor copies any data previously written to the buffer to the underlying stream, and then invokes &lt;xref:System.IO.BufferedStream.Seek%2A&gt;.","pos":[214,365],"source":"       The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>."},{"content":"Seeking to any location beyond the length of the stream is supported.","pos":[372,441]}]},{"pos":[29994,30033],"content":"The position within the current stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The position within the current stream.","pos":[0,39]}]},{"pos":[30209,30279],"content":"The value passed to <xref:System.IO.BufferedStream.Seek*> is negative.","needQuote":true,"needEscape":true,"nodes":[{"content":"The value passed to &lt;xref:System.IO.BufferedStream.Seek*&gt; is negative.","pos":[0,70],"source":"The value passed to <xref:System.IO.BufferedStream.Seek*> is negative."}]},{"pos":[30368,30421],"content":"An I/O error occurs, such as the stream being closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurs, such as the stream being closed.","pos":[0,53]}]},{"pos":[30524,30560],"content":"The stream does not support seeking.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support seeking.","pos":[0,36]}]},{"pos":[30667,30715],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[31151,31209],"content":"Copies bytes from the current buffered stream to an array.","needQuote":true,"needEscape":true,"nodes":[{"content":"Copies bytes from the current buffered stream to an array.","pos":[0,58]}]},{"pos":[31222,31734],"content":"The `Read` method will return 0 only if the end of the stream is reached. In all other cases, `Read` always reads at least one byte from the stream before returning. By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically). An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.       Use <xref:System.IO.BinaryReader> for reading primitive data types.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The <ph id=\"ph1\">`Read`</ph> method will return 0 only if the end of the stream is reached.","pos":[0,73],"source":"The `Read` method will return 0 only if the end of the stream is reached."},{"content":"In all other cases, <ph id=\"ph1\">`Read`</ph> always reads at least one byte from the stream before returning.","pos":[74,165],"source":" In all other cases, `Read` always reads at least one byte from the stream before returning."},{"content":"By definition, if no data is available from the stream upon a call to <ph id=\"ph1\">`Read`</ph>, the <ph id=\"ph2\">`Read`</ph> method returns 0 (the end of the stream is reached automatically).","pos":[166,321],"source":" By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically)."},{"content":"An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.","pos":[322,436]},{"content":"Use &lt;xref:System.IO.BinaryReader&gt; for reading primitive data types.","pos":[443,510],"source":"       Use <xref:System.IO.BinaryReader> for reading primitive data types."}]},{"pos":[32329,32372],"content":"The buffer to which bytes are to be copied.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer to which bytes are to be copied.","pos":[0,43]}]},{"pos":[32434,32496],"content":"The byte offset in the buffer at which to begin reading bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The byte offset in the buffer at which to begin reading bytes.","pos":[0,62]}]},{"pos":[32557,32588],"content":"The number of bytes to be read.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of bytes to be read.","pos":[0,31]}]},{"pos":[32645,32876],"content":"The total number of bytes read into <code>array</code>. This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.","needQuote":true,"needEscape":true,"nodes":[{"content":"The total number of bytes read into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">array</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[0,55],"source":"The total number of bytes read into <code>array</code>."},{"content":"This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.","pos":[56,231]}]},{"pos":[33028,33115],"content":"Length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">array</ph><ept id=\"p1\">&lt;/code&gt;</ept> minus <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">offset</ph><ept id=\"p2\">&lt;/code&gt;</ept> is less than <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">count</ph><ept id=\"p3\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."},{"pos":[33218,33301],"content":"<ph id=\"ph1\">&lt;code&gt;array&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>array</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[33416,33470],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[33559,33649],"content":"The stream is not open or is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[33752,33788],"content":"The stream does not support reading.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support reading.","pos":[0,36]}]},{"pos":[33895,33943],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[34528,34698],"content":"Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.","pos":[0,170]}]},{"pos":[34710,34950],"content":"You can create a cancellation token by creating an instance of the &lt;xref:System.Threading.CancellationTokenSource&gt; class and passing the &lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt; property as the <ph id=\"ph1\">`cancellationToken`</ph> parameter.","needQuote":true,"needEscape":true,"extradata":"MT","source":"You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter."},{"pos":[35205,35239],"content":"The buffer to write the data into.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer to write the data into.","pos":[0,34]}]},{"pos":[35301,35376],"content":"The byte offset in <ph id=\"ph1\">`buffer`</ph> at which to begin writing data from the stream.","needQuote":true,"needEscape":true,"source":"The byte offset in `buffer` at which to begin writing data from the stream."},{"pos":[35437,35473],"content":"The maximum number of bytes to read.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of bytes to read.","pos":[0,36]}]},{"pos":[35568,35615],"content":"The token to monitor for cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"The token to monitor for cancellation requests.","pos":[0,47]}]},{"pos":[35701,36068],"content":"A task that represents the asynchronous read operation. The value of the <code>TResult</code> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.","needQuote":true,"needEscape":true,"nodes":[{"content":"A task that represents the asynchronous read operation.","pos":[0,55]},{"content":"The value of the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">TResult</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter contains the total number of bytes read into the buffer.","pos":[56,160],"source":" The value of the <code>TResult</code> parameter contains the total number of bytes read into the buffer."},{"content":"The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.","pos":[161,367]}]},{"pos":[36233,36317],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[36432,36486],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[36581,36668],"content":"The sum of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">offset</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">count</ph><ept id=\"p2\">&lt;/code&gt;</ept> is larger than the buffer length.","needQuote":true,"needEscape":true,"source":"The sum of <code>offset</code> and <code>count</code> is larger than the buffer length."},{"pos":[36771,36807],"content":"The stream does not support reading.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support reading.","pos":[0,36]}]},{"pos":[36914,36943],"content":"The stream has been disposed.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream has been disposed.","pos":[0,29]}]},{"pos":[37054,37114],"content":"The stream is currently in use by a previous read operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream is currently in use by a previous read operation.","pos":[0,60]}]},{"pos":[37434,37618],"content":"Reads a byte from the underlying stream and returns the byte cast to an <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, or returns -1 if reading from the end of the stream.","needQuote":true,"needEscape":true,"source":"Reads a byte from the underlying stream and returns the byte cast to an <xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"></xref>, or returns -1 if reading from the end of the stream."},{"pos":[37750,37874],"content":"The byte cast to an <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, or -1 if reading from the end of the stream.","needQuote":true,"needEscape":true,"source":"The byte cast to an <xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"></xref>, or -1 if reading from the end of the stream."},{"pos":[38024,38077],"content":"An I/O error occurs, such as the stream being closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurs, such as the stream being closed.","pos":[0,53]}]},{"pos":[38180,38216],"content":"The stream does not support reading.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support reading.","pos":[0,36]}]},{"pos":[38323,38371],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[38789,38842],"content":"Sets the position within the current buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the position within the current buffered stream.","pos":[0,53]}]},{"pos":[38855,39747],"content":"If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`. If `offset` is 0, the new position will be the position specified by `origin`. If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.       When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the Seek method can cause the position of the stream to no longer match the position of the internal buffer in the reader. To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName> method; however, this method slows performance and should be called only when absolutely necessary.       Seeking to any location beyond the length of the stream is supported.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"If <ph id=\"ph1\">`offset`</ph> is negative, the new position will precede the position specified by <ph id=\"ph2\">`origin`</ph> by the number of bytes specified by <ph id=\"ph3\">`offset`</ph>.","pos":[0,135],"source":"If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`."},{"content":"If <ph id=\"ph1\">`offset`</ph> is 0, the new position will be the position specified by <ph id=\"ph2\">`origin`</ph>.","pos":[136,214],"source":" If `offset` is 0, the new position will be the position specified by `origin`."},{"content":"If <ph id=\"ph1\">`offset`</ph> is positive, the new position will follow the position specified by <ph id=\"ph2\">`origin`</ph> by the number of bytes specified by <ph id=\"ph3\">`offset`</ph>.","pos":[215,349],"source":" If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`."},{"content":"When a &lt;xref:System.IO.BufferedStream&gt; object is the base stream for a &lt;xref:System.IO.StreamReader&gt; object, calling the Seek method can cause the position of the stream to no longer match the position of the internal buffer in the reader.","pos":[356,595],"source":"       When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the Seek method can cause the position of the stream to no longer match the position of the internal buffer in the reader."},{"content":"To reset the internal buffer, call the &lt;xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName&gt; method; however, this method slows performance and should be called only when absolutely necessary.","pos":[596,812],"source":" To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName> method; however, this method slows performance and should be called only when absolutely necessary."},{"content":"Seeking to any location beyond the length of the stream is supported.","pos":[819,888]}]},{"pos":[39919,39954],"content":"A byte offset relative to <ph id=\"ph1\">`origin`</ph>.","needQuote":true,"needEscape":true,"source":"A byte offset relative to `origin`."},{"pos":[40024,40137],"content":"A value of type <xref:System.IO.SeekOrigin> indicating the reference point from which to obtain the new position.","needQuote":true,"needEscape":true,"nodes":[{"content":"A value of type &lt;xref:System.IO.SeekOrigin&gt; indicating the reference point from which to obtain the new position.","pos":[0,113],"source":"A value of type <xref:System.IO.SeekOrigin> indicating the reference point from which to obtain the new position."}]},{"pos":[40194,40246],"content":"The new position within the current buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new position within the current buffered stream.","pos":[0,52]}]},{"pos":[40392,40482],"content":"The stream is not open or is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[40585,40621],"content":"The stream does not support seeking.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support seeking.","pos":[0,36]}]},{"pos":[40728,40776],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[41144,41183],"content":"Sets the length of the buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the length of the buffered stream.","pos":[0,39]}]},{"pos":[41196,41782],"content":"The buffer is flushed before setting the length of the underlying data source or repository. If the specified value is less than the current length of the buffered stream, the buffered stream is truncated. If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded. If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.       `SetLength` flushes any buffered writes if necessary.       A stream must support both writing and seeking for `SetLength` to work.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The buffer is flushed before setting the length of the underlying data source or repository.","pos":[0,92]},{"content":"If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.","pos":[93,205]},{"content":"If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.","pos":[206,319]},{"content":"If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.","pos":[320,444]},{"content":"<ph id=\"ph1\">`SetLength`</ph> flushes any buffered writes if necessary.","pos":[451,504],"source":"`SetLength` flushes any buffered writes if necessary."},{"content":"A stream must support both writing and seeking for <ph id=\"ph1\">`SetLength`</ph> to work.","pos":[511,582],"source":"       A stream must support both writing and seeking for `SetLength` to work."}]},{"pos":[41928,42009],"content":"An integer indicating the desired length of the current buffered stream in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"An integer indicating the desired length of the current buffered stream in bytes.","pos":[0,81]}]},{"pos":[42186,42217],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>value</code> is negative."},{"pos":[42306,42396],"content":"The stream is not open or is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[42499,42552],"content":"The stream does not support both writing and seeking.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support both writing and seeking.","pos":[0,53]}]},{"pos":[42659,42707],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[43148,43276],"content":"Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.","needQuote":true,"needEscape":true,"nodes":[{"content":"Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.","pos":[0,128]}]},{"pos":[43886,43965],"content":"The byte array from which to copy <ph id=\"ph1\">`count`</ph> bytes to the current buffered stream.","needQuote":true,"needEscape":true,"source":"The byte array from which to copy `count` bytes to the current buffered stream."},{"pos":[44027,44115],"content":"The offset in the buffer at which to begin copying bytes to the current buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The offset in the buffer at which to begin copying bytes to the current buffered stream.","pos":[0,88]}]},{"pos":[44176,44241],"content":"The number of bytes to be written to the current buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of bytes to be written to the current buffered stream.","pos":[0,65]}]},{"pos":[44394,44481],"content":"Length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">array</ph><ept id=\"p1\">&lt;/code&gt;</ept> minus <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">offset</ph><ept id=\"p2\">&lt;/code&gt;</ept> is less than <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">count</ph><ept id=\"p3\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."},{"pos":[44584,44667],"content":"<ph id=\"ph1\">&lt;code&gt;array&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>array</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[44782,44836],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[44925,45010],"content":"The stream is closed or <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The stream is closed or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[45113,45149],"content":"The stream does not support writing.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support writing.","pos":[0,36]}]},{"pos":[45256,45304],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]},{"pos":[45894,46075],"content":"Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.","pos":[0,181]}]},{"pos":[46087,46327],"content":"You can create a cancellation token by creating an instance of the &lt;xref:System.Threading.CancellationTokenSource&gt; class and passing the &lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt; property as the <ph id=\"ph1\">`cancellationToken`</ph> parameter.","needQuote":true,"needEscape":true,"extradata":"MT","source":"You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter."},{"pos":[46578,46608],"content":"The buffer to write data from.","needQuote":true,"needEscape":true,"nodes":[{"content":"The buffer to write data from.","pos":[0,30]}]},{"pos":[46670,46757],"content":"The zero-based byte offset in <ph id=\"ph1\">`buffer`</ph> from which to begin copying bytes to the stream.","needQuote":true,"needEscape":true,"source":"The zero-based byte offset in `buffer` from which to begin copying bytes to the stream."},{"pos":[46818,46855],"content":"The maximum number of bytes to write.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of bytes to write.","pos":[0,37]}]},{"pos":[46950,46997],"content":"The token to monitor for cancellation requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"The token to monitor for cancellation requests.","pos":[0,47]}]},{"pos":[47069,47125],"content":"A task that represents the asynchronous write operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"A task that represents the asynchronous write operation.","pos":[0,56]}]},{"pos":[47291,47375],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[47490,47544],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is negative.","needQuote":true,"needEscape":true,"source":"<code>offset</code> or <code>count</code> is negative."},{"pos":[47639,47726],"content":"The sum of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">offset</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">count</ph><ept id=\"p2\">&lt;/code&gt;</ept> is larger than the buffer length.","needQuote":true,"needEscape":true,"source":"The sum of <code>offset</code> and <code>count</code> is larger than the buffer length."},{"pos":[47829,47865],"content":"The stream does not support writing.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support writing.","pos":[0,36]}]},{"pos":[47972,48001],"content":"The stream has been disposed.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream has been disposed.","pos":[0,29]}]},{"pos":[48112,48173],"content":"The stream is currently in use by a previous write operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream is currently in use by a previous write operation.","pos":[0,61]}]},{"pos":[48536,48597],"content":"Writes a byte to the current position in the buffered stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a byte to the current position in the buffered stream.","pos":[0,61]}]},{"pos":[48741,48771],"content":"A byte to write to the stream.","needQuote":true,"needEscape":true,"nodes":[{"content":"A byte to write to the stream.","pos":[0,30]}]},{"pos":[48936,48972],"content":"The stream does not support writing.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream does not support writing.","pos":[0,36]}]},{"pos":[49075,49158],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>value</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[49265,49313],"content":"Methods were called after the stream was closed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Methods were called after the stream was closed.","pos":[0,48]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.IO.BufferedStream\n  id: BufferedStream\n  children:\n  - System.IO.BufferedStream.#ctor(System.IO.Stream)\n  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)\n  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  - System.IO.BufferedStream.CanRead\n  - System.IO.BufferedStream.CanSeek\n  - System.IO.BufferedStream.CanWrite\n  - System.IO.BufferedStream.Dispose(System.Boolean)\n  - System.IO.BufferedStream.EndRead(System.IAsyncResult)\n  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)\n  - System.IO.BufferedStream.Flush\n  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)\n  - System.IO.BufferedStream.Length\n  - System.IO.BufferedStream.Position\n  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)\n  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  - System.IO.BufferedStream.ReadByte\n  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)\n  - System.IO.BufferedStream.SetLength(System.Int64)\n  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)\n  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  - System.IO.BufferedStream.WriteByte(System.Byte)\n  langs:\n  - csharp\n  name: BufferedStream\n  nameWithType: BufferedStream\n  fullName: System.IO.BufferedStream\n  type: Class\n  summary: Adds a buffering layer to read and write operations on another stream. This class cannot be inherited.\n  remarks: \"A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\\\[\\\\],Int32,Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\\\[\\\\],Int32,Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the Using an Object that Implements IDisposable section in the <xref:System.IDisposable> interface topic.  \\n  \\n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.\"\n  example:\n  - \"The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \\n  \\n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \\n  \\n **Example 1: Code that runs on the client**  \\n  \\n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \\n  \\n **Example 2: Code that runs on the server**  \\n  \\n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class BufferedStream : System.IO.Stream\n  inheritance:\n  - System.IO.Stream\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)\n  id: '#ctor(System.IO.Stream)'\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: BufferedStream(Stream)\n  nameWithType: BufferedStream.BufferedStream(Stream)\n  fullName: System.IO.BufferedStream.BufferedStream(Stream)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Initializes a new instance of the <xref href=\"System.IO.BufferedStream\"></xref> class with a default buffer size of 4096 bytes.\n  remarks: A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor. The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.\n  syntax:\n    content: public BufferedStream (System.IO.Stream stream);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: The current stream.\n  overload: System.IO.BufferedStream.#ctor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)\n  id: '#ctor(System.IO.Stream,System.Int32)'\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: BufferedStream(Stream,Int32)\n  nameWithType: BufferedStream.BufferedStream(Stream,Int32)\n  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Initializes a new instance of the <xref href=\"System.IO.BufferedStream\"></xref> class with the specified buffer size.\n  remarks: A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor. The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]\"\n  syntax:\n    content: public BufferedStream (System.IO.Stream stream, int bufferSize);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: The current stream.\n    - id: bufferSize\n      type: System.Int32\n      description: The buffer size in bytes.\n  overload: System.IO.BufferedStream.#ctor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>bufferSize</code> is negative.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Begins an asynchronous read operation. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)\n  remarks: \"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  \\n  \\n <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to BeginRead. Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.  \\n  \\n> [!NOTE]\\n>  Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.  \\n  \\n <xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.\"\n  syntax:\n    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: The buffer to read the data into.\n    - id: offset\n      type: System.Int32\n      description: The byte offset in `buffer` at which to begin writing data read from the stream.\n    - id: count\n      type: System.Int32\n      description: The maximum number of bytes to read.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the read is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous read request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An object that represents the asynchronous read, which could still be pending.\n  overload: System.IO.BufferedStream.BeginRead*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: Attempted an asynchronous read past the end of the stream.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The buffer length minus <code>offset</code> is less than <code>count</code>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The current stream does not support the read operation.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Begins an asynchronous write operation. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)\n  remarks: \"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  \\n  \\n <xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from BeginWrite. <xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.\"\n  syntax:\n    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: The buffer containing data to write to the current stream.\n    - id: offset\n      type: System.Int32\n      description: The zero-based byte offset in `buffer` at which to begin copying bytes to the current stream.\n    - id: count\n      type: System.Int32\n      description: The maximum number of bytes to write.\n    - id: callback\n      type: System.AsyncCallback\n      description: The method to be called when the asynchronous write operation is completed.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous write request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An object that references the asynchronous write which could still be pending.\n  overload: System.IO.BufferedStream.BeginWrite*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffer</code> length minus <code>offset</code> is less than <code>count</code>.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support writing.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.CanRead\n  id: CanRead\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: CanRead\n  nameWithType: BufferedStream.CanRead\n  fullName: System.IO.BufferedStream.CanRead\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Gets a value indicating whether the current stream supports reading.\n  remarks: \"If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.  \\n  \\n If the stream is closed, this property returns `false`.\"\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]\"\n  syntax:\n    content: public override bool CanRead { get; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports reading; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or was opened with write-only access.\n  overload: System.IO.BufferedStream.CanRead*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.CanSeek\n  id: CanSeek\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: CanSeek\n  nameWithType: BufferedStream.CanSeek\n  fullName: System.IO.BufferedStream.CanSeek\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Gets a value indicating whether the current stream supports seeking.\n  remarks: \"If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.  \\n  \\n If the stream is closed, this property returns `false`.\"\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]\"\n  syntax:\n    content: public override bool CanSeek { get; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports seeking; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.\n  overload: System.IO.BufferedStream.CanSeek*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.CanWrite\n  id: CanWrite\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: CanWrite\n  nameWithType: BufferedStream.CanWrite\n  fullName: System.IO.BufferedStream.CanWrite\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Gets a value indicating whether the current stream supports writing.\n  remarks: \"If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.  \\n  \\n If the stream is closed, this property returns `false`.\"\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]\"\n  syntax:\n    content: public override bool CanWrite { get; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the stream supports writing; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if the stream is closed or was opened with read-only access.\n  overload: System.IO.BufferedStream.CanWrite*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: BufferedStream.Dispose(Boolean)\n  fullName: System.IO.BufferedStream.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  syntax:\n    content: protected override void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: To be added.\n  overload: System.IO.BufferedStream.Dispose*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)\n  id: EndRead(System.IAsyncResult)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: EndRead(IAsyncResult)\n  nameWithType: BufferedStream.EndRead(IAsyncResult)\n  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Waits for the pending asynchronous read operation to complete. (Consider using <xref:System.IO.BufferedStream.ReadAsync*> instead; see the Remarks section.)\n  remarks: \"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  \\n  \\n EndRead must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.\"\n  syntax:\n    content: public override int EndRead (IAsyncResult asyncResult);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: The reference to the pending asynchronous request to wait for.\n    return:\n      type: System.Int32\n      description: The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested. Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.\n  overload: System.IO.BufferedStream.EndRead*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginRead*> on this class.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)\n  id: EndWrite(System.IAsyncResult)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: EndWrite(IAsyncResult)\n  nameWithType: BufferedStream.EndWrite(IAsyncResult)\n  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Ends an asynchronous write operation and blocks until the I/O operation is complete. (Consider using <xref:System.IO.BufferedStream.WriteAsync*> instead; see the Remarks section.)\n  remarks: \"In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  \\n  \\n EndWrite must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>. Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.\"\n  syntax:\n    content: public override void EndWrite (IAsyncResult asyncResult);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: The pending asynchronous request.\n  overload: System.IO.BufferedStream.EndWrite*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: This <xref:System.IAsyncResult> object was not created by calling <xref:System.IO.BufferedStream.BeginWrite*> on this class.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Flush\n  id: Flush\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Flush()\n  nameWithType: BufferedStream.Flush()\n  fullName: System.IO.BufferedStream.Flush()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Clears all buffers for this stream and causes any buffered data to be written to the underlying device.\n  remarks: \"Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.  \\n  \\n If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size. For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.  \\n  \\n All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.\"\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]\"\n  syntax:\n    content: public override void Flush ();\n    parameters: []\n  overload: System.IO.BufferedStream.Flush*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The stream has been disposed.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The data source or repository is not open.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)\n  id: FlushAsync(System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: FlushAsync(CancellationToken)\n  nameWithType: BufferedStream.FlushAsync(CancellationToken)\n  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.\n  syntax:\n    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The token to monitor for cancellation requests.\n    return:\n      type: System.Threading.Tasks.Task\n      description: A task that represents the asynchronous flush operation.\n  overload: System.IO.BufferedStream.FlushAsync*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The stream has been disposed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Length\n  id: Length\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Length\n  nameWithType: BufferedStream.Length\n  fullName: System.IO.BufferedStream.Length\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Gets the stream length in bytes.\n  syntax:\n    content: public override long Length { get; }\n    return:\n      type: System.Int64\n      description: The stream length in bytes.\n  overload: System.IO.BufferedStream.Length*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The underlying stream is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> or closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support seeking.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Position\n  id: Position\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Position\n  nameWithType: BufferedStream.Position\n  fullName: System.IO.BufferedStream.Position\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Gets the position within the current stream.\n  remarks: \"The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.  \\n  \\n The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.  \\n  \\n Seeking to any location beyond the length of the stream is supported.\"\n  syntax:\n    content: public override long Position { get; set; }\n    return:\n      type: System.Int64\n      description: The position within the current stream.\n  overload: System.IO.BufferedStream.Position*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value passed to <xref:System.IO.BufferedStream.Seek*> is negative.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurs, such as the stream being closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support seeking.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)\n  id: Read(System.Byte[],System.Int32,System.Int32)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Read(Byte[],Int32,Int32)\n  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)\n  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Copies bytes from the current buffered stream to an array.\n  remarks: \"The `Read` method will return 0 only if the end of the stream is reached. In all other cases, `Read` always reads at least one byte from the stream before returning. By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically). An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.  \\n  \\n Use <xref:System.IO.BinaryReader> for reading primitive data types.\"\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]\"\n  syntax:\n    content: public override int Read (byte[] array, int offset, int count);\n    parameters:\n    - id: array\n      type: System.Byte[]\n      description: The buffer to which bytes are to be copied.\n    - id: offset\n      type: System.Int32\n      description: The byte offset in the buffer at which to begin reading bytes.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to be read.\n    return:\n      type: System.Int32\n      description: The total number of bytes read into <code>array</code>. This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.\n  overload: System.IO.BufferedStream.Read*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>array</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support reading.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)\n  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)\n  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.\n  remarks: You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.\n  syntax:\n    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: The buffer to write the data into.\n    - id: offset\n      type: System.Int32\n      description: The byte offset in `buffer` at which to begin writing data from the stream.\n    - id: count\n      type: System.Int32\n      description: The maximum number of bytes to read.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The token to monitor for cancellation requests.\n    return:\n      type: System.Threading.Tasks.Task{System.Int32}\n      description: A task that represents the asynchronous read operation. The value of the <code>TResult</code> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.\n  overload: System.IO.BufferedStream.ReadAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The sum of <code>offset</code> and <code>count</code> is larger than the buffer length.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support reading.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The stream has been disposed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The stream is currently in use by a previous read operation.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.ReadByte\n  id: ReadByte\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: ReadByte()\n  nameWithType: BufferedStream.ReadByte()\n  fullName: System.IO.BufferedStream.ReadByte()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Reads a byte from the underlying stream and returns the byte cast to an <xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"></xref>, or returns -1 if reading from the end of the stream.\n  syntax:\n    content: public override int ReadByte ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The byte cast to an <xref uid=\"langword_csharp_int\" name=\"int\" href=\"\"></xref>, or -1 if reading from the end of the stream.\n  overload: System.IO.BufferedStream.ReadByte*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurs, such as the stream being closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support reading.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)\n  id: Seek(System.Int64,System.IO.SeekOrigin)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Seek(Int64,SeekOrigin)\n  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)\n  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Sets the position within the current buffered stream.\n  remarks: \"If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`. If `offset` is 0, the new position will be the position specified by `origin`. If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.  \\n  \\n When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the Seek method can cause the position of the stream to no longer match the position of the internal buffer in the reader. To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName> method; however, this method slows performance and should be called only when absolutely necessary.  \\n  \\n Seeking to any location beyond the length of the stream is supported.\"\n  syntax:\n    content: public override long Seek (long offset, System.IO.SeekOrigin origin);\n    parameters:\n    - id: offset\n      type: System.Int64\n      description: A byte offset relative to `origin`.\n    - id: origin\n      type: System.IO.SeekOrigin\n      description: A value of type <xref:System.IO.SeekOrigin> indicating the reference point from which to obtain the new position.\n    return:\n      type: System.Int64\n      description: The new position within the current buffered stream.\n  overload: System.IO.BufferedStream.Seek*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support seeking.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.SetLength(System.Int64)\n  id: SetLength(System.Int64)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: SetLength(Int64)\n  nameWithType: BufferedStream.SetLength(Int64)\n  fullName: System.IO.BufferedStream.SetLength(Int64)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Sets the length of the buffered stream.\n  remarks: \"The buffer is flushed before setting the length of the underlying data source or repository. If the specified value is less than the current length of the buffered stream, the buffered stream is truncated. If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded. If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.  \\n  \\n `SetLength` flushes any buffered writes if necessary.  \\n  \\n A stream must support both writing and seeking for `SetLength` to work.\"\n  syntax:\n    content: public override void SetLength (long value);\n    parameters:\n    - id: value\n      type: System.Int64\n      description: An integer indicating the desired length of the current buffered stream in bytes.\n  overload: System.IO.BufferedStream.SetLength*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>value</code> is negative.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The stream is not open or is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support both writing and seeking.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)\n  id: Write(System.Byte[],System.Int32,System.Int32)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: Write(Byte[],Int32,Int32)\n  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)\n  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.\n  remarks: ''\n  example:\n  - \"This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \\n  \\n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]\"\n  syntax:\n    content: public override void Write (byte[] array, int offset, int count);\n    parameters:\n    - id: array\n      type: System.Byte[]\n      description: The byte array from which to copy `count` bytes to the current buffered stream.\n    - id: offset\n      type: System.Int32\n      description: The offset in the buffer at which to begin copying bytes to the current buffered stream.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to be written to the current buffered stream.\n  overload: System.IO.BufferedStream.Write*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>array</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The stream is closed or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support writing.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)\n  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)\n  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.\n  remarks: You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.\n  syntax:\n    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: The buffer to write data from.\n    - id: offset\n      type: System.Int32\n      description: The zero-based byte offset in `buffer` from which to begin copying bytes to the stream.\n    - id: count\n      type: System.Int32\n      description: The maximum number of bytes to write.\n    - id: cancellationToken\n      type: System.Threading.CancellationToken\n      description: The token to monitor for cancellation requests.\n    return:\n      type: System.Threading.Tasks.Task\n      description: A task that represents the asynchronous write operation.\n  overload: System.IO.BufferedStream.WriteAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>offset</code> or <code>count</code> is negative.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The sum of <code>offset</code> and <code>count</code> is larger than the buffer length.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support writing.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The stream has been disposed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The stream is currently in use by a previous write operation.\n  platform:\n  - net462\n- uid: System.IO.BufferedStream.WriteByte(System.Byte)\n  id: WriteByte(System.Byte)\n  parent: System.IO.BufferedStream\n  langs:\n  - csharp\n  name: WriteByte(Byte)\n  nameWithType: BufferedStream.WriteByte(Byte)\n  fullName: System.IO.BufferedStream.WriteByte(Byte)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.IO\n  summary: Writes a byte to the current position in the buffered stream.\n  syntax:\n    content: public override void WriteByte (byte value);\n    parameters:\n    - id: value\n      type: System.Byte\n      description: A byte to write to the stream.\n  overload: System.IO.BufferedStream.WriteByte*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The stream does not support writing.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>value</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: Methods were called after the stream was closed.\n  platform:\n  - net462\nreferences:\n- uid: System.IO.Stream\n  isExternal: false\n  name: System.IO.Stream\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.IO.IOException\n  isExternal: true\n  name: System.IO.IOException\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.NotSupportedException\n  isExternal: true\n  name: System.NotSupportedException\n- uid: System.ObjectDisposedException\n  isExternal: true\n  name: System.ObjectDisposedException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BufferedStream(Stream)\n  nameWithType: BufferedStream.BufferedStream(Stream)\n  fullName: System.IO.BufferedStream.BufferedStream(Stream)\n- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BufferedStream(Stream,Int32)\n  nameWithType: BufferedStream.BufferedStream(Stream,Int32)\n  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: true\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.Byte[]\n  parent: System\n  isExternal: true\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: true\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.Object\n  parent: System\n  isExternal: true\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)\n- uid: System.IO.BufferedStream.CanRead\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanRead\n  nameWithType: BufferedStream.CanRead\n  fullName: System.IO.BufferedStream.CanRead\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.IO.BufferedStream.CanSeek\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanSeek\n  nameWithType: BufferedStream.CanSeek\n  fullName: System.IO.BufferedStream.CanSeek\n- uid: System.IO.BufferedStream.CanWrite\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanWrite\n  nameWithType: BufferedStream.CanWrite\n  fullName: System.IO.BufferedStream.CanWrite\n- uid: System.IO.BufferedStream.Dispose(System.Boolean)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: BufferedStream.Dispose(Boolean)\n  fullName: System.IO.BufferedStream.Dispose(Boolean)\n- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: EndRead(IAsyncResult)\n  nameWithType: BufferedStream.EndRead(IAsyncResult)\n  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)\n- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: EndWrite(IAsyncResult)\n  nameWithType: BufferedStream.EndWrite(IAsyncResult)\n  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)\n- uid: System.IO.BufferedStream.Flush\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Flush()\n  nameWithType: BufferedStream.Flush()\n  fullName: System.IO.BufferedStream.Flush()\n- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: FlushAsync(CancellationToken)\n  nameWithType: BufferedStream.FlushAsync(CancellationToken)\n  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)\n- uid: System.Threading.Tasks.Task\n  parent: System.Threading.Tasks\n  isExternal: true\n  name: Task\n  nameWithType: Task\n  fullName: System.Threading.Tasks.Task\n- uid: System.Threading.CancellationToken\n  parent: System.Threading\n  isExternal: true\n  name: CancellationToken\n  nameWithType: CancellationToken\n  fullName: System.Threading.CancellationToken\n- uid: System.IO.BufferedStream.Length\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Length\n  nameWithType: BufferedStream.Length\n  fullName: System.IO.BufferedStream.Length\n- uid: System.Int64\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.IO.BufferedStream.Position\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Position\n  nameWithType: BufferedStream.Position\n  fullName: System.IO.BufferedStream.Position\n- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Read(Byte[],Int32,Int32)\n  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)\n  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)\n- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)\n  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)\n  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)\n- uid: System.Threading.Tasks.Task{System.Int32}\n  parent: System.Threading.Tasks\n  isExternal: true\n  name: Task<Int32>\n  nameWithType: Task<Int32>\n  fullName: System.Threading.Tasks.Task<System.Int32>\n  spec.csharp:\n  - uid: System.Threading.Tasks.Task`1\n    name: Task\n    nameWithType: Task\n    fullName: Task<System.Int32>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Int32\n    name: Int32\n    nameWithType: Int32\n    fullName: Int32\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.BufferedStream.ReadByte\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: ReadByte()\n  nameWithType: BufferedStream.ReadByte()\n  fullName: System.IO.BufferedStream.ReadByte()\n- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Seek(Int64,SeekOrigin)\n  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)\n  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)\n- uid: System.IO.SeekOrigin\n  parent: System.IO\n  isExternal: true\n  name: SeekOrigin\n  nameWithType: SeekOrigin\n  fullName: System.IO.SeekOrigin\n- uid: System.IO.BufferedStream.SetLength(System.Int64)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: SetLength(Int64)\n  nameWithType: BufferedStream.SetLength(Int64)\n  fullName: System.IO.BufferedStream.SetLength(Int64)\n- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Write(Byte[],Int32,Int32)\n  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)\n  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)\n- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)\n  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)\n  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)\n- uid: System.IO.BufferedStream.WriteByte(System.Byte)\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: WriteByte(Byte)\n  nameWithType: BufferedStream.WriteByte(Byte)\n  fullName: System.IO.BufferedStream.WriteByte(Byte)\n- uid: System.Byte\n  parent: System\n  isExternal: true\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: System.IO.BufferedStream.#ctor*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BufferedStream\n  nameWithType: BufferedStream.BufferedStream\n- uid: System.IO.BufferedStream.BeginRead*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BeginRead\n  nameWithType: BufferedStream.BeginRead\n- uid: System.IO.BufferedStream.BeginWrite*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: BeginWrite\n  nameWithType: BufferedStream.BeginWrite\n- uid: System.IO.BufferedStream.CanRead*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanRead\n  nameWithType: BufferedStream.CanRead\n- uid: System.IO.BufferedStream.CanSeek*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanSeek\n  nameWithType: BufferedStream.CanSeek\n- uid: System.IO.BufferedStream.CanWrite*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: CanWrite\n  nameWithType: BufferedStream.CanWrite\n- uid: System.IO.BufferedStream.Dispose*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Dispose\n  nameWithType: BufferedStream.Dispose\n- uid: System.IO.BufferedStream.EndRead*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: EndRead\n  nameWithType: BufferedStream.EndRead\n- uid: System.IO.BufferedStream.EndWrite*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: EndWrite\n  nameWithType: BufferedStream.EndWrite\n- uid: System.IO.BufferedStream.Flush*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Flush\n  nameWithType: BufferedStream.Flush\n- uid: System.IO.BufferedStream.FlushAsync*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: FlushAsync\n  nameWithType: BufferedStream.FlushAsync\n- uid: System.IO.BufferedStream.Length*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Length\n  nameWithType: BufferedStream.Length\n- uid: System.IO.BufferedStream.Position*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Position\n  nameWithType: BufferedStream.Position\n- uid: System.IO.BufferedStream.Read*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Read\n  nameWithType: BufferedStream.Read\n- uid: System.IO.BufferedStream.ReadAsync*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: ReadAsync\n  nameWithType: BufferedStream.ReadAsync\n- uid: System.IO.BufferedStream.ReadByte*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: ReadByte\n  nameWithType: BufferedStream.ReadByte\n- uid: System.IO.BufferedStream.Seek*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Seek\n  nameWithType: BufferedStream.Seek\n- uid: System.IO.BufferedStream.SetLength*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: SetLength\n  nameWithType: BufferedStream.SetLength\n- uid: System.IO.BufferedStream.Write*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: Write\n  nameWithType: BufferedStream.Write\n- uid: System.IO.BufferedStream.WriteAsync*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: WriteAsync\n  nameWithType: BufferedStream.WriteAsync\n- uid: System.IO.BufferedStream.WriteByte*\n  parent: System.IO.BufferedStream\n  isExternal: false\n  name: WriteByte\n  nameWithType: BufferedStream.WriteByte\n"}