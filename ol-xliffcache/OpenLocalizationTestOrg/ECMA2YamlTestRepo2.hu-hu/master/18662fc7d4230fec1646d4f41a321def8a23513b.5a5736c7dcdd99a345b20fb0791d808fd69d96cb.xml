{"nodes":[{"pos":[478,554],"content":"Ensures that all finalization code in derived classes is marked as critical.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ensures that all finalization code in derived classes is marked as critical.","pos":[0,76]}]},{"pos":[567,2434],"content":"Classes deriving from the CriticalFinalizerObject class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.       In classes derived from the CriticalFinalizerObject class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from CriticalFinalizerObject, can run a standard finalizer to flush out existing buffered data.       In most cases, you do not need to write classes that derive from the CriticalFinalizerObject class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Classes deriving from the CriticalFinalizerObject class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.       In classes derived from the CriticalFinalizerObject class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from CriticalFinalizerObject, can run a standard finalizer to flush out existing buffered data.       In most cases, you do not need to write classes that derive from the CriticalFinalizerObject class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.","pos":[0,1863],"nodes":[{"content":"Classes deriving from the CriticalFinalizerObject class are implicitly treated as a constrained execution region (CER).","pos":[0,119]},{"content":"This requires code in the finalizer to only call code with a strong reliability contract.","pos":[121,210]},{"content":"For more information about CERs, see the &lt;xref:System.Runtime.ConstrainedExecution&gt; namespace.","pos":[211,305],"source":" For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace."},{"content":"In classes derived from the CriticalFinalizerObject class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread.","pos":[312,637]},{"content":"If a finalizer violates the rules for a CER, it might not successfully execute.","pos":[638,717]},{"content":"In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers.","pos":[718,947]},{"content":"For example, a class such as &lt;xref:System.IO.FileStream&gt;, which holds data in the &lt;xref:System.Runtime.InteropServices.SafeHandle&gt; class that is derived from CriticalFinalizerObject, can run a standard finalizer to flush out existing buffered data.","pos":[948,1196],"source":" For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from CriticalFinalizerObject, can run a standard finalizer to flush out existing buffered data."},{"content":"In most cases, you do not need to write classes that derive from the CriticalFinalizerObject class.","pos":[1203,1302]},{"content":"The .NET Framework class library provides two classes, &lt;xref:System.Runtime.InteropServices.SafeHandle&gt; and &lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;, that provide critical finalization functionality for handle resources.","pos":[1303,1535],"source":" The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources."},{"content":"Furthermore, the .NET Framework provides a set of prewritten classes derived from the &lt;xref:System.Runtime.InteropServices.SafeHandle&gt; class, and this set is located in the &lt;xref:Microsoft.Win32.SafeHandles&gt; namespace.","pos":[1536,1754],"source":" Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace."},{"content":"These classes are designed to provide common functionality for supporting file and operating system handles.","pos":[1755,1863]}]}]},{"pos":[3762,3883],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class."},{"pos":[4519,4645],"content":"Releases all the resources used by the <bpt id=\"p1\">&lt;xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Releases all the resources used by the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class."},{"pos":[4657,4919],"content":"The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The finalizer for any types deriving from &lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt; is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).","pos":[0,262],"source":"The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER)."}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  id: CriticalFinalizerObject\n  children:\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  langs:\n  - csharp\n  name: CriticalFinalizerObject\n  nameWithType: CriticalFinalizerObject\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  type: Class\n  summary: Ensures that all finalization code in derived classes is marked as critical.\n  remarks: \"Classes deriving from the CriticalFinalizerObject class are implicitly treated as a constrained execution region (CER).  This requires code in the finalizer to only call code with a strong reliability contract. For more information about CERs, see the <xref:System.Runtime.ConstrainedExecution> namespace.  \\n  \\n In classes derived from the CriticalFinalizerObject class, the common language runtime (CLR) guarantees that all critical finalization code will be given the opportunity to execute, provided the finalizer follows the rules for a CER, even in situations where the CLR forcibly unloads an application domain or aborts a thread. If a finalizer violates the rules for a CER, it might not successfully execute. In addition, the CLR establishes a weak ordering among normal and critical finalizers: for objects reclaimed by garbage collection at the same time, all the noncritical finalizers are called before any of the critical finalizers. For example, a class such as <xref:System.IO.FileStream>, which holds data in the <xref:System.Runtime.InteropServices.SafeHandle> class that is derived from CriticalFinalizerObject, can run a standard finalizer to flush out existing buffered data.  \\n  \\n In most cases, you do not need to write classes that derive from the CriticalFinalizerObject class. The .NET Framework class library provides two classes, <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle>, that provide critical finalization functionality for handle resources. Furthermore, the .NET Framework provides a set of prewritten classes derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, and this set is located in the <xref:Microsoft.Win32.SafeHandles> namespace. These classes are designed to provide common functionality for supporting file and operating system handles.\"\n  example:\n  - \"The following code example shows the use of the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class to provide critical finalization for the standard input and output streams. The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, derived from the <xref:System.Runtime.InteropServices.SafeHandle> class, is passed to the file stream in the <xref:System.IO.FileStream> constructor.  \\n  \\n [!code-cs[SafeHandle.SafeFileHandle#1](~/add/codesnippet/csharp/t-system.runtime.constra_0_1.cs)]\\n [!code-vb[SafeHandle.SafeFileHandle#1](~/add/codesnippet/visualbasic/t-system.runtime.constra_0_1.vb)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class CriticalFinalizerObject\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  id: '#ctor'\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  langs:\n  - csharp\n  name: CriticalFinalizerObject()\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject()\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.CriticalFinalizerObject()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.\n  syntax:\n    content: protected CriticalFinalizerObject ();\n    parameters: []\n  overload: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  id: Finalize\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: CriticalFinalizerObject.Finalize()\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Releases all the resources used by the <xref href=\"System.Runtime.ConstrainedExecution.CriticalFinalizerObject\"></xref> class.\n  remarks: The finalizer for any types deriving from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> is given the opportunity to execute and will not be aborted, assuming the finalizer correctly follows the rules for a constrained execution region (CER).\n  syntax:\n    content: ~CriticalFinalizerObject ();\n    parameters: []\n  overload: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: CriticalFinalizerObject()\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject()\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.CriticalFinalizerObject()\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: Finalize()\n  nameWithType: CriticalFinalizerObject.Finalize()\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize()\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor*\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: CriticalFinalizerObject\n  nameWithType: CriticalFinalizerObject.CriticalFinalizerObject\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize*\n  parent: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: Finalize\n  nameWithType: CriticalFinalizerObject.Finalize\n"}