{"nodes":[{"pos":[395,496],"content":"Checks for sufficient memory resources before executing an operation. This class cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Checks for sufficient memory resources before executing an operation. This class cannot be inherited.","pos":[0,101],"nodes":[{"content":"Checks for sufficient memory resources before executing an operation.","pos":[0,69]},{"content":"This class cannot be inherited.","pos":[70,101]}]}]},{"pos":[509,3250],"content":"> [!NOTE] >  This class is intended for use in advanced development.       Creating an instance of the MemoryFailPoint class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.      > [!IMPORTANT] >  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.       By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.       MemoryFailPoint checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  MemoryFailPoint makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with MemoryFailPoint are released.       To use a memory gate, you must create a MemoryFailPoint object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.       The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.       MemoryFailPoint operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"<ph id=\"ph1\">&gt; [!NOTE]</ph> &gt;  This class is intended for use in advanced development.","pos":[0,68],"source":"> [!NOTE] >  This class is intended for use in advanced development."},{"content":"Creating an instance of the MemoryFailPoint class creates a memory gate.","pos":[75,147]},{"content":"A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory.","pos":[148,263]},{"content":"Failing the check results in an &lt;xref:System.InsufficientMemoryException&gt; exception being thrown.","pos":[264,361],"source":" Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown."},{"content":"This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources.","pos":[362,482]},{"content":"This enables you decrease performance to avoid an &lt;xref:System.OutOfMemoryException&gt; exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.","pos":[483,695],"source":" This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  This type implements the &lt;xref:System.IDisposable&gt; interface.","pos":[701,780],"source":"      > [!IMPORTANT] >  This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type, you should dispose of it either directly or indirectly.","pos":[781,875]},{"content":"To dispose of the type directly, call its &lt;xref:System.IDisposable.Dispose%2A&gt; method in a <ph id=\"ph1\">`try`</ph><ph id=\"ph2\">/</ph><ph id=\"ph3\">`catch`</ph> block.","pos":[876,987],"source":" To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[988,1095],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the “Using an Object that Implements IDisposable” section in the &lt;xref:System.IDisposable&gt; interface topic.","pos":[1096,1229],"source":" For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic."},{"content":"By throwing an &lt;xref:System.InsufficientMemoryException&gt; exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state.","pos":[1236,1485],"source":"       By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state."},{"content":"This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current &lt;xref:System.AppDomain&gt; or recycling the process.","pos":[1486,1662],"source":" This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process."},{"content":"MemoryFailPoint checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.","pos":[1669,1853]},{"content":"MemoryFailPoint makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the &lt;xref:System.Runtime.MemoryFailPoint.Dispose%2A&gt; method to ensure that resources associated with MemoryFailPoint are released.","pos":[1855,2135],"source":"  MemoryFailPoint makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with MemoryFailPoint are released."},{"content":"To use a memory gate, you must create a MemoryFailPoint object and specify the number of megabytes (MB) of memory that the next operation is expected to use.","pos":[2142,2299]},{"content":"If enough memory is not available, an &lt;xref:System.InsufficientMemoryException&gt; exception is thrown.","pos":[2300,2400],"source":" If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown."},{"content":"The parameter of the constructor must be a positive integer.","pos":[2407,2467]},{"content":"A negative value raises an &lt;xref:System.ArgumentOutOfRangeException&gt; exception.","pos":[2468,2547],"source":" A negative value raises an <xref:System.ArgumentOutOfRangeException> exception."},{"content":"MemoryFailPoint operates at a granularity of 16 MB.","pos":[2554,2605]},{"content":"Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","pos":[2606,2725]}]},{"pos":[4499,4658],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class, specifying the amount of memory required for successful execution.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> class, specifying the amount of memory required for successful execution."},{"pos":[4670,5190],"content":"The amount of memory used by your application to process a work item can be determined empirically.  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item. See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The amount of memory used by your application to process a work item can be determined empirically.","pos":[0,99]},{"content":"To estimate the amount of memory your application needs to process a request, consider using the &lt;xref:System.GC.GetTotalMemory%2A?displayProperty=fullName&gt; method to determine the amount of memory available before and after calling the method that processes the work item.","pos":[101,374],"source":"  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item."},{"content":"See the &lt;xref:System.Runtime.MemoryFailPoint&gt; class for a code example that dynamically determines the value for the <ph id=\"ph1\">`sizeInMegabytes`</ph> parameter.","pos":[375,520],"source":" See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter."}]},{"pos":[5672,5742],"content":"The required memory size, in megabytes. This must be a positive value.","needQuote":true,"needEscape":true,"nodes":[{"content":"The required memory size, in megabytes. This must be a positive value.","pos":[0,70],"nodes":[{"content":"The required memory size, in megabytes.","pos":[0,39]},{"content":"This must be a positive value.","pos":[40,70]}]}]},{"pos":[5921,5959],"content":"The specified memory size is negative.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified memory size is negative.","pos":[0,38]}]},{"pos":[6074,6156],"content":"There is insufficient memory to begin execution of the code protected by the gate.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is insufficient memory to begin execution of the code protected by the gate.","pos":[0,82]}]},{"pos":[6495,6582],"content":"Releases all resources used by the <bpt id=\"p1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Releases all resources used by the <xref href=\"System.Runtime.MemoryFailPoint\"></xref>."},{"pos":[6595,7468],"content":"Call Dispose when you are finished using the <xref:System.Runtime.MemoryFailPoint>. The Dispose method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state. After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/add/includes/ajax-current-ext-md.md) and [Implementing a Dispose Method](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] >  Always call Dispose before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Call Dispose when you are finished using the &lt;xref:System.Runtime.MemoryFailPoint&gt;.","pos":[0,83],"source":"Call Dispose when you are finished using the <xref:System.Runtime.MemoryFailPoint>."},{"content":"The Dispose method leaves the &lt;xref:System.Runtime.MemoryFailPoint&gt; in an unusable state.","pos":[84,173],"source":" The Dispose method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state."},{"content":"After calling &lt;xref:System.Runtime.MemoryFailPoint&gt;, you must release all references to the &lt;xref:System.Runtime.MemoryFailPoint&gt; so the garbage collector can reclaim the memory that the &lt;xref:System.Runtime.MemoryFailPoint&gt; was occupying.","pos":[174,413],"source":" After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/add/includes/ajax-current-ext-md.md)</ept>.","pos":[414,588],"source":" For more information, see [Cleaning Up Unmanaged Resources](~/add/includes/ajax-current-ext-md.md) and [Implementing a Dispose Method](~/add/includes/ajax-current-ext-md.md)."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Always call Dispose before you release your last reference to the &lt;xref:System.Runtime.MemoryFailPoint&gt;.","pos":[594,711],"source":"      > [!NOTE] >  Always call Dispose before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the &lt;xref:System.Runtime.MemoryFailPoint&gt; object's <ph id=\"ph1\">`Finalize`</ph> method.","pos":[712,870],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method."}]},{"pos":[7948,8123],"content":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id=\"p1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object.","needQuote":true,"needEscape":true,"source":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> object."},{"pos":[8135,8232],"content":"The garbage collector calls the Finalize method when the current object is ready to be finalized.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The garbage collector calls the Finalize method when the current object is ready to be finalized.","pos":[0,97]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.MemoryFailPoint\n  id: MemoryFailPoint\n  children:\n  - System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  - System.Runtime.MemoryFailPoint.Dispose\n  - System.Runtime.MemoryFailPoint.Finalize\n  langs:\n  - csharp\n  name: MemoryFailPoint\n  nameWithType: MemoryFailPoint\n  fullName: System.Runtime.MemoryFailPoint\n  type: Class\n  summary: Checks for sufficient memory resources before executing an operation. This class cannot be inherited.\n  remarks: \"> [!NOTE]\\n>  This class is intended for use in advanced development.  \\n  \\n Creating an instance of the MemoryFailPoint class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \\n  \\n By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.  \\n  \\n MemoryFailPoint checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  MemoryFailPoint makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with MemoryFailPoint are released.  \\n  \\n To use a memory gate, you must create a MemoryFailPoint object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.  \\n  \\n The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.  \\n  \\n MemoryFailPoint operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.\"\n  example:\n  - \"MemoryFailPoint enables an application to slow itself to avoid running out of memory in a corrupting manner.  It should be used within a lexical scope.  The following example launches threads to process items in a work queue.  Before each thread is launched, the available memory resources are checked using MemoryFailPoint.  If an exception is thrown, the main method waits until memory is available before launching the next thread.  \\n  \\n [!code-cs[MemoryFailPoint#1](~/add/codesnippet/csharp/t-system.runtime.memoryf_1.cs)]\"\n  syntax:\n    content: 'public sealed class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable'\n  inheritance:\n  - System.Object\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  implements:\n  - System.IDisposable\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  id: '#ctor(System.Int32)'\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: MemoryFailPoint(Int32)\n  nameWithType: MemoryFailPoint.MemoryFailPoint(Int32)\n  fullName: System.Runtime.MemoryFailPoint.MemoryFailPoint(Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> class, specifying the amount of memory required for successful execution.\n  remarks: The amount of memory used by your application to process a work item can be determined empirically.  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item. See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter.\n  example:\n  - \"The following example demonstrates how to determine the amount of memory a method requires when executing. This code example is part of a larger example provided for the <xref:System.Runtime.MemoryFailPoint> class.  \\n  \\n [!code-cs[MemoryFailPoint#2](~/add/codesnippet/csharp/m-system.runtime.memoryf_1.cs)]\"\n  syntax:\n    content: public MemoryFailPoint (int sizeInMegabytes);\n    parameters:\n    - id: sizeInMegabytes\n      type: System.Int32\n      description: The required memory size, in megabytes. This must be a positive value.\n  overload: System.Runtime.MemoryFailPoint.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The specified memory size is negative.\n  - type: System.InsufficientMemoryException\n    commentId: T:System.InsufficientMemoryException\n    description: There is insufficient memory to begin execution of the code protected by the gate.\n  platform:\n  - net462\n- uid: System.Runtime.MemoryFailPoint.Dispose\n  id: Dispose\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: MemoryFailPoint.Dispose()\n  fullName: System.Runtime.MemoryFailPoint.Dispose()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime\n  summary: Releases all resources used by the <xref href=\"System.Runtime.MemoryFailPoint\"></xref>.\n  remarks: \"Call Dispose when you are finished using the <xref:System.Runtime.MemoryFailPoint>. The Dispose method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state. After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/add/includes/ajax-current-ext-md.md) and [Implementing a Dispose Method](~/add/includes/ajax-current-ext-md.md).  \\n  \\n> [!NOTE]\\n>  Always call Dispose before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Runtime.MemoryFailPoint.Dispose*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Runtime.MemoryFailPoint.Finalize\n  id: Finalize\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: MemoryFailPoint.Finalize()\n  fullName: System.Runtime.MemoryFailPoint.Finalize()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime\n  summary: Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> object.\n  remarks: The garbage collector calls the Finalize method when the current object is ready to be finalized.\n  syntax:\n    content: ~MemoryFailPoint ();\n    parameters: []\n  overload: System.Runtime.MemoryFailPoint.Finalize*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.InsufficientMemoryException\n  parent: System\n  isExternal: false\n  name: InsufficientMemoryException\n  nameWithType: InsufficientMemoryException\n  fullName: System.InsufficientMemoryException\n- uid: System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: MemoryFailPoint(Int32)\n  nameWithType: MemoryFailPoint.MemoryFailPoint(Int32)\n  fullName: System.Runtime.MemoryFailPoint.MemoryFailPoint(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Runtime.MemoryFailPoint.Dispose\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Dispose()\n  nameWithType: MemoryFailPoint.Dispose()\n  fullName: System.Runtime.MemoryFailPoint.Dispose()\n- uid: System.Runtime.MemoryFailPoint.Finalize\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Finalize()\n  nameWithType: MemoryFailPoint.Finalize()\n  fullName: System.Runtime.MemoryFailPoint.Finalize()\n- uid: System.Runtime.MemoryFailPoint.#ctor*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: MemoryFailPoint\n  nameWithType: MemoryFailPoint.MemoryFailPoint\n- uid: System.Runtime.MemoryFailPoint.Dispose*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Dispose\n  nameWithType: MemoryFailPoint.Dispose\n- uid: System.Runtime.MemoryFailPoint.Finalize*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Finalize\n  nameWithType: MemoryFailPoint.Finalize\n"}