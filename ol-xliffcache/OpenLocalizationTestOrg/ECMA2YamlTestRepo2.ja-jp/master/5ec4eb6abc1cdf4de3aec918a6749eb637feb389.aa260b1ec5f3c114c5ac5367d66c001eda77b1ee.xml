{"nodes":[{"pos":[1349,1414],"content":"Defines a lock that supports single writers and multiple readers.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a lock that supports single writers and multiple readers.","pos":[0,65]}]},{"pos":[1427,5833],"content":"> [!IMPORTANT] >  The [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and ReaderWriterLock. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development. <xref:System.Threading.ReaderWriterLockSlim> is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than ReaderWriterLock.       ReaderWriterLock is used to synchronize access to a resource. At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread. In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.       `ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration. Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.      > [!NOTE] >  Holding reader locks or writer locks for long periods will starve other threads. For best performance, consider restructuring your application to minimize the duration of writes.       A thread can hold a reader lock or a writer lock, but not both at the same time. Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.       Recursive lock requests increase the lock count on a lock.       Readers and writers are queued separately. When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on. In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.       While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue. Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.       Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values. Use time-outs to avoid deadlocks in your application. For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first. Unless time-outs are used, the threads deadlock.       If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>. A thread can catch this exception and determine what action to take next.       Time-outs are expressed in milliseconds. If you use a <xref:System.TimeSpan?displayProperty=fullName> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>. The following table shows the valid time-out values in milliseconds.      |Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes. For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.|   |0|The thread does not wait to acquire the lock. If the lock cannot be acquired immediately, the method returns.|   |>0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed. If you specify a negative integer other than -1, a time-out value of zero is used instead. (That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&gt; [!IMPORTANT]</ph> &gt;  The <ph id=\"ph2\">[!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)]</ph> has two reader-writer locks, &lt;xref:System.Threading.ReaderWriterLockSlim&gt; and ReaderWriterLock.","pos":[0,175],"source":"> [!IMPORTANT] >  The [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and ReaderWriterLock."},{"content":"&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is recommended for all new development.","pos":[176,260],"source":" <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development."},{"content":"&lt;xref:System.Threading.ReaderWriterLockSlim&gt; is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state.","pos":[261,425],"source":" <xref:System.Threading.ReaderWriterLockSlim> is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state."},{"content":"&lt;xref:System.Threading.ReaderWriterLockSlim&gt; avoids many cases of potential deadlock.","pos":[426,511],"source":" <xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock."},{"content":"In addition, the performance of &lt;xref:System.Threading.ReaderWriterLockSlim&gt; is significantly better than ReaderWriterLock.","pos":[512,635],"source":" In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than ReaderWriterLock."},{"content":"ReaderWriterLock is used to synchronize access to a resource.","pos":[642,703]},{"content":"At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.","pos":[704,821]},{"content":"In a situation where a resource is changed infrequently, a <ph id=\"ph1\">`ReaderWriterLock`</ph> provides better throughput than a simple one-at-a-time lock, such as &lt;xref:System.Threading.Monitor&gt;.","pos":[822,1001],"source":" In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>."},{"content":"<ph id=\"ph1\">`ReaderWriterLock`</ph> works best where most accesses are reads, while writes are infrequent and of short duration.","pos":[1008,1119],"source":"`ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration."},{"content":"Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.","pos":[1120,1233]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Holding reader locks or writer locks for long periods will starve other threads.","pos":[1239,1332],"source":"      > [!NOTE] >  Holding reader locks or writer locks for long periods will starve other threads."},{"content":"For best performance, consider restructuring your application to minimize the duration of writes.","pos":[1333,1430]},{"content":"A thread can hold a reader lock or a writer lock, but not both at the same time.","pos":[1437,1517]},{"content":"Instead of releasing a reader lock in order to acquire the writer lock, you can use &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt;.","pos":[1518,1738],"source":" Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>."},{"content":"Recursive lock requests increase the lock count on a lock.","pos":[1745,1803]},{"content":"Readers and writers are queued separately.","pos":[1810,1852]},{"content":"When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.","pos":[1853,2117]},{"content":"In other words, <ph id=\"ph1\">`ReaderWriterLock`</ph> alternates between a collection of readers, and one writer.","pos":[2118,2212],"source":" In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer."},{"content":"While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.","pos":[2219,2372]},{"content":"Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.","pos":[2373,2553]},{"content":"Most methods for acquiring locks on a <ph id=\"ph1\">`ReaderWriterLock`</ph> accept time-out values.","pos":[2560,2640],"source":"       Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values."},{"content":"Use time-outs to avoid deadlocks in your application.","pos":[2641,2694]},{"content":"For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.","pos":[2695,2941]},{"content":"Unless time-outs are used, the threads deadlock.","pos":[2942,2990]},{"content":"If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an &lt;xref:System.ApplicationException&gt;.","pos":[2997,3172],"source":"       If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>."},{"content":"A thread can catch this exception and determine what action to take next.","pos":[3173,3246]},{"content":"Time-outs are expressed in milliseconds.","pos":[3253,3293]},{"content":"If you use a &lt;xref:System.TimeSpan?displayProperty=fullName&gt; to specify the time-out, the value used is the total number of whole milliseconds represented by the &lt;xref:System.TimeSpan&gt;.","pos":[3294,3479],"source":" If you use a <xref:System.TimeSpan?displayProperty=fullName> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>."},{"content":"The following table shows the valid time-out values in milliseconds.","pos":[3480,3548]},{"content":"|Value|Description|   |-----------|-----------------|   |-1|The thread waits until the lock is acquired, regardless of how long it takes.","pos":[3554,3691]},{"content":"For methods that specify integer time-outs, the constant &lt;xref:System.Threading.Timeout.Infinite&gt; can be used.|   |0|The thread does not wait to acquire the lock.","pos":[3692,3854],"source":" For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.|   |0|The thread does not wait to acquire the lock."},{"content":"If the lock cannot be acquired immediately, the method returns.|   |&gt;0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed.","pos":[3855,4036],"source":" If the lock cannot be acquired immediately, the method returns.|   |>0|The number of milliseconds to wait.|       With the exception of -1, negative time-out values are not allowed."},{"content":"If you specify a negative integer other than -1, a time-out value of zero is used instead.","pos":[4037,4127]},{"content":"(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a &lt;xref:System.TimeSpan&gt; that represents a negative number of milliseconds other than -1, &lt;xref:System.ArgumentOutOfRangeException&gt; is thrown.","pos":[4128,4376],"source":" (That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown."}]},{"pos":[7186,7281],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Threading.ReaderWriterLock\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLock\"></xref> class."},{"pos":[8792,8868],"content":"Acquires a reader lock, using an <xref:System.Int32> value for the time-out.","needQuote":true,"needEscape":true,"nodes":[{"content":"Acquires a reader lock, using an &lt;xref:System.Int32&gt; value for the time-out.","pos":[0,76],"source":"Acquires a reader lock, using an <xref:System.Int32> value for the time-out."}]},{"pos":[8881,10186],"content":"AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.      > [!NOTE] >  If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.       `AcquireReaderLock` supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.       Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.","pos":[0,125]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.","pos":[131,222],"source":"      > [!NOTE] >  If the current thread already has the writer lock, no reader lock is acquired."},{"content":"Instead, the lock count on the writer lock is incremented.","pos":[223,281]},{"content":"This prevents a thread from blocking on its own writer lock.","pos":[282,342]},{"content":"The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.","pos":[343,579],"source":" The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock."},{"content":"<ph id=\"ph1\">`AcquireReaderLock`</ph> supports recursive reader-lock requests.","pos":[586,646],"source":"`AcquireReaderLock` supports recursive reader-lock requests."},{"content":"That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.","pos":[647,750]},{"content":"You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id=\"ph1\">`AcquireReaderLock`</ph>.","pos":[751,875],"source":" You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`."},{"content":"Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.","pos":[876,1005],"source":" Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately."},{"content":"Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.","pos":[1012,1126]},{"content":"Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.","pos":[1127,1217]},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1224,1296],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[11614,11643],"content":"The time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]}]},{"pos":[11823,11899],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>millisecondsTimeout</code> expires before the lock request is granted."},{"pos":[12358,12436],"content":"Acquires a reader lock, using a <xref:System.TimeSpan> value for the time-out.","needQuote":true,"needEscape":true,"nodes":[{"content":"Acquires a reader lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.","pos":[0,78],"source":"Acquires a reader lock, using a <xref:System.TimeSpan> value for the time-out."}]},{"pos":[12449,13798],"content":"<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.      > [!NOTE] >  If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.       `AcquireReaderLock` supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.       Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"&lt;xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A&gt; blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.","pos":[0,169],"source":"<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  If the current thread already has the writer lock, no reader lock is acquired.","pos":[175,266],"source":"      > [!NOTE] >  If the current thread already has the writer lock, no reader lock is acquired."},{"content":"Instead, the lock count on the writer lock is incremented.","pos":[267,325]},{"content":"This prevents a thread from blocking on its own writer lock.","pos":[326,386]},{"content":"The result is exactly the same as calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, and an additional call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; is required when releasing the writer lock.","pos":[387,623],"source":" The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock."},{"content":"<ph id=\"ph1\">`AcquireReaderLock`</ph> supports recursive reader-lock requests.","pos":[630,690],"source":"`AcquireReaderLock` supports recursive reader-lock requests."},{"content":"That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.","pos":[691,794]},{"content":"You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A&gt; once for each time you call <ph id=\"ph1\">`AcquireReaderLock`</ph>.","pos":[795,919],"source":" You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`."},{"content":"Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.","pos":[920,1049],"source":" Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately."},{"content":"Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.","pos":[1056,1170]},{"content":"Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.","pos":[1171,1261]},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1268,1340],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[13954,14056],"content":"A <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> specifying the time-out period.","needQuote":true,"needEscape":true,"source":"A <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period."},{"pos":[14236,14300],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> expires before the lock request is granted."},{"pos":[14415,14490],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> specifies a negative value other than -1 milliseconds."},{"pos":[14934,15012],"content":"Acquires the writer lock, using an <xref:System.Int32> value for the time-out.","needQuote":true,"needEscape":true,"nodes":[{"content":"Acquires the writer lock, using an &lt;xref:System.Int32&gt; value for the time-out.","pos":[0,78],"source":"Acquires the writer lock, using an <xref:System.Int32> value for the time-out."}]},{"pos":[15025,16473],"content":"This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.       A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.      > [!CAUTION] >  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.       `AcquireWriterLock` supports recursive writer-lock requests. That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.       Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks if another thread has a reader lock or writer lock.","pos":[0,70]},{"content":"For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.","pos":[71,221],"source":" For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class."},{"content":"A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.","pos":[228,457],"source":"       A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  If a thread calls <ph id=\"ph2\">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.","pos":[463,652],"source":"      > [!CAUTION] >  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock."},{"content":"To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.","pos":[653,809],"source":" To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock."},{"content":"<ph id=\"ph1\">`AcquireWriterLock`</ph> supports recursive writer-lock requests.","pos":[816,876],"source":"`AcquireWriterLock` supports recursive writer-lock requests."},{"content":"That is, a thread can call <ph id=\"ph1\">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.","pos":[877,982],"source":" That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time."},{"content":"You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id=\"ph1\">`AcquireWriterLock`</ph>.","pos":[983,1107],"source":" You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`."},{"content":"Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.","pos":[1108,1237],"source":" Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately."},{"content":"Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.","pos":[1244,1358]},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1365,1437],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[17901,17930],"content":"The time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]}]},{"pos":[18110,18174],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> expires before the lock request is granted."},{"pos":[18633,18713],"content":"Acquires the writer lock, using a <xref:System.TimeSpan> value for the time-out.","needQuote":true,"needEscape":true,"nodes":[{"content":"Acquires the writer lock, using a &lt;xref:System.TimeSpan&gt; value for the time-out.","pos":[0,80],"source":"Acquires the writer lock, using a <xref:System.TimeSpan> value for the time-out."}]},{"pos":[18726,20218],"content":"This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.       A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.      > [!CAUTION] >  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.       `AcquireWriterLock` supports recursive writer-lock requests. That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.       Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks if another thread has a reader lock or writer lock.","pos":[0,70]},{"content":"For a description of the way the writer lock alternates with multiple concurrent reader locks, see the &lt;xref:System.Threading.ReaderWriterLock&gt; class.","pos":[71,221],"source":" For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class."},{"content":"A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt;, or by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.","pos":[228,501],"source":"       A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  If a thread calls <ph id=\"ph2\">`AcquireWriterLock`</ph> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.","pos":[507,696],"source":"      > [!CAUTION] >  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock."},{"content":"To avoid such deadlocks, use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; to determine whether the current thread already has a reader lock.","pos":[697,853],"source":" To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock."},{"content":"<ph id=\"ph1\">`AcquireWriterLock`</ph> supports recursive writer-lock requests.","pos":[860,920],"source":"`AcquireWriterLock` supports recursive writer-lock requests."},{"content":"That is, a thread can call <ph id=\"ph1\">`AcquireWriterLock`</ph> multiple times, which increments the lock count each time.","pos":[921,1026],"source":" That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time."},{"content":"You must call &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt; once for each time you call <ph id=\"ph1\">`AcquireWriterLock`</ph>.","pos":[1027,1151],"source":" You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`."},{"content":"Alternatively, you can call &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt; to reduce the lock count to zero immediately.","pos":[1152,1281],"source":" Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately."},{"content":"Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.","pos":[1288,1402]},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1409,1481],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[20374,20478],"content":"The <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> specifying the time-out period.","needQuote":true,"needEscape":true,"source":"The <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period."},{"pos":[20658,20722],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> expires before the lock request is granted."},{"pos":[20837,20912],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> specifies a negative value other than -1 milliseconds."},{"pos":[21346,21450],"content":"Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.","needQuote":true,"needEscape":true,"nodes":[{"content":"Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.","pos":[0,104]}]},{"pos":[21463,22131],"content":"You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used. This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.       The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.","needQuote":false,"needEscape":true,"nodes":[{"content":"You can use &lt;xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A&gt; and <ph id=\"ph1\">`AnyWritersSince`</ph> to improve application performance.","pos":[0,126],"source":"You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance."},{"content":"For example, a thread might cache the information it obtains while holding a reader lock.","pos":[127,216]},{"content":"After releasing and later reacquiring the lock, the thread can use <ph id=\"ph1\">`AnyWritersSince`</ph> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.","pos":[217,425],"source":" After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used."},{"content":"This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.","pos":[426,555]},{"content":"The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.","pos":[562,666]}]},{"pos":[23675,23695],"content":"The sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number.","pos":[0,20]}]},{"pos":[23754,23979],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[24580,24714],"content":"Restores the lock status of the thread to what it was before <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*> was called.","needQuote":true,"needEscape":true,"nodes":[{"content":"Restores the lock status of the thread to what it was before &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt; was called.","pos":[0,134],"source":"Restores the lock status of the thread to what it was before <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*> was called."}]},{"pos":[24727,25434],"content":"DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock. The lock count on the reader lock is restored.      > [!NOTE] >  `DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.       A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.","needQuote":false,"needEscape":true,"nodes":[{"content":"DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.","pos":[0,183]},{"content":"The lock count on the reader lock is restored.","pos":[184,230]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph><ph id=\"ph2\"> &gt;  </ph><ph id=\"ph3\">`DowngradeFromWriterLock`</ph> accepts a &lt;xref:System.Threading.LockCookie&gt; obtained by calling &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.","pos":[236,404],"source":"      > [!NOTE] >  `DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>."},{"content":"Do not use a <ph id=\"ph1\">`LockCookie`</ph> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.","pos":[405,499],"source":" Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>."},{"content":"A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.","pos":[506,702]}]},{"pos":[26878,27003],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.LockCookie\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*&gt;.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.LockCookie\"></xref> returned by <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>."},{"pos":[27189,27230],"content":"The thread does not have the writer lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"The thread does not have the writer lock.","pos":[0,41]}]},{"pos":[27335,27392],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockCookie</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","needQuote":true,"needEscape":true,"source":"The address of <code>lockCookie</code> is a null pointer."},{"pos":[27748,27926],"content":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <bpt id=\"p1\">&lt;xref href=\"System.Threading.ReaderWriterLock\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object.","needQuote":true,"needEscape":true,"source":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Threading.ReaderWriterLock\"></xref> object."},{"pos":[27938,28065],"content":"The garbage collector calls Finalize when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.","needQuote":true,"needEscape":true,"nodes":[{"content":"The garbage collector calls Finalize when the current &lt;xref:System.Threading.ReaderWriterLock&gt; object is ready to be finalized.","pos":[0,127],"source":"The garbage collector calls Finalize when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized."}]},{"pos":[28594,28665],"content":"Gets a value indicating whether the current thread holds a reader lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating whether the current thread holds a reader lock.","pos":[0,71]}]},{"pos":[29291,29469],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the current thread holds a reader lock; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current thread holds a reader lock; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[29942,30015],"content":"Gets a value indicating whether the current thread holds the writer lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating whether the current thread holds the writer lock.","pos":[0,73]}]},{"pos":[30789,30969],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the current thread holds the writer lock; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current thread holds the writer lock; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[31421,31503],"content":"Releases the lock, regardless of the number of times the thread acquired the lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"Releases the lock, regardless of the number of times the thread acquired the lock.","pos":[0,82]}]},{"pos":[31515,31771],"content":"ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count. To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.","needQuote":true,"needEscape":true,"nodes":[{"content":"ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count. To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.","pos":[0,256],"nodes":[{"content":"ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count.","pos":[0,92]},{"content":"To restore the state of the lock, including the lock count, pass the &lt;xref:System.Threading.LockCookie&gt; to &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.","pos":[93,256],"source":" To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>."}]}]},{"pos":[33253,33341],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.LockCookie\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value representing the released lock.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.LockCookie\"></xref> value representing the released lock."},{"pos":[33818,33844],"content":"Decrements the lock count.","needQuote":true,"needEscape":true,"nodes":[{"content":"Decrements the lock count.","pos":[0,26]}]},{"pos":[33857,34228],"content":"ReleaseReaderLock decrements the lock count. When the count reaches zero, the lock is released.      > [!NOTE] >  If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.","needQuote":false,"needEscape":true,"nodes":[{"content":"ReleaseReaderLock decrements the lock count.","pos":[0,44]},{"content":"When the count reaches zero, the lock is released.","pos":[45,95]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  If a thread has the writer lock, calling <ph id=\"ph2\">`ReleaseReaderLock`</ph> has the same effect as calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A&gt;.","pos":[101,268],"source":"      > [!NOTE] >  If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>."},{"content":"If a thread has no locks, calling <ph id=\"ph1\">`ReleaseReaderLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.","pos":[269,368],"source":" If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>."}]},{"pos":[35741,35793],"content":"The thread does not have any reader or writer locks.","needQuote":true,"needEscape":true,"nodes":[{"content":"The thread does not have any reader or writer locks.","pos":[0,52]}]},{"pos":[36194,36239],"content":"Decrements the lock count on the writer lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"Decrements the lock count on the writer lock.","pos":[0,45]}]},{"pos":[36252,36500],"content":"ReleaseWriterLock decrements the writer lock count. When the count reaches zero, the writer lock is released.      > [!NOTE] >  If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.","needQuote":false,"needEscape":true,"nodes":[{"content":"ReleaseWriterLock decrements the writer lock count.","pos":[0,51]},{"content":"When the count reaches zero, the writer lock is released.","pos":[52,109]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  If a thread has a reader lock, or no locks, calling <ph id=\"ph2\">`ReleaseWriterLock`</ph> throws an &lt;xref:System.ApplicationException&gt;.","pos":[115,245],"source":"      > [!NOTE] >  If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>."}]},{"pos":[38013,38054],"content":"The thread does not have the writer lock.","needQuote":true,"needEscape":true,"nodes":[{"content":"The thread does not have the writer lock.","pos":[0,41]}]},{"pos":[38515,38638],"content":"Restores the lock status of the thread to what it was before calling <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.","needQuote":true,"needEscape":true,"nodes":[{"content":"Restores the lock status of the thread to what it was before calling &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.","pos":[0,123],"source":"Restores the lock status of the thread to what it was before calling <xref:System.Threading.ReaderWriterLock.ReleaseLock*>."}]},{"pos":[38651,39628],"content":"The state restored by `RestoreLock` includes the recursive lock count.       A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock. Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.      > [!CAUTION] >  Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock. Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.       Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.","needQuote":false,"needEscape":true,"nodes":[{"content":"The state restored by <ph id=\"ph1\">`RestoreLock`</ph> includes the recursive lock count.","pos":[0,70],"source":"The state restored by `RestoreLock` includes the recursive lock count."},{"content":"A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.","pos":[77,286]},{"content":"Because <ph id=\"ph1\">`RestoreLock`</ph> does not accept a time-out, you should take care to avoid possible deadlocks.","pos":[287,386],"source":" Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Before calling <ph id=\"ph2\">`RestoreLock`</ph>, make sure you have released all locks acquired since the call to &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock%2A&gt;.","pos":[392,559],"source":"      > [!CAUTION] >  Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>."},{"content":"For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.","pos":[560,674]},{"content":"Use &lt;xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A&gt; and &lt;xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A&gt; to detect such additional locks.","pos":[675,837],"source":" Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks."},{"content":"Do not use a &lt;xref:System.Threading.LockCookie&gt; returned from &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt;.","pos":[844,970],"source":"       Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>."}]},{"pos":[41180,41297],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.LockCookie\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> returned by &lt;xref:System.Threading.ReaderWriterLock.ReleaseLock*&gt;.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.LockCookie\"></xref> returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock*>."},{"pos":[41475,41532],"content":"The address of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockCookie</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a null pointer.","needQuote":true,"needEscape":true,"source":"The address of <code>lockCookie</code> is a null pointer."},{"pos":[41986,42124],"content":"Upgrades a reader lock to the writer lock, using an <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_Int32\" name=\"Int32\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value for the time-out.","needQuote":true,"needEscape":true,"source":"Upgrades a reader lock to the writer lock, using an <xref uid=\"langword_csharp_Int32\" name=\"Int32\" href=\"\"></xref> value for the time-out."},{"pos":[42137,43575],"content":"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.      > [!IMPORTANT] >  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.       To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`. Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.       When a thread has no reader lock, do not use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"When a thread calls <ph id=\"ph1\">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.","pos":[0,165],"source":"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock."},{"content":"Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.","pos":[166,286]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock.","pos":[292,437],"source":"      > [!IMPORTANT] >  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock."},{"content":"If there are no other threads waiting for the writer lock, this happens immediately.","pos":[438,522]},{"content":"However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.","pos":[523,778]},{"content":"This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.","pos":[779,924]},{"content":"To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id=\"ph1\">`UpgradeToWriterLock`</ph>.","pos":[931,1110],"source":"       To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`."},{"content":"Do not use this <ph id=\"ph1\">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.","pos":[1111,1201],"source":" Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>."},{"content":"When a thread has no reader lock, do not use <ph id=\"ph1\">`UpgradeToWriterLock`</ph>.","pos":[1208,1275],"source":"       When a thread has no reader lock, do not use `UpgradeToWriterLock`."},{"content":"Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.","pos":[1276,1350],"source":" Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead."},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1357,1429],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[45031,45060],"content":"The time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]}]},{"pos":[45132,45189],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.LockCookie\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.LockCookie\"></xref> value."},{"pos":[45371,45447],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>millisecondsTimeout</code> expires before the lock request is granted."},{"pos":[45916,46059],"content":"Upgrades a reader lock to the writer lock, using a <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value for the time-out.","needQuote":true,"needEscape":true,"source":"Upgrades a reader lock to the writer lock, using a <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> value for the time-out."},{"pos":[46072,47642],"content":"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.      > [!IMPORTANT] >  The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.       To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`. Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.       When a thread has no reader lock, do not use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.","needQuote":false,"needEscape":true,"nodes":[{"content":"When a thread calls <ph id=\"ph1\">`UpgradeToWriterLock`</ph> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.","pos":[0,165],"source":"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock."},{"content":"Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.","pos":[166,286]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  The time-out exception is not thrown until the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method can reacquire the reader lock.","pos":[292,481],"source":"      > [!IMPORTANT] >  The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock."},{"content":"If there are no other threads waiting for the writer lock, this happens immediately.","pos":[482,566]},{"content":"However, if another thread is queued for the writer lock, the thread that called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.","pos":[567,866],"source":" However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock."},{"content":"This is true even if the other thread that requested the writer lock requested it after the current thread called the &lt;xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A&gt; method.","pos":[867,1056],"source":" This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method."},{"content":"To restore the lock state, call &lt;xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A&gt; using the &lt;xref:System.Threading.LockCookie&gt; returned by <ph id=\"ph1\">`UpgradeToWriterLock`</ph>.","pos":[1063,1242],"source":"       To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`."},{"content":"Do not use this <ph id=\"ph1\">`LockCookie`</ph> with &lt;xref:System.Threading.ReaderWriterLock.RestoreLock%2A&gt;.","pos":[1243,1333],"source":" Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>."},{"content":"When a thread has no reader lock, do not use <ph id=\"ph1\">`UpgradeToWriterLock`</ph>.","pos":[1340,1407],"source":"       When a thread has no reader lock, do not use `UpgradeToWriterLock`."},{"content":"Use &lt;xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A&gt; instead.","pos":[1408,1482],"source":" Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead."},{"content":"For valid time-out values, see &lt;xref:System.Threading.ReaderWriterLock&gt;.","pos":[1489,1561],"source":"       For valid time-out values, see <xref:System.Threading.ReaderWriterLock>."}]},{"pos":[47823,47927],"content":"The <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> specifying the time-out period.","needQuote":true,"needEscape":true,"source":"The <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period."},{"pos":[47999,48056],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.LockCookie\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.LockCookie\"></xref> value."},{"pos":[48238,48302],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> expires before the lock request is granted.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> expires before the lock request is granted."},{"pos":[48417,48492],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> specifies a negative value other than -1 milliseconds.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> specifies a negative value other than -1 milliseconds."},{"pos":[48864,48897],"content":"Gets the current sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the current sequence number.","pos":[0,33]}]},{"pos":[48910,49803],"content":"The sequence number increases whenever a thread acquires the writer lock. You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.       You can use `WriterSeqNum` to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used. This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.       The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.","needQuote":false,"needEscape":true,"nodes":[{"content":"The sequence number increases whenever a thread acquires the writer lock.","pos":[0,73]},{"content":"You can save the sequence number and pass it to &lt;xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A&gt; at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.","pos":[74,292],"source":" You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime."},{"content":"You can use <ph id=\"ph1\">`WriterSeqNum`</ph> to improve application performance.","pos":[299,361],"source":"       You can use `WriterSeqNum` to improve application performance."},{"content":"For example, a thread might cache the information it obtains while holding a reader lock.","pos":[362,451]},{"content":"After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <ph id=\"ph1\">`AnyWritersSince`</ph>; if not, the cached information can be used.","pos":[452,649],"source":" After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used."},{"content":"This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.","pos":[650,778]},{"content":"The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.","pos":[785,889]}]},{"pos":[51317,51345],"content":"The current sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The current sequence number.","pos":[0,28]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.ReaderWriterLock\n  id: ReaderWriterLock\n  children:\n  - System.Threading.ReaderWriterLock.#ctor\n  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)\n  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)\n  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)\n  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)\n  - System.Threading.ReaderWriterLock.Finalize\n  - System.Threading.ReaderWriterLock.IsReaderLockHeld\n  - System.Threading.ReaderWriterLock.IsWriterLockHeld\n  - System.Threading.ReaderWriterLock.ReleaseLock\n  - System.Threading.ReaderWriterLock.ReleaseReaderLock\n  - System.Threading.ReaderWriterLock.ReleaseWriterLock\n  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)\n  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)\n  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLock.WriterSeqNum\n  langs:\n  - csharp\n  name: ReaderWriterLock\n  nameWithType: ReaderWriterLock\n  fullName: System.Threading.ReaderWriterLock\n  type: Class\n  summary: Defines a lock that supports single writers and multiple readers.\n  remarks: \"> [!IMPORTANT]\\n>  The [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and ReaderWriterLock. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development. <xref:System.Threading.ReaderWriterLockSlim> is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than ReaderWriterLock.  \\n  \\n ReaderWriterLock is used to synchronize access to a resource. At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread. In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.  \\n  \\n `ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration. Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.  \\n  \\n> [!NOTE]\\n>  Holding reader locks or writer locks for long periods will starve other threads. For best performance, consider restructuring your application to minimize the duration of writes.  \\n  \\n A thread can hold a reader lock or a writer lock, but not both at the same time. Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  \\n  \\n Recursive lock requests increase the lock count on a lock.  \\n  \\n Readers and writers are queued separately. When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on. In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.  \\n  \\n While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue. Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.  \\n  \\n Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values. Use time-outs to avoid deadlocks in your application. For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first. Unless time-outs are used, the threads deadlock.  \\n  \\n If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>. A thread can catch this exception and determine what action to take next.  \\n  \\n Time-outs are expressed in milliseconds. If you use a <xref:System.TimeSpan?displayProperty=fullName> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>. The following table shows the valid time-out values in milliseconds.  \\n  \\n|Value|Description|  \\n|-----------|-----------------|  \\n|-1|The thread waits until the lock is acquired, regardless of how long it takes. For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.|  \\n|0|The thread does not wait to acquire the lock. If the lock cannot be acquired immediately, the method returns.|  \\n|>0|The number of milliseconds to wait.|  \\n  \\n With the exception of -1, negative time-out values are not allowed. If you specify a negative integer other than -1, a time-out value of zero is used instead. (That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.\"\n  example:\n  - \"The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  inheritance:\n  - System.Object\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.#ctor\n  id: '#ctor'\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: ReaderWriterLock()\n  nameWithType: ReaderWriterLock.ReaderWriterLock()\n  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLock\"></xref> class.\n  remarks: ''\n  example:\n  - \"The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]\"\n  syntax:\n    content: public ReaderWriterLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLock.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)\n  id: AcquireReaderLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: AcquireReaderLock(Int32)\n  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Acquires a reader lock, using an <xref:System.Int32> value for the time-out.\n  remarks: \"AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.  \\n  \\n> [!NOTE]\\n>  If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.  \\n  \\n `AcquireReaderLock` supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.  \\n  \\n Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  example:\n  - \"The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]\"\n  syntax:\n    content: public void AcquireReaderLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The time-out in milliseconds.\n  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>millisecondsTimeout</code> expires before the lock request is granted.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)\n  id: AcquireReaderLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: AcquireReaderLock(TimeSpan)\n  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Acquires a reader lock, using a <xref:System.TimeSpan> value for the time-out.\n  remarks: \"<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.  \\n  \\n> [!NOTE]\\n>  If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.  \\n  \\n `AcquireReaderLock` supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.  \\n  \\n Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  syntax:\n    content: public void AcquireReaderLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period.\n  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>timeout</code> expires before the lock request is granted.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> specifies a negative value other than -1 milliseconds.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)\n  id: AcquireWriterLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: AcquireWriterLock(Int32)\n  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Acquires the writer lock, using an <xref:System.Int32> value for the time-out.\n  remarks: \"This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  \\n  \\n> [!CAUTION]\\n>  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.  \\n  \\n `AcquireWriterLock` supports recursive writer-lock requests. That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.  \\n  \\n Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  example:\n  - \"The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]\"\n  syntax:\n    content: public void AcquireWriterLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The time-out in milliseconds.\n  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>timeout</code> expires before the lock request is granted.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)\n  id: AcquireWriterLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: AcquireWriterLock(TimeSpan)\n  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Acquires the writer lock, using a <xref:System.TimeSpan> value for the time-out.\n  remarks: \"This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  \\n  \\n> [!CAUTION]\\n>  If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.  \\n  \\n `AcquireWriterLock` supports recursive writer-lock requests. That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time. You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`. Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.  \\n  \\n Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  syntax:\n    content: public void AcquireWriterLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period.\n  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>timeout</code> expires before the lock request is granted.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> specifies a negative value other than -1 milliseconds.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)\n  id: AnyWritersSince(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: AnyWritersSince(Int32)\n  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)\n  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.\n  remarks: \"You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used. This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.  \\n  \\n The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.\"\n  example:\n  - \"The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]\"\n  syntax:\n    content: public bool AnyWritersSince (int seqNum);\n    parameters:\n    - id: seqNum\n      type: System.Int32\n      description: The sequence number.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ReaderWriterLock.AnyWritersSince*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)\n  id: DowngradeFromWriterLock(System.Threading.LockCookie@)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: DowngradeFromWriterLock(LockCookie)\n  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)\n  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Restores the lock status of the thread to what it was before <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*> was called.\n  remarks: \"DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock. The lock count on the reader lock is restored.  \\n  \\n> [!NOTE]\\n>  `DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  \\n  \\n A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.\"\n  example:\n  - \"The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]\"\n  syntax:\n    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);\n    parameters:\n    - id: lockCookie\n      type: System.Threading.LockCookie\n      description: A <xref href=\"System.Threading.LockCookie\"></xref> returned by <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.\n  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: The thread does not have the writer lock.\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>lockCookie</code> is a null pointer.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.Finalize\n  id: Finalize\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: ReaderWriterLock.Finalize()\n  fullName: System.Threading.ReaderWriterLock.Finalize()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Threading.ReaderWriterLock\"></xref> object.\n  remarks: The garbage collector calls Finalize when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.\n  syntax:\n    content: ~ReaderWriterLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLock.Finalize*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld\n  id: IsReaderLockHeld\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: IsReaderLockHeld\n  nameWithType: ReaderWriterLock.IsReaderLockHeld\n  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets a value indicating whether the current thread holds a reader lock.\n  remarks: ''\n  example:\n  - \"The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]\"\n  syntax:\n    content: public bool IsReaderLockHeld { get; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current thread holds a reader lock; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld\n  id: IsWriterLockHeld\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: IsWriterLockHeld\n  nameWithType: ReaderWriterLock.IsWriterLockHeld\n  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets a value indicating whether the current thread holds the writer lock.\n  remarks: ''\n  example:\n  - \"The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]\"\n  syntax:\n    content: public bool IsWriterLockHeld { get; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the current thread holds the writer lock; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.ReleaseLock\n  id: ReleaseLock\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: ReleaseLock()\n  nameWithType: ReaderWriterLock.ReleaseLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseLock()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Releases the lock, regardless of the number of times the thread acquired the lock.\n  remarks: ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count. To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.\n  example:\n  - \"The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]\"\n  syntax:\n    content: public System.Threading.LockCookie ReleaseLock ();\n    parameters: []\n    return:\n      type: System.Threading.LockCookie\n      description: A <xref href=\"System.Threading.LockCookie\"></xref> value representing the released lock.\n  overload: System.Threading.ReaderWriterLock.ReleaseLock*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock\n  id: ReleaseReaderLock\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: ReleaseReaderLock()\n  nameWithType: ReaderWriterLock.ReleaseReaderLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Decrements the lock count.\n  remarks: \"ReleaseReaderLock decrements the lock count. When the count reaches zero, the lock is released.  \\n  \\n> [!NOTE]\\n>  If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.\"\n  example:\n  - \"The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]\"\n  syntax:\n    content: public void ReleaseReaderLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: The thread does not have any reader or writer locks.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock\n  id: ReleaseWriterLock\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: ReleaseWriterLock()\n  nameWithType: ReaderWriterLock.ReleaseWriterLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Decrements the lock count on the writer lock.\n  remarks: \"ReleaseWriterLock decrements the writer lock count. When the count reaches zero, the writer lock is released.  \\n  \\n> [!NOTE]\\n>  If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.\"\n  example:\n  - \"The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]\"\n  syntax:\n    content: public void ReleaseWriterLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: The thread does not have the writer lock.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)\n  id: RestoreLock(System.Threading.LockCookie@)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: RestoreLock(LockCookie)\n  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)\n  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Restores the lock status of the thread to what it was before calling <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.\n  remarks: \"The state restored by `RestoreLock` includes the recursive lock count.  \\n  \\n A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock. Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.  \\n  \\n> [!CAUTION]\\n>  Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock. Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.  \\n  \\n Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.\"\n  example:\n  - \"The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]\"\n  syntax:\n    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);\n    parameters:\n    - id: lockCookie\n      type: System.Threading.LockCookie\n      description: A <xref href=\"System.Threading.LockCookie\"></xref> returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.\n  overload: System.Threading.ReaderWriterLock.RestoreLock*\n  exceptions:\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: The address of <code>lockCookie</code> is a null pointer.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)\n  id: UpgradeToWriterLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: UpgradeToWriterLock(Int32)\n  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Upgrades a reader lock to the writer lock, using an <xref uid=\"langword_csharp_Int32\" name=\"Int32\" href=\"\"></xref> value for the time-out.\n  remarks: \"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.  \\n  \\n> [!IMPORTANT]\\n>  The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.  \\n  \\n To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`. Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  \\n  \\n When a thread has no reader lock, do not use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  example:\n  - \"The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]\"\n  syntax:\n    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The time-out in milliseconds.\n    return:\n      type: System.Threading.LockCookie\n      description: A <xref href=\"System.Threading.LockCookie\"></xref> value.\n  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>millisecondsTimeout</code> expires before the lock request is granted.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)\n  id: UpgradeToWriterLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: UpgradeToWriterLock(TimeSpan)\n  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Upgrades a reader lock to the writer lock, using a <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> value for the time-out.\n  remarks: \"When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.  \\n  \\n> [!IMPORTANT]\\n>  The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.  \\n  \\n To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`. Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  \\n  \\n When a thread has no reader lock, do not use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.  \\n  \\n For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.\"\n  syntax:\n    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref uid=\"langword_csharp_TimeSpan\" name=\"TimeSpan\" href=\"\"></xref> specifying the time-out period.\n    return:\n      type: System.Threading.LockCookie\n      description: A <xref href=\"System.Threading.LockCookie\"></xref> value.\n  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*\n  exceptions:\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>timeout</code> expires before the lock request is granted.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> specifies a negative value other than -1 milliseconds.\n  platform:\n  - net462\n- uid: System.Threading.ReaderWriterLock.WriterSeqNum\n  id: WriterSeqNum\n  parent: System.Threading.ReaderWriterLock\n  langs:\n  - csharp\n  name: WriterSeqNum\n  nameWithType: ReaderWriterLock.WriterSeqNum\n  fullName: System.Threading.ReaderWriterLock.WriterSeqNum\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets the current sequence number.\n  remarks: \"The sequence number increases whenever a thread acquires the writer lock. You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.  \\n  \\n You can use `WriterSeqNum` to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used. This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.  \\n  \\n The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.\"\n  example:\n  - \"The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \\n  \\n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \\n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]\"\n  syntax:\n    content: public int WriterSeqNum { get; }\n    return:\n      type: System.Int32\n      description: The current sequence number.\n  overload: System.Threading.ReaderWriterLock.WriterSeqNum*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  isExternal: false\n  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n- uid: System.ApplicationException\n  parent: System\n  isExternal: false\n  name: ApplicationException\n  nameWithType: ApplicationException\n  fullName: System.ApplicationException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.NullReferenceException\n  isExternal: true\n  name: System.NullReferenceException\n- uid: System.Threading.ReaderWriterLock.#ctor\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReaderWriterLock()\n  nameWithType: ReaderWriterLock.ReaderWriterLock()\n  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()\n- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireReaderLock(Int32)\n  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireReaderLock(TimeSpan)\n  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: true\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireWriterLock(Int32)\n  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)\n- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireWriterLock(TimeSpan)\n  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AnyWritersSince(Int32)\n  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)\n  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: DowngradeFromWriterLock(LockCookie)\n  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)\n  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)\n- uid: System.Threading.LockCookie\n  parent: System.Threading\n  isExternal: false\n  name: LockCookie\n  nameWithType: LockCookie\n  fullName: System.Threading.LockCookie\n- uid: System.Threading.ReaderWriterLock.Finalize\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: Finalize()\n  nameWithType: ReaderWriterLock.Finalize()\n  fullName: System.Threading.ReaderWriterLock.Finalize()\n- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: IsReaderLockHeld\n  nameWithType: ReaderWriterLock.IsReaderLockHeld\n  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld\n- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: IsWriterLockHeld\n  nameWithType: ReaderWriterLock.IsWriterLockHeld\n  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld\n- uid: System.Threading.ReaderWriterLock.ReleaseLock\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseLock()\n  nameWithType: ReaderWriterLock.ReleaseLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseLock()\n- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseReaderLock()\n  nameWithType: ReaderWriterLock.ReleaseReaderLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()\n- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseWriterLock()\n  nameWithType: ReaderWriterLock.ReleaseWriterLock()\n  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()\n- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: RestoreLock(LockCookie)\n  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)\n  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)\n- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: UpgradeToWriterLock(Int32)\n  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)\n  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)\n- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: UpgradeToWriterLock(TimeSpan)\n  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)\n  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLock.WriterSeqNum\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: WriterSeqNum\n  nameWithType: ReaderWriterLock.WriterSeqNum\n  fullName: System.Threading.ReaderWriterLock.WriterSeqNum\n- uid: System.Threading.ReaderWriterLock.#ctor*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReaderWriterLock\n  nameWithType: ReaderWriterLock.ReaderWriterLock\n- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireReaderLock\n  nameWithType: ReaderWriterLock.AcquireReaderLock\n- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AcquireWriterLock\n  nameWithType: ReaderWriterLock.AcquireWriterLock\n- uid: System.Threading.ReaderWriterLock.AnyWritersSince*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: AnyWritersSince\n  nameWithType: ReaderWriterLock.AnyWritersSince\n- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: DowngradeFromWriterLock\n  nameWithType: ReaderWriterLock.DowngradeFromWriterLock\n- uid: System.Threading.ReaderWriterLock.Finalize*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: Finalize\n  nameWithType: ReaderWriterLock.Finalize\n- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: IsReaderLockHeld\n  nameWithType: ReaderWriterLock.IsReaderLockHeld\n- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: IsWriterLockHeld\n  nameWithType: ReaderWriterLock.IsWriterLockHeld\n- uid: System.Threading.ReaderWriterLock.ReleaseLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseLock\n  nameWithType: ReaderWriterLock.ReleaseLock\n- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseReaderLock\n  nameWithType: ReaderWriterLock.ReleaseReaderLock\n- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: ReleaseWriterLock\n  nameWithType: ReaderWriterLock.ReleaseWriterLock\n- uid: System.Threading.ReaderWriterLock.RestoreLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: RestoreLock\n  nameWithType: ReaderWriterLock.RestoreLock\n- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: UpgradeToWriterLock\n  nameWithType: ReaderWriterLock.UpgradeToWriterLock\n- uid: System.Threading.ReaderWriterLock.WriterSeqNum*\n  parent: System.Threading.ReaderWriterLock\n  isExternal: false\n  name: WriterSeqNum\n  nameWithType: ReaderWriterLock.WriterSeqNum\n"}