{"nodes":[{"pos":[430,500],"content":"Allows an object to control its own serialization and deserialization.","needQuote":true,"needEscape":true,"nodes":[{"content":"Allows an object to control its own serialization and deserialization.","pos":[0,70]}]},{"pos":[513,4650],"content":"Any class that might be serialized must be marked with the <xref:System.SerializableAttribute>. If a class needs to control its serialization process, it can implement the ISerializable interface. The <xref:System.Runtime.Serialization.Formatter> calls the <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> at serialization time and populates the supplied <xref:System.Runtime.Serialization.SerializationInfo> with all the data required to represent the object. The <xref:System.Runtime.Serialization.Formatter> creates a <xref:System.Runtime.Serialization.SerializationInfo> with the type of the object in the graph. Objects that need to send proxies for themselves can use the <xref:System.Runtime.Serialization.SerializationInfo.FullTypeName%2A> and <xref:System.Runtime.Serialization.SerializationInfo.AssemblyName%2A> methods on <xref:System.Runtime.Serialization.SerializationInfo> to change the transmitted information.       In the case of class inheritance, it is possible to serialize a class that derives from a base class that implements ISerializable. In this case, the derived class should call the base class implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> inside its implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A>. Otherwise, the data from the base class will not be serialized.       The ISerializable interface implies a constructor with the signature constructor (<xref:System.Runtime.Serialization.SerializationInfo> information, <xref:System.Runtime.Serialization.StreamingContext> context). At deserialization time, the current constructor is called only after the data in the <xref:System.Runtime.Serialization.SerializationInfo> has been deserialized by the formatter. In general, this constructor should be protected if the class is not sealed.       The order in which objects are deserialized cannot be guaranteed. For example, if one type references a type that has not been deserialized yet, an exception will occur. If you are creating types that have such dependencies, you can work around the problem by implementing the `IDeserializationCallback` interface and the `OnDeserialization` method.       The serialization architecture handles object types that extend <xref:System.MarshalByRefObject> the same as types that extend <xref:System.Object>. These types can be marked with the <xref:System.SerializableAttribute> and implement the ISerializable interface as any other object type. Their object state will be captured and persisted onto the stream.       When these types are being used through <xref:System.Runtime.Remoting>, the remoting infrastructure provides a surrogate that preempts typical serialization and instead serializes a proxy to the <xref:System.MarshalByRefObject>. A surrogate is a helper that knows how to serialize and deserialize objects of a particular type. The proxy, invisible to the user in most cases, will be of type <xref:System.Runtime.Remoting.ObjRef>.       As a general design pattern, it would be unusual for a class to be both marked with the serializable attribute and extend <xref:System.MarshalByRefObject>. Developers should think carefully about the possible serialization and remoting scenarios when combining these two characteristics. One example where this might be applicable is with a <xref:System.IO.MemoryStream>. While the base class of <xref:System.IO.MemoryStream> (<xref:System.IO.Stream>) extends from <xref:System.MarshalByRefObject>, it is possible to capture the state of a <xref:System.IO.MemoryStream> and restore it at will. It might, therefore, be meaningful to serialize the state of this stream into a database and restore it at some later point in time. However, when used through remoting, an object of this type would be proxied.       For more information about serialization of classes that extend <xref:System.MarshalByRefObject>, see <xref:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector>. For more information about implementing ISerializable, see [Custom Serialization](~/add/includes/ajax-current-ext-md.md).","needQuote":false,"needEscape":true,"nodes":[{"content":"Any class that might be serialized must be marked with the &lt;xref:System.SerializableAttribute&gt;.","pos":[0,95],"source":"Any class that might be serialized must be marked with the <xref:System.SerializableAttribute>."},{"content":"If a class needs to control its serialization process, it can implement the ISerializable interface.","pos":[96,196]},{"content":"The &lt;xref:System.Runtime.Serialization.Formatter&gt; calls the &lt;xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A&gt; at serialization time and populates the supplied &lt;xref:System.Runtime.Serialization.SerializationInfo&gt; with all the data required to represent the object.","pos":[197,478],"source":" The <xref:System.Runtime.Serialization.Formatter> calls the <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> at serialization time and populates the supplied <xref:System.Runtime.Serialization.SerializationInfo> with all the data required to represent the object."},{"content":"The &lt;xref:System.Runtime.Serialization.Formatter&gt; creates a &lt;xref:System.Runtime.Serialization.SerializationInfo&gt; with the type of the object in the graph.","pos":[479,634],"source":" The <xref:System.Runtime.Serialization.Formatter> creates a <xref:System.Runtime.Serialization.SerializationInfo> with the type of the object in the graph."},{"content":"Objects that need to send proxies for themselves can use the &lt;xref:System.Runtime.Serialization.SerializationInfo.FullTypeName%2A&gt; and &lt;xref:System.Runtime.Serialization.SerializationInfo.AssemblyName%2A&gt; methods on &lt;xref:System.Runtime.Serialization.SerializationInfo&gt; to change the transmitted information.","pos":[635,943],"source":" Objects that need to send proxies for themselves can use the <xref:System.Runtime.Serialization.SerializationInfo.FullTypeName%2A> and <xref:System.Runtime.Serialization.SerializationInfo.AssemblyName%2A> methods on <xref:System.Runtime.Serialization.SerializationInfo> to change the transmitted information."},{"content":"In the case of class inheritance, it is possible to serialize a class that derives from a base class that implements ISerializable.","pos":[950,1081]},{"content":"In this case, the derived class should call the base class implementation of &lt;xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A&gt; inside its implementation of &lt;xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A&gt;.","pos":[1082,1322],"source":" In this case, the derived class should call the base class implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> inside its implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A>."},{"content":"Otherwise, the data from the base class will not be serialized.","pos":[1323,1386]},{"content":"The ISerializable interface implies a constructor with the signature constructor (&lt;xref:System.Runtime.Serialization.SerializationInfo&gt; information, &lt;xref:System.Runtime.Serialization.StreamingContext&gt; context).","pos":[1393,1604],"source":"       The ISerializable interface implies a constructor with the signature constructor (<xref:System.Runtime.Serialization.SerializationInfo> information, <xref:System.Runtime.Serialization.StreamingContext> context)."},{"content":"At deserialization time, the current constructor is called only after the data in the &lt;xref:System.Runtime.Serialization.SerializationInfo&gt; has been deserialized by the formatter.","pos":[1605,1784],"source":" At deserialization time, the current constructor is called only after the data in the <xref:System.Runtime.Serialization.SerializationInfo> has been deserialized by the formatter."},{"content":"In general, this constructor should be protected if the class is not sealed.","pos":[1785,1861]},{"content":"The order in which objects are deserialized cannot be guaranteed.","pos":[1868,1933]},{"content":"For example, if one type references a type that has not been deserialized yet, an exception will occur.","pos":[1934,2037]},{"content":"If you are creating types that have such dependencies, you can work around the problem by implementing the <ph id=\"ph1\">`IDeserializationCallback`</ph> interface and the <ph id=\"ph2\">`OnDeserialization`</ph> method.","pos":[2038,2217],"source":" If you are creating types that have such dependencies, you can work around the problem by implementing the `IDeserializationCallback` interface and the `OnDeserialization` method."},{"content":"The serialization architecture handles object types that extend &lt;xref:System.MarshalByRefObject&gt; the same as types that extend &lt;xref:System.Object&gt;.","pos":[2224,2372],"source":"       The serialization architecture handles object types that extend <xref:System.MarshalByRefObject> the same as types that extend <xref:System.Object>."},{"content":"These types can be marked with the &lt;xref:System.SerializableAttribute&gt; and implement the ISerializable interface as any other object type.","pos":[2373,2511],"source":" These types can be marked with the <xref:System.SerializableAttribute> and implement the ISerializable interface as any other object type."},{"content":"Their object state will be captured and persisted onto the stream.","pos":[2512,2578]},{"content":"When these types are being used through &lt;xref:System.Runtime.Remoting&gt;, the remoting infrastructure provides a surrogate that preempts typical serialization and instead serializes a proxy to the &lt;xref:System.MarshalByRefObject&gt;.","pos":[2585,2813],"source":"       When these types are being used through <xref:System.Runtime.Remoting>, the remoting infrastructure provides a surrogate that preempts typical serialization and instead serializes a proxy to the <xref:System.MarshalByRefObject>."},{"content":"A surrogate is a helper that knows how to serialize and deserialize objects of a particular type.","pos":[2814,2911]},{"content":"The proxy, invisible to the user in most cases, will be of type &lt;xref:System.Runtime.Remoting.ObjRef&gt;.","pos":[2912,3014],"source":" The proxy, invisible to the user in most cases, will be of type <xref:System.Runtime.Remoting.ObjRef>."},{"content":"As a general design pattern, it would be unusual for a class to be both marked with the serializable attribute and extend &lt;xref:System.MarshalByRefObject&gt;.","pos":[3021,3176],"source":"       As a general design pattern, it would be unusual for a class to be both marked with the serializable attribute and extend <xref:System.MarshalByRefObject>."},{"content":"Developers should think carefully about the possible serialization and remoting scenarios when combining these two characteristics.","pos":[3177,3308]},{"content":"One example where this might be applicable is with a &lt;xref:System.IO.MemoryStream&gt;.","pos":[3309,3392],"source":" One example where this might be applicable is with a <xref:System.IO.MemoryStream>."},{"content":"While the base class of &lt;xref:System.IO.MemoryStream&gt; (&lt;xref:System.IO.Stream&gt;) extends from &lt;xref:System.MarshalByRefObject&gt;, it is possible to capture the state of a &lt;xref:System.IO.MemoryStream&gt; and restore it at will.","pos":[3393,3614],"source":" While the base class of <xref:System.IO.MemoryStream> (<xref:System.IO.Stream>) extends from <xref:System.MarshalByRefObject>, it is possible to capture the state of a <xref:System.IO.MemoryStream> and restore it at will."},{"content":"It might, therefore, be meaningful to serialize the state of this stream into a database and restore it at some later point in time.","pos":[3615,3747]},{"content":"However, when used through remoting, an object of this type would be proxied.","pos":[3748,3825]},{"content":"For more information about serialization of classes that extend &lt;xref:System.MarshalByRefObject&gt;, see &lt;xref:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector&gt;.","pos":[3832,4001],"source":"       For more information about serialization of classes that extend <xref:System.MarshalByRefObject>, see <xref:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector>."},{"content":"For more information about implementing ISerializable, see <bpt id=\"p1\">[</bpt>Custom Serialization<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>.","pos":[4002,4123],"source":" For more information about implementing ISerializable, see [Custom Serialization](~/add/includes/ajax-current-ext-md.md)."}]},{"pos":[5972,6104],"content":"Populates a <bpt id=\"p1\">&lt;xref href=\"System.Runtime.Serialization.SerializationInfo\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> with the data needed to serialize the target object.","needQuote":true,"needEscape":true,"source":"Populates a <xref href=\"System.Runtime.Serialization.SerializationInfo\"></xref> with the data needed to serialize the target object."},{"pos":[6117,6784],"content":"Any objects that are included in the <xref:System.Runtime.Serialization.SerializationInfo> are automatically tracked and serialized by the formatter.       Code that calls GetObjectData requires the <xref:System.Security.Permissions.SecurityPermission> for providing serialization services. Associated enumeration: <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>.      > [!NOTE] >  It is not guaranteed that this method will be called only once per object instance during serialization. Therefore, the method should be implemented in such a way that its behavior will be the same regardless of the number of times it is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"Any objects that are included in the &lt;xref:System.Runtime.Serialization.SerializationInfo&gt; are automatically tracked and serialized by the formatter.","pos":[0,149],"source":"Any objects that are included in the <xref:System.Runtime.Serialization.SerializationInfo> are automatically tracked and serialized by the formatter."},{"content":"Code that calls GetObjectData requires the &lt;xref:System.Security.Permissions.SecurityPermission&gt; for providing serialization services.","pos":[156,290],"source":"       Code that calls GetObjectData requires the <xref:System.Security.Permissions.SecurityPermission> for providing serialization services."},{"content":"Associated enumeration: &lt;xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName&gt;.","pos":[291,398],"source":" Associated enumeration: <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  It is not guaranteed that this method will be called only once per object instance during serialization.","pos":[404,521],"source":"      > [!NOTE] >  It is not guaranteed that this method will be called only once per object instance during serialization."},{"content":"Therefore, the method should be implemented in such a way that its behavior will be the same regardless of the number of times it is called.","pos":[522,662]}]},{"pos":[7849,7943],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Runtime.Serialization.SerializationInfo\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to populate with data.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Runtime.Serialization.SerializationInfo\"></xref> to populate with data."},{"pos":[8039,8137],"content":"The destination (see <xref:System.Runtime.Serialization.StreamingContext>) for this serialization.","needQuote":true,"needEscape":true,"nodes":[{"content":"The destination (see &lt;xref:System.Runtime.Serialization.StreamingContext&gt;) for this serialization.","pos":[0,98],"source":"The destination (see <xref:System.Runtime.Serialization.StreamingContext>) for this serialization."}]},{"pos":[8334,8383],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.Serialization.ISerializable\n  id: ISerializable\n  children:\n  - System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\n  langs:\n  - csharp\n  name: ISerializable\n  nameWithType: ISerializable\n  fullName: System.Runtime.Serialization.ISerializable\n  type: Interface\n  summary: Allows an object to control its own serialization and deserialization.\n  remarks: \"Any class that might be serialized must be marked with the <xref:System.SerializableAttribute>. If a class needs to control its serialization process, it can implement the ISerializable interface. The <xref:System.Runtime.Serialization.Formatter> calls the <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> at serialization time and populates the supplied <xref:System.Runtime.Serialization.SerializationInfo> with all the data required to represent the object. The <xref:System.Runtime.Serialization.Formatter> creates a <xref:System.Runtime.Serialization.SerializationInfo> with the type of the object in the graph. Objects that need to send proxies for themselves can use the <xref:System.Runtime.Serialization.SerializationInfo.FullTypeName%2A> and <xref:System.Runtime.Serialization.SerializationInfo.AssemblyName%2A> methods on <xref:System.Runtime.Serialization.SerializationInfo> to change the transmitted information.  \\n  \\n In the case of class inheritance, it is possible to serialize a class that derives from a base class that implements ISerializable. In this case, the derived class should call the base class implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> inside its implementation of <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A>. Otherwise, the data from the base class will not be serialized.  \\n  \\n The ISerializable interface implies a constructor with the signature constructor (<xref:System.Runtime.Serialization.SerializationInfo> information, <xref:System.Runtime.Serialization.StreamingContext> context). At deserialization time, the current constructor is called only after the data in the <xref:System.Runtime.Serialization.SerializationInfo> has been deserialized by the formatter. In general, this constructor should be protected if the class is not sealed.  \\n  \\n The order in which objects are deserialized cannot be guaranteed. For example, if one type references a type that has not been deserialized yet, an exception will occur. If you are creating types that have such dependencies, you can work around the problem by implementing the `IDeserializationCallback` interface and the `OnDeserialization` method.  \\n  \\n The serialization architecture handles object types that extend <xref:System.MarshalByRefObject> the same as types that extend <xref:System.Object>. These types can be marked with the <xref:System.SerializableAttribute> and implement the ISerializable interface as any other object type. Their object state will be captured and persisted onto the stream.  \\n  \\n When these types are being used through <xref:System.Runtime.Remoting>, the remoting infrastructure provides a surrogate that preempts typical serialization and instead serializes a proxy to the <xref:System.MarshalByRefObject>. A surrogate is a helper that knows how to serialize and deserialize objects of a particular type. The proxy, invisible to the user in most cases, will be of type <xref:System.Runtime.Remoting.ObjRef>.  \\n  \\n As a general design pattern, it would be unusual for a class to be both marked with the serializable attribute and extend <xref:System.MarshalByRefObject>. Developers should think carefully about the possible serialization and remoting scenarios when combining these two characteristics. One example where this might be applicable is with a <xref:System.IO.MemoryStream>. While the base class of <xref:System.IO.MemoryStream> (<xref:System.IO.Stream>) extends from <xref:System.MarshalByRefObject>, it is possible to capture the state of a <xref:System.IO.MemoryStream> and restore it at will. It might, therefore, be meaningful to serialize the state of this stream into a database and restore it at some later point in time. However, when used through remoting, an object of this type would be proxied.  \\n  \\n For more information about serialization of classes that extend <xref:System.MarshalByRefObject>, see <xref:System.Runtime.Remoting.Messaging.RemotingSurrogateSelector>. For more information about implementing ISerializable, see [Custom Serialization](~/add/includes/ajax-current-ext-md.md).\"\n  example:\n  - \"The following code example demonstrates the use of the ISerializable interface to define custom serialization behavior for a class.  \\n  \\n [!code-cpp[ISerializable Interface Example#1](~/add/codesnippet/cpp/t-system.runtime.seriali_4_1.cpp)]\\n [!code-cs[ISerializable Interface Example#1](~/add/codesnippet/csharp/t-system.runtime.seriali_4_1.cs)]\\n [!code-vb[ISerializable Interface Example#1](~/add/codesnippet/visualbasic/t-system.runtime.seriali_4_1.vb)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public interface ISerializable\n  implements: []\n  platform:\n  - net462\n- uid: System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\n  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\n  parent: System.Runtime.Serialization.ISerializable\n  langs:\n  - csharp\n  name: GetObjectData(SerializationInfo,StreamingContext)\n  nameWithType: ISerializable.GetObjectData(SerializationInfo,StreamingContext)\n  fullName: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.Serialization\n  summary: Populates a <xref href=\"System.Runtime.Serialization.SerializationInfo\"></xref> with the data needed to serialize the target object.\n  remarks: \"Any objects that are included in the <xref:System.Runtime.Serialization.SerializationInfo> are automatically tracked and serialized by the formatter.  \\n  \\n Code that calls GetObjectData requires the <xref:System.Security.Permissions.SecurityPermission> for providing serialization services. Associated enumeration: <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  It is not guaranteed that this method will be called only once per object instance during serialization. Therefore, the method should be implemented in such a way that its behavior will be the same regardless of the number of times it is called.\"\n  example:\n  - \"The following example uses the GetObjectData method to set alternate values for a serialized object. The code uses the <xref:System.Runtime.Serialization.SerializationInfo.AddValue%2A> method of the <xref:System.Runtime.Serialization.SerializationInfo> class to store the alternate values when the object is serialized. Conversely, when the constructor of the `Person` class is called during deserialization, the alternatve values are retrieved using the <xref:System.Runtime.Serialization.SerializationInfo.GetValue%2A> method and reassigned to the object's fields.  \\n  \\n [!code-cs[ISerializable_GetObjectData#0](~/add/codesnippet/csharp/8416df17-ca26-45ef-baab-_1.cs)]\\n [!code-vb[ISerializable_GetObjectData#0](~/add/codesnippet/visualbasic/8416df17-ca26-45ef-baab-_1.vb)]\"\n  syntax:\n    content: public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);\n    parameters:\n    - id: info\n      type: System.Runtime.Serialization.SerializationInfo\n      description: The <xref href=\"System.Runtime.Serialization.SerializationInfo\"></xref> to populate with data.\n    - id: context\n      type: System.Runtime.Serialization.StreamingContext\n      description: The destination (see <xref:System.Runtime.Serialization.StreamingContext>) for this serialization.\n  overload: System.Runtime.Serialization.ISerializable.GetObjectData*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\nreferences:\n- uid: System.Security.SecurityException\n  isExternal: true\n  name: System.Security.SecurityException\n- uid: System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\n  parent: System.Runtime.Serialization.ISerializable\n  isExternal: false\n  name: GetObjectData(SerializationInfo,StreamingContext)\n  nameWithType: ISerializable.GetObjectData(SerializationInfo,StreamingContext)\n  fullName: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)\n- uid: System.Runtime.Serialization.SerializationInfo\n  parent: System.Runtime.Serialization\n  isExternal: false\n  name: SerializationInfo\n  nameWithType: SerializationInfo\n  fullName: System.Runtime.Serialization.SerializationInfo\n- uid: System.Runtime.Serialization.StreamingContext\n  parent: System.Runtime.Serialization\n  isExternal: true\n  name: StreamingContext\n  nameWithType: StreamingContext\n  fullName: System.Runtime.Serialization.StreamingContext\n- uid: System.Runtime.Serialization.ISerializable.GetObjectData*\n  parent: System.Runtime.Serialization.ISerializable\n  isExternal: false\n  name: GetObjectData\n  nameWithType: ISerializable.GetObjectData\n"}