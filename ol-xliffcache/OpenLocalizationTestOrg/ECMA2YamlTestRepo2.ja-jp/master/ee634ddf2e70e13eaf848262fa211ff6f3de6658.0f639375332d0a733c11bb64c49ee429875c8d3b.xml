{"nodes":[{"pos":[412,566],"content":"Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.","needQuote":true,"needEscape":true,"nodes":[{"content":"Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.","pos":[0,154]}]},{"pos":[579,3231],"content":"The exception class defined for the component in the COM+ catalog implements both IPlaybackControl and the interface for the original class. The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself. They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.       The Queued Components Player calls the methods of IPlaybackControl to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue. The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call. The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem. If the application does not implement IPlaybackControl, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.       A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system. The transaction is rolled back, and the poison message goes to the top of the queue. When the message is dequeued again, the same condition occurs. This message can continue looping indefinitely until something is done to correct the problem. The Queued Components service handles the poison message by using a series of retries. After several unsuccessful retries, the message is moved to a final resting queue. Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.       The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.       If you discover a poison message, you might be able to solve the underlying cause of the problem quickly. For example, if the server was offline for some reason, you can bring the server back online. If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur. The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.","needQuote":false,"needEscape":true,"nodes":[{"content":"The exception class defined for the component in the COM+ catalog implements both IPlaybackControl and the interface for the original class. The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself. They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.       The Queued Components Player calls the methods of IPlaybackControl to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue. The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call. The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem. If the application does not implement IPlaybackControl, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.       A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system. The transaction is rolled back, and the poison message goes to the top of the queue. When the message is dequeued again, the same condition occurs. This message can continue looping indefinitely until something is done to correct the problem. The Queued Components service handles the poison message by using a series of retries. After several unsuccessful retries, the message is moved to a final resting queue. Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.       The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.       If you discover a poison message, you might be able to solve the underlying cause of the problem quickly. For example, if the server was offline for some reason, you can bring the server back online. If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur. The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.","pos":[0,2644],"nodes":[{"content":"The exception class defined for the component in the COM+ catalog implements both IPlaybackControl and the interface for the original class.","pos":[0,140]},{"content":"The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.","pos":[141,286]},{"content":"They will be called after &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt; or &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt; to process exceptions for the method originally called.","pos":[287,511],"source":" They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called."},{"content":"The Queued Components Player calls the methods of IPlaybackControl to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.","pos":[518,703]},{"content":"The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.","pos":[704,836]},{"content":"The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.","pos":[837,1026]},{"content":"If the application does not implement IPlaybackControl, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.","pos":[1027,1209]},{"content":"A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.","pos":[1216,1351]},{"content":"The transaction is rolled back, and the poison message goes to the top of the queue.","pos":[1352,1436]},{"content":"When the message is dequeued again, the same condition occurs.","pos":[1437,1499]},{"content":"This message can continue looping indefinitely until something is done to correct the problem.","pos":[1500,1594]},{"content":"The Queued Components service handles the poison message by using a series of retries.","pos":[1595,1681]},{"content":"After several unsuccessful retries, the message is moved to a final resting queue.","pos":[1682,1764]},{"content":"Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.","pos":[1765,1880]},{"content":"The poison message situation can also be resolved programmatically, using the &lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt; method, which informs the server-side component author that all attempts to play back the deferred activation have failed.","pos":[1887,2157],"source":"       The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed."},{"content":"If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.","pos":[2164,2269]},{"content":"For example, if the server was offline for some reason, you can bring the server back online.","pos":[2270,2363]},{"content":"If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.","pos":[2364,2519]},{"content":"The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.","pos":[2520,2644]}]}]},{"pos":[3972,4178],"content":"Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.","needQuote":true,"needEscape":true,"nodes":[{"content":"Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.","pos":[0,206]}]},{"pos":[4191,4914],"content":"As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification. It does so by first calling FinalClientRetry, then calling the exception-handling version of the failed method in the exception-handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). If the exception method is not successful, the message is left on the Xact Dead Letter queue.       The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.","needQuote":false,"needEscape":true,"nodes":[{"content":"As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification. It does so by first calling FinalClientRetry, then calling the exception-handling version of the failed method in the exception-handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). If the exception method is not successful, the message is left on the Xact Dead Letter queue.       The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.","pos":[0,721],"nodes":[{"content":"As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.","pos":[0,163]},{"content":"It does so by first calling FinalClientRetry, then calling the exception-handling version of the failed method in the exception-handler object.","pos":[164,307]},{"content":"This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).","pos":[308,532]},{"content":"If the exception method is not successful, the message is left on the Xact Dead Letter queue.","pos":[533,626]},{"content":"The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.","pos":[633,721]}]}]},{"pos":[5529,5730],"content":"Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.","needQuote":true,"needEscape":true,"nodes":[{"content":"Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.","pos":[0,201]}]},{"pos":[5742,6521],"content":"As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification. It does so by first calling FinalServerRetry, then calling the exception handling version of the failed method in the exception handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). The server object should make every effort to complete this transaction successfully. Otherwise, manual intervention is required to reprocess the message. If the exception method is not successful, the message is moved to the final resting queue.","needQuote":true,"needEscape":true,"nodes":[{"content":"As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification. It does so by first calling FinalServerRetry, then calling the exception handling version of the failed method in the exception handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). The server object should make every effort to complete this transaction successfully. Otherwise, manual intervention is required to reprocess the message. If the exception method is not successful, the message is moved to the final resting queue.","pos":[0,779],"nodes":[{"content":"As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.","pos":[0,163]},{"content":"It does so by first calling FinalServerRetry, then calling the exception handling version of the failed method in the exception handler object.","pos":[164,307]},{"content":"This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).","pos":[308,532]},{"content":"The server object should make every effort to complete this transaction successfully.","pos":[533,618]},{"content":"Otherwise, manual intervention is required to reprocess the message.","pos":[619,687]},{"content":"If the exception method is not successful, the message is moved to the final resting queue.","pos":[688,779]}]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.EnterpriseServices.IPlaybackControl\n  id: IPlaybackControl\n  children:\n  - System.EnterpriseServices.IPlaybackControl.FinalClientRetry\n  - System.EnterpriseServices.IPlaybackControl.FinalServerRetry\n  langs:\n  - csharp\n  name: IPlaybackControl\n  nameWithType: IPlaybackControl\n  fullName: System.EnterpriseServices.IPlaybackControl\n  type: Interface\n  summary: Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.\n  remarks: \"The exception class defined for the component in the COM+ catalog implements both IPlaybackControl and the interface for the original class. The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself. They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.  \\n  \\n The Queued Components Player calls the methods of IPlaybackControl to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue. The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call. The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem. If the application does not implement IPlaybackControl, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.  \\n  \\n A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system. The transaction is rolled back, and the poison message goes to the top of the queue. When the message is dequeued again, the same condition occurs. This message can continue looping indefinitely until something is done to correct the problem. The Queued Components service handles the poison message by using a series of retries. After several unsuccessful retries, the message is moved to a final resting queue. Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.  \\n  \\n The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.  \\n  \\n If you discover a poison message, you might be able to solve the underlying cause of the problem quickly. For example, if the server was offline for some reason, you can bring the server back online. If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur. The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.Guid(\"51372AFD-CAE7-11CF-BE81-00AA00A2FA25\")]\n\n      [System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]\n\n      public interface IPlaybackControl\n  implements: []\n  platform:\n  - net462\n- uid: System.EnterpriseServices.IPlaybackControl.FinalClientRetry\n  id: FinalClientRetry\n  parent: System.EnterpriseServices.IPlaybackControl\n  langs:\n  - csharp\n  name: FinalClientRetry()\n  nameWithType: IPlaybackControl.FinalClientRetry()\n  fullName: System.EnterpriseServices.IPlaybackControl.FinalClientRetry()\n  type: Method\n  assemblies:\n  - System.EnterpriseServices\n  namespace: System.EnterpriseServices\n  summary: Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.\n  remarks: \"As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification. It does so by first calling FinalClientRetry, then calling the exception-handling version of the failed method in the exception-handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). If the exception method is not successful, the message is left on the Xact Dead Letter queue.  \\n  \\n The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.\"\n  syntax:\n    content: public void FinalClientRetry ();\n    parameters: []\n  overload: System.EnterpriseServices.IPlaybackControl.FinalClientRetry*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.EnterpriseServices.IPlaybackControl.FinalServerRetry\n  id: FinalServerRetry\n  parent: System.EnterpriseServices.IPlaybackControl\n  langs:\n  - csharp\n  name: FinalServerRetry()\n  nameWithType: IPlaybackControl.FinalServerRetry()\n  fullName: System.EnterpriseServices.IPlaybackControl.FinalServerRetry()\n  type: Method\n  assemblies:\n  - System.EnterpriseServices\n  namespace: System.EnterpriseServices\n  summary: Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.\n  remarks: As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification. It does so by first calling FinalServerRetry, then calling the exception handling version of the failed method in the exception handler object. This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction). The server object should make every effort to complete this transaction successfully. Otherwise, manual intervention is required to reprocess the message. If the exception method is not successful, the message is moved to the final resting queue.\n  syntax:\n    content: public void FinalServerRetry ();\n    parameters: []\n  overload: System.EnterpriseServices.IPlaybackControl.FinalServerRetry*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.EnterpriseServices.IPlaybackControl.FinalClientRetry\n  parent: System.EnterpriseServices.IPlaybackControl\n  isExternal: false\n  name: FinalClientRetry()\n  nameWithType: IPlaybackControl.FinalClientRetry()\n  fullName: System.EnterpriseServices.IPlaybackControl.FinalClientRetry()\n- uid: System.EnterpriseServices.IPlaybackControl.FinalServerRetry\n  parent: System.EnterpriseServices.IPlaybackControl\n  isExternal: false\n  name: FinalServerRetry()\n  nameWithType: IPlaybackControl.FinalServerRetry()\n  fullName: System.EnterpriseServices.IPlaybackControl.FinalServerRetry()\n- uid: System.EnterpriseServices.IPlaybackControl.FinalClientRetry*\n  parent: System.EnterpriseServices.IPlaybackControl\n  isExternal: false\n  name: FinalClientRetry\n  nameWithType: IPlaybackControl.FinalClientRetry\n- uid: System.EnterpriseServices.IPlaybackControl.FinalServerRetry*\n  parent: System.EnterpriseServices.IPlaybackControl\n  isExternal: false\n  name: FinalServerRetry\n  nameWithType: IPlaybackControl.FinalServerRetry\n"}