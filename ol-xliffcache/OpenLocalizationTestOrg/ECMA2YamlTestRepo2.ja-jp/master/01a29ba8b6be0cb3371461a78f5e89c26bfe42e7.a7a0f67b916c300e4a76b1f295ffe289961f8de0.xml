{"nodes":[{"pos":[841,967],"content":"Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.","needQuote":true,"needEscape":true,"nodes":[{"content":"Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.","pos":[0,126]}]},{"pos":[980,4411],"content":"The XmlMessageFormatter is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue. When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of XmlMessageFormatter is created for you and associated with the <xref:System.Messaging.MessageQueue>. You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>.       A queue's default XmlMessageFormatter instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter. You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.       When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.       The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.       The XmlMessageFormatter is a crucial component of loosely coupled XML-based messaging. The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application. The class must have a default constructor.       The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data. The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed. As long as the schema does not change on the client or the server, other changes on either side do not affect the other.","needQuote":false,"needEscape":true,"nodes":[{"content":"The XmlMessageFormatter is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue. When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of XmlMessageFormatter is created for you and associated with the <xref:System.Messaging.MessageQueue>. You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>.       A queue's default XmlMessageFormatter instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter. You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.       When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.       The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.       The XmlMessageFormatter is a crucial component of loosely coupled XML-based messaging. The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application. The class must have a default constructor.       The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data. The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed. As long as the schema does not change on the client or the server, other changes on either side do not affect the other.","pos":[0,3417],"nodes":[{"content":"The XmlMessageFormatter is the default formatter that an instance of &lt;xref:System.Messaging.MessageQueue&gt; uses to serialize messages written to the queue.","pos":[0,154],"source":"The XmlMessageFormatter is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue."},{"content":"When you create an instance of &lt;xref:System.Messaging.MessageQueue&gt;, an instance of XmlMessageFormatter is created for you and associated with the &lt;xref:System.Messaging.MessageQueue&gt;.","pos":[155,339],"source":" When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of XmlMessageFormatter is created for you and associated with the <xref:System.Messaging.MessageQueue>."},{"content":"You can specify a different formatter by creating it in your code and assigning it to the &lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt; property of your &lt;xref:System.Messaging.MessageQueue&gt;.","pos":[340,534],"source":" You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>."},{"content":"A queue's default XmlMessageFormatter instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; or &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; property on the formatter.","pos":[541,844],"source":"       A queue's default XmlMessageFormatter instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter."},{"content":"You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate &lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt; constructor.","pos":[845,1127],"source":" You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor."},{"content":"When specifying &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; rather than &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;, type existence is checked at compile time rather than read time, reducing possibility for error.","pos":[1134,1381],"source":"       When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error."},{"content":"&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; requires every entry to be fully qualified, specifying its assembly name.","pos":[1382,1518],"source":" <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name."},{"content":"Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.","pos":[1519,1649]},{"content":"The &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[1656,1878],"source":"       The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"This allows the formatter to interpret the message body.","pos":[1879,1935]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[1942,2052]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[2053,2263],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"Only one of the two properties needs to be set when reading from the queue, but you can set both.","pos":[2270,2367]},{"content":"The set of types is the combined set from the two properties.","pos":[2368,2429]},{"content":"The decision of which property to use is specific to your application.","pos":[2430,2500]},{"content":"If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.","pos":[2501,2669]},{"content":"The XmlMessageFormatter is a crucial component of loosely coupled XML-based messaging.","pos":[2676,2762]},{"content":"The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application.","pos":[2763,2914]},{"content":"The class must have a default constructor.","pos":[2915,2957]},{"content":"The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data.","pos":[2964,3110]},{"content":"The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed.","pos":[3111,3296]},{"content":"As long as the schema does not change on the client or the server, other changes on either side do not affect the other.","pos":[3297,3417]}]}]},{"pos":[8756,8880],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class, without target types set.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, without target types set."},{"pos":[8893,9688],"content":"This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.       To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize.       When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set. As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.","needQuote":false,"needEscape":true,"nodes":[{"content":"This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.       To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize.       When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set. As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.","pos":[0,791],"nodes":[{"content":"This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.","pos":[0,130]},{"content":"To read a message from a queue using an instance of &lt;xref:System.Messaging.XmlMessageFormatter&gt; created using this constructor, you must set the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; or &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties so the formatter knows what types to attempt to deserialize.","pos":[137,478],"source":"       To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize."},{"content":"When you create a new &lt;xref:System.Messaging.MessageQueue&gt;, a default &lt;xref:System.Messaging.XmlMessageFormatter&gt; instance is created, without the target types set.","pos":[485,649],"source":"       When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set."},{"content":"As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.","pos":[650,791]}]}]},{"pos":[10303,10480],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class, setting target types passed in as an array of (fully qualified) string values.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, setting target types passed in as an array of (fully qualified) string values."},{"pos":[10493,12097],"content":"The constructors with target type parameters are most frequently used when reading from the queue. When writing, it is not necessary to specify target types.       This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property to the array values passed in through the `targetTypeNames` parameter. Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of given types.       Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which one to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.","needQuote":false,"needEscape":true,"nodes":[{"content":"The constructors with target type parameters are most frequently used when reading from the queue.","pos":[0,98]},{"content":"When writing, it is not necessary to specify target types.","pos":[99,157]},{"content":"This overload of the &lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt; constructor sets the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; property to the array values passed in through the <ph id=\"ph1\">`targetTypeNames`</ph> parameter.","pos":[164,403],"source":"       This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property to the array values passed in through the `targetTypeNames` parameter."},{"content":"Setting this property enables a &lt;xref:System.Messaging.MessageQueue&gt; using this &lt;xref:System.Messaging.XmlMessageFormatter&gt; instance to read messages containing objects of given types.","pos":[404,588],"source":" Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of given types."},{"content":"Both the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[595,822],"source":"       Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"This allows the formatter to interpret the message body.","pos":[823,879]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[886,996]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[997,1207],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"Only one of the two properties needs to be set when reading from the queue, but you can set both.","pos":[1214,1311]},{"content":"The set of types is the combined set from the two properties.","pos":[1312,1373]},{"content":"The decision of which one to use is specific to your application.","pos":[1374,1439]},{"content":"If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.","pos":[1440,1596]}]},{"pos":[12551,12796],"content":"An array of type <xref:System.String> that specifies the set of possible types that will be deserialized by the formatter from the message provided. These values must be fully qualified, for example, \"MyNamespace.MyOrders, MyOrdersAssemblyName\".","needQuote":true,"needEscape":true,"nodes":[{"content":"An array of type <xref:System.String> that specifies the set of possible types that will be deserialized by the formatter from the message provided. These values must be fully qualified, for example, \"MyNamespace.MyOrders, MyOrdersAssemblyName\".","pos":[0,245],"nodes":[{"content":"An array of type &lt;xref:System.String&gt; that specifies the set of possible types that will be deserialized by the formatter from the message provided.","pos":[0,148],"source":"An array of type <xref:System.String> that specifies the set of possible types that will be deserialized by the formatter from the message provided."},{"content":"These values must be fully qualified, for example, \"MyNamespace.MyOrders, MyOrdersAssemblyName\".","pos":[149,245]}]}]},{"pos":[12969,13076],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">targetTypeNames</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <code>targetTypeNames</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[13534,13692],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class, setting target types passed in as an array of object types.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, setting target types passed in as an array of object types."},{"pos":[13705,16080],"content":"The constructors with target type parameters are most frequently used when reading from the queue. When writing, it is not necessary to specify target types.       This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property to the array values passed in through the `targetTypes` parameter. Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of the given types.       Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which one to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.       When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.       When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the following C# code.      ```   TargetTypes = new Type[]{typeof(MyClass)}   ```","needQuote":false,"needEscape":true,"nodes":[{"content":"The constructors with target type parameters are most frequently used when reading from the queue.","pos":[0,98]},{"content":"When writing, it is not necessary to specify target types.","pos":[99,157]},{"content":"This overload of the &lt;xref:System.Messaging.XmlMessageFormatter.%23ctor%2A&gt; constructor sets the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; property to the array values passed in through the <ph id=\"ph1\">`targetTypes`</ph> parameter.","pos":[164,395],"source":"       This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property to the array values passed in through the `targetTypes` parameter."},{"content":"Setting this property enables a &lt;xref:System.Messaging.MessageQueue&gt; using this &lt;xref:System.Messaging.XmlMessageFormatter&gt; instance to read messages containing objects of the given types.","pos":[396,584],"source":" Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of the given types."},{"content":"Both the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[591,818],"source":"       Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"This allows the formatter to interpret the message body.","pos":[819,875]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[882,992]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[993,1203],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"Only one of the two properties needs to be set when reading from the queue, but you can set both.","pos":[1210,1307]},{"content":"The set of types is the combined set from the two properties.","pos":[1308,1369]},{"content":"The decision of which one to use is specific to your application.","pos":[1370,1435]},{"content":"If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.","pos":[1436,1592]},{"content":"When specifying &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; rather than &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;, type existence is checked at compile time rather than read time, reducing possibility for error.","pos":[1599,1846],"source":"       When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error."},{"content":"&lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; requires every entry to be fully qualified, specifying its assembly name.","pos":[1847,1983],"source":" <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name."},{"content":"Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.","pos":[1984,2114]},{"content":"When using &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt;, you can add each object (for example, <ph id=\"ph1\">`MyClass`</ph>) to the list in a way demonstrated by the following C# code.","pos":[2121,2300],"source":"       When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the following C# code."}]},{"pos":[16237,16383],"content":"An array of type <xref:System.Type> that specifies the set of possible types that will be deserialized by the formatter from the message provided.","needQuote":true,"needEscape":true,"nodes":[{"content":"An array of type &lt;xref:System.Type&gt; that specifies the set of possible types that will be deserialized by the formatter from the message provided.","pos":[0,146],"source":"An array of type <xref:System.Type> that specifies the set of possible types that will be deserialized by the formatter from the message provided."}]},{"pos":[16556,16659],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">targetTypes</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <code>targetTypes</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[17103,17164],"content":"Determines whether the formatter can deserialize the message.","needQuote":true,"needEscape":true,"nodes":[{"content":"Determines whether the formatter can deserialize the message.","pos":[0,61]}]},{"pos":[17177,18284],"content":"When CanRead is called, the formatter attempts to determine if the contents of the message are something it can deserialize. The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties. CanRead returns `false` under the following two circumstances:      -   The message was not formatted using the <xref:System.Messaging.XmlMessageFormatter>.      -   The schema of the message body is not among those listed in either the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property.       The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what types of objects it must be able to deserialize. If any type is missing from the list, yet is found within the message, CanRead returns `false`.","needQuote":false,"needEscape":true,"nodes":[{"content":"When CanRead is called, the formatter attempts to determine if the contents of the message are something it can deserialize.","pos":[0,124]},{"content":"The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties.","pos":[125,413],"source":" The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties."},{"content":"CanRead returns <ph id=\"ph1\">`false`</ph> under the following two circumstances:      -   The message was not formatted using the &lt;xref:System.Messaging.XmlMessageFormatter&gt;.","pos":[414,570],"source":" CanRead returns `false` under the following two circumstances:      -   The message was not formatted using the <xref:System.Messaging.XmlMessageFormatter>."},{"content":"-   The schema of the message body is not among those listed in either the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; or &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; property.","pos":[576,785],"source":"      -   The schema of the message body is not among those listed in either the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property."},{"content":"The &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what types of objects it must be able to deserialize.","pos":[792,1005],"source":"       The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what types of objects it must be able to deserialize."},{"content":"If any type is missing from the list, yet is found within the message, CanRead returns <ph id=\"ph1\">`false`</ph>.","pos":[1006,1101],"source":" If any type is missing from the list, yet is found within the message, CanRead returns `false`."}]},{"pos":[18455,18516],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Messaging.Message\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to inspect.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Messaging.Message\"></xref> to inspect."},{"pos":[18575,18760],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the XML formatter can deserialize the message; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the XML formatter can deserialize the message; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[18943,19099],"content":"Neither the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames<bpt id=\"p1\">*</bpt>&gt; nor &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes<ept id=\"p1\">*</ept>&gt; property has been set.","needQuote":true,"needEscape":true,"source":"Neither the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> nor <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> property has been set."},{"pos":[19202,19301],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">message</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[19662,19903],"content":"Creates an instance of the <bpt id=\"p1\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class whose read/write properties (the sets of target types) are the same as the current <bpt id=\"p2\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> instance.","needQuote":true,"needEscape":true,"source":"Creates an instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class whose read/write properties (the sets of target types) are the same as the current <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> instance."},{"pos":[19915,20067],"content":"This method creates a copy of the formatter and initializes all its properties to the values of this <xref:System.Messaging.XmlMessageFormatter> object.","needQuote":true,"needEscape":true,"nodes":[{"content":"This method creates a copy of the formatter and initializes all its properties to the values of this &lt;xref:System.Messaging.XmlMessageFormatter&gt; object.","pos":[0,152],"source":"This method creates a copy of the formatter and initializes all its properties to the values of this <xref:System.Messaging.XmlMessageFormatter> object."}]},{"pos":[20191,20389],"content":"An object whose properties are identical to those of this <bpt id=\"p1\">&lt;xref href=\"System.Messaging.XmlMessageFormatter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> instance, but whose metadata does not specify it to be a formatter class instance.","needQuote":true,"needEscape":true,"source":"An object whose properties are identical to those of this <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> instance, but whose metadata does not specify it to be a formatter class instance."},{"pos":[20891,20994],"content":"Reads the contents from the given message and creates an object that contains the deserialized message.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the contents from the given message and creates an object that contains the deserialized message.","pos":[0,103]}]},{"pos":[21007,21725],"content":"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. One of these properties must be set before the message can be deserialized.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       The target types do not have to be specified in order to write to the queue.","needQuote":false,"needEscape":true,"nodes":[{"content":"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. One of these properties must be set before the message can be deserialized.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       The target types do not have to be specified in order to write to the queue.","pos":[0,714],"nodes":[{"content":"Both the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[0,227],"source":"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"One of these properties must be set before the message can be deserialized.","pos":[228,303]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[310,420]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[421,631],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"The target types do not have to be specified in order to write to the queue.","pos":[638,714]}]}]},{"pos":[21895,21976],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Messaging.Message\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, in XML format, to deserialize.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Messaging.Message\"></xref>, in XML format, to deserialize."},{"pos":[22034,22059],"content":"The deserialized message.","needQuote":true,"needEscape":true,"nodes":[{"content":"The deserialized message.","pos":[0,25]}]},{"pos":[22240,22667],"content":"Neither the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> nor <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> property has been set.       -or-       The instance serialized in the message body does not comply with any of the schemas represented by the types in the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> properties.","needQuote":false,"needEscape":true,"nodes":[{"content":"Neither the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames<bpt id=\"p1\">*</bpt>&gt; nor &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes<ept id=\"p1\">*</ept>&gt; property has been set.","pos":[0,156],"source":"Neither the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> nor <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> property has been set."},{"content":"-or-       The instance serialized in the message body does not comply with any of the schemas represented by the types in the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames<bpt id=\"p1\">*</bpt>&gt; and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes<ept id=\"p1\">*</ept>&gt; properties.","pos":[163,423],"source":"       -or-       The instance serialized in the message body does not comply with any of the schemas represented by the types in the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> properties."}]},{"pos":[22771,22870],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">message</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[23277,23382],"content":"Specifies the set of possible types that will be deserialized by the formatter from the message provided.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies the set of possible types that will be deserialized by the formatter from the message provided.","pos":[0,105]}]},{"pos":[23395,24810],"content":"Both the TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.       TargetTypeNames requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.       The target types are only required when reading from the queue. The TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.","needQuote":false,"needEscape":true,"nodes":[{"content":"Both the TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.       TargetTypeNames requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.       The target types are only required when reading from the queue. The TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.","pos":[0,1407],"nodes":[{"content":"Both the TargetTypeNames and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[0,180],"source":"Both the TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"This allows the formatter to interpret the message body.","pos":[181,237]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[244,354]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[355,565],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"Only one of the two properties needs to be set when reading from the queue, but you can set both.","pos":[572,669]},{"content":"The set of types is the combined set from the two properties.","pos":[670,731]},{"content":"The decision of which property to use is specific to your application.","pos":[732,802]},{"content":"If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.","pos":[803,971]},{"content":"TargetTypeNames requires every entry to be fully qualified, specifying its assembly name.","pos":[978,1067]},{"content":"Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.","pos":[1068,1198]},{"content":"The target types are only required when reading from the queue.","pos":[1205,1268]},{"content":"The TargetTypeNames and &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; properties do not need to be set to write to the queue.","pos":[1269,1407],"source":" The TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue."}]}]},{"pos":[24940,25076],"content":"An array of type <xref:System.String> that specifies the types of objects to deserialize from the message body when reading the message.","needQuote":true,"needEscape":true,"nodes":[{"content":"An array of type &lt;xref:System.String&gt; that specifies the types of objects to deserialize from the message body when reading the message.","pos":[0,136],"source":"An array of type <xref:System.String> that specifies the types of objects to deserialize from the message body when reading the message."}]},{"pos":[25259,25352],"content":"The TargetTypeNames property is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The TargetTypeNames property is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[25739,25844],"content":"Specifies the set of possible types that will be deserialized by the formatter from the message provided.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies the set of possible types that will be deserialized by the formatter from the message provided.","pos":[0,105]}]},{"pos":[25857,27451],"content":"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.       The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.       Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.       The target types are only required when reading from the queue. The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties do not need to be set to write to the queue.       When specifying TargetTypes rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.       When using TargetTypes, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the C# code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.","needQuote":false,"needEscape":true,"nodes":[{"content":"Both the &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and TargetTypes properties tell the formatter what schemas to attempt to match when deserializing a message.","pos":[0,180],"source":"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties tell the formatter what schemas to attempt to match when deserializing a message."},{"content":"This allows the formatter to interpret the message body.","pos":[181,237]},{"content":"The instance serialized in the message body must comply with one of the schemas represented in the type array.","pos":[244,354]},{"content":"When you read the message using the &lt;xref:System.Messaging.MessageQueue.Receive%2A&gt; method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.","pos":[355,565],"source":" When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it."},{"content":"Only one of the two properties needs to be set when reading from the queue, but you can set both.","pos":[572,669]},{"content":"The set of types is the combined set from the two properties.","pos":[670,731]},{"content":"The decision of which property to use is specific to your application.","pos":[732,802]},{"content":"If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.","pos":[803,971]},{"content":"The target types are only required when reading from the queue.","pos":[978,1041]},{"content":"The &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; and TargetTypes properties do not need to be set to write to the queue.","pos":[1042,1180],"source":" The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties do not need to be set to write to the queue."},{"content":"When specifying TargetTypes rather than &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt;, type existence is checked at compile time rather than read time, reducing possibility for error.","pos":[1187,1387],"source":"       When specifying TargetTypes rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error."},{"content":"When using TargetTypes, you can add each object (for example, <ph id=\"ph1\">`MyClass`</ph>) to the list in a way demonstrated by the C# code <ph id=\"ph2\">`TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`</ph>.","pos":[1394,1584],"source":"       When using TargetTypes, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the C# code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`."}]},{"pos":[27955,28089],"content":"An array of type <xref:System.Type> that specifies the types of objects to deserialize from the message body when reading the message.","needQuote":true,"needEscape":true,"nodes":[{"content":"An array of type &lt;xref:System.Type&gt; that specifies the types of objects to deserialize from the message body when reading the message.","pos":[0,134],"source":"An array of type <xref:System.Type> that specifies the types of objects to deserialize from the message body when reading the message."}]},{"pos":[28268,28357],"content":"The TargetTypes property is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The TargetTypes property is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[28840,28890],"content":"Serializes an object into the body of the message.","needQuote":true,"needEscape":true,"nodes":[{"content":"Serializes an object into the body of the message.","pos":[0,50]}]},{"pos":[28903,29567],"content":"The target types need not be specified to write to the queue as they must be when reading. The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message.       The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized. Only public fields and public properties can be serialized. Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.","needQuote":false,"needEscape":true,"nodes":[{"content":"The target types need not be specified to write to the queue as they must be when reading. The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message.       The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized. Only public fields and public properties can be serialized. Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.","pos":[0,662],"nodes":[{"content":"The target types need not be specified to write to the queue as they must be when reading.","pos":[0,90]},{"content":"The &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A&gt; or &lt;xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A&gt; property is used by the formatter only when deserializing a message.","pos":[91,288],"source":" The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message."},{"content":"The &lt;xref:System.Messaging.XmlMessageFormatter&gt; makes use of the &lt;xref:System.Xml.Serialization.XmlSerializer&gt; class, which defines what can be serialized.","pos":[295,450],"source":"       The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized."},{"content":"Only public fields and public properties can be serialized.","pos":[451,510]},{"content":"Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.","pos":[511,662]}]}]},{"pos":[29748,29886],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Messaging.Message\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> whose &lt;xref:System.Messaging.Message.Body*&gt; property will contain the serialized object.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Messaging.Message\"></xref> whose <xref:System.Messaging.Message.Body*> property will contain the serialized object."},{"pos":[29946,30010],"content":"The <xref:System.Object> to be serialized into the message body.","needQuote":true,"needEscape":true,"nodes":[{"content":"The &lt;xref:System.Object&gt; to be serialized into the message body.","pos":[0,64],"source":"The <xref:System.Object> to be serialized into the message body."}]},{"pos":[30184,30412],"content":"The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.       -or-       The <code>obj</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.","needQuote":false,"needEscape":true,"nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">message</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[0,99],"source":"The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"content":"-or-       The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[106,212],"source":"       -or-       The <code>obj</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Messaging.XmlMessageFormatter\n  id: XmlMessageFormatter\n  children:\n  - System.Messaging.XmlMessageFormatter.#ctor\n  - System.Messaging.XmlMessageFormatter.#ctor(System.String[])\n  - System.Messaging.XmlMessageFormatter.#ctor(System.Type[])\n  - System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)\n  - System.Messaging.XmlMessageFormatter.Clone\n  - System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)\n  - System.Messaging.XmlMessageFormatter.TargetTypeNames\n  - System.Messaging.XmlMessageFormatter.TargetTypes\n  - System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)\n  langs:\n  - csharp\n  name: XmlMessageFormatter\n  nameWithType: XmlMessageFormatter\n  fullName: System.Messaging.XmlMessageFormatter\n  type: Class\n  summary: Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.\n  remarks: \"The XmlMessageFormatter is the default formatter that an instance of <xref:System.Messaging.MessageQueue> uses to serialize messages written to the queue. When you create an instance of <xref:System.Messaging.MessageQueue>, an instance of XmlMessageFormatter is created for you and associated with the <xref:System.Messaging.MessageQueue>. You can specify a different formatter by creating it in your code and assigning it to the <xref:System.Messaging.MessageQueue.Formatter%2A> property of your <xref:System.Messaging.MessageQueue>.  \\n  \\n A queue's default XmlMessageFormatter instance can be used to write to the queue, but it cannot be used to read from the queue until you set either the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property on the formatter. You can either set one or both of these values on the default formatter instance, or you can create a new instance of the formatter and set the values automatically by passing them as arguments into the appropriate <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor.  \\n  \\n When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.  \\n  \\n The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.  \\n  \\n The XmlMessageFormatter is a crucial component of loosely coupled XML-based messaging. The XSD.exe utility uses the XML format is used to generate XML schema, such as when you use the utility to serialize a class used by your application. The class must have a default constructor.  \\n  \\n The format is used again in the reverse process when the utility generates a class based on the schema you distribute to describe your class data. The use of the utility and the XML schema it generates enables you to avoid redistributing.dll files every time you recompile a class after the implementation of your class has changed. As long as the schema does not change on the client or the server, other changes on either side do not affect the other.\"\n  example:\n  - \"The following code example includes three pieces of code: a server component, an order class, and client code. The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages. The schema is an XML formatted file that describes the \\\"shape\\\" of the class. This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.  \\n  \\n The following code example represents a server component that receives orders through a message queue. The body of the message should be an order object whose schema matches the Order.cs class below. The server process or application deserializes the order.  \\n  \\n [!code-vb[Classic XmlMessageFormatter Example#1](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_1.vb)]\\n [!code-cpp[Classic XmlMessageFormatter Example#1](~/add/codesnippet/cpp/t-system.messaging.xmlme_1.cpp)]\\n [!code-cs[Classic XmlMessageFormatter Example#1](~/add/codesnippet/csharp/t-system.messaging.xmlme_1.cs)]  \\n  \\n The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.  \\n  \\n [!code-vb[Classic XmlMessageFormatter Example#2](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_2.vb)]\\n [!code-cs[Classic XmlMessageFormatter Example#2](~/add/codesnippet/csharp/t-system.messaging.xmlme_2.cs)]\\n [!code-cpp[Classic XmlMessageFormatter Example#2](~/add/codesnippet/cpp/t-system.messaging.xmlme_2.cpp)]  \\n  \\n Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body. The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body. The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.  \\n  \\n When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema. It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class). This new order class is used to serialize the order into the message body.  \\n  \\n The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue. The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility. An order is sent to the Orders queue on the local computer.  \\n  \\n [!code-vb[Classic XmlMessageFormatter Example#3](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_3.vb)]\\n [!code-cpp[Classic XmlMessageFormatter Example#3](~/add/codesnippet/cpp/t-system.messaging.xmlme_3.cpp)]\\n [!code-cs[Classic XmlMessageFormatter Example#3](~/add/codesnippet/csharp/t-system.messaging.xmlme_3.cs)]  \\n  \\n After the schema is generated from the order class on the server, you can modify the class. Unless the schema changes, you do not need to redistribute the schema. After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified. The two classes have become loosely coupled.\"\n  syntax:\n    content: 'public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter'\n  inheritance:\n  - System.Object\n  implements:\n  - System.ICloneable\n  - System.Messaging.IMessageFormatter\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.#ctor\n  id: '#ctor'\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: XmlMessageFormatter()\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter()\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()\n  type: Constructor\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, without target types set.\n  remarks: \"This overload of the constructor is used most frequently when writing to the queue, as target types are not required when writing.  \\n  \\n To read a message from a queue using an instance of <xref:System.Messaging.XmlMessageFormatter> created using this constructor, you must set the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties so the formatter knows what types to attempt to deserialize.  \\n  \\n When you create a new <xref:System.Messaging.MessageQueue>, a default <xref:System.Messaging.XmlMessageFormatter> instance is created, without the target types set. As with a formatter created using this constructor, you must set target types for that formatter instance if you want to read from the queue.\"\n  syntax:\n    content: public XmlMessageFormatter ();\n    parameters: []\n  overload: System.Messaging.XmlMessageFormatter.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])\n  id: '#ctor(System.String[])'\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: XmlMessageFormatter(String[])\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])\n  type: Constructor\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, setting target types passed in as an array of (fully qualified) string values.\n  remarks: \"The constructors with target type parameters are most frequently used when reading from the queue. When writing, it is not necessary to specify target types.  \\n  \\n This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> property to the array values passed in through the `targetTypeNames` parameter. Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of given types.  \\n  \\n Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which one to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.\"\n  example:\n  - >-\n    [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.xmlme_1.cpp)]\n     [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.xmlme_1.cs)]\n     [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.xmlme_1.vb)]\n  syntax:\n    content: public XmlMessageFormatter (string[] targetTypeNames);\n    parameters:\n    - id: targetTypeNames\n      type: System.String[]\n      description: An array of type <xref:System.String> that specifies the set of possible types that will be deserialized by the formatter from the message provided. These values must be fully qualified, for example, \"MyNamespace.MyOrders, MyOrdersAssemblyName\".\n  overload: System.Messaging.XmlMessageFormatter.#ctor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>targetTypeNames</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])\n  id: '#ctor(System.Type[])'\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: XmlMessageFormatter(Type[])\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])\n  type: Constructor\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Initializes a new instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class, setting target types passed in as an array of object types.\n  remarks: \"The constructors with target type parameters are most frequently used when reading from the queue. When writing, it is not necessary to specify target types.  \\n  \\n This overload of the <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> constructor sets the <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property to the array values passed in through the `targetTypes` parameter. Setting this property enables a <xref:System.Messaging.MessageQueue> using this <xref:System.Messaging.XmlMessageFormatter> instance to read messages containing objects of the given types.  \\n  \\n Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which one to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown at read time.  \\n  \\n When specifying <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.  \\n  \\n When using <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the following C# code.  \\n  \\n```  \\nTargetTypes = new Type[]{typeof(MyClass)}  \\n```\"\n  syntax:\n    content: public XmlMessageFormatter (Type[] targetTypes);\n    parameters:\n    - id: targetTypes\n      type: System.Type[]\n      description: An array of type <xref:System.Type> that specifies the set of possible types that will be deserialized by the formatter from the message provided.\n  overload: System.Messaging.XmlMessageFormatter.#ctor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>targetTypes</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)\n  id: CanRead(System.Messaging.Message)\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: CanRead(Message)\n  nameWithType: XmlMessageFormatter.CanRead(Message)\n  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)\n  type: Method\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Determines whether the formatter can deserialize the message.\n  remarks: \"When CanRead is called, the formatter attempts to determine if the contents of the message are something it can deserialize. The formatter can only deserialize the message if the type in the message body has the same schema as one of the types in the array represented by the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties. CanRead returns `false` under the following two circumstances:  \\n  \\n-   The message was not formatted using the <xref:System.Messaging.XmlMessageFormatter>.  \\n  \\n-   The schema of the message body is not among those listed in either the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property.  \\n  \\n The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what types of objects it must be able to deserialize. If any type is missing from the list, yet is found within the message, CanRead returns `false`.\"\n  syntax:\n    content: public bool CanRead (System.Messaging.Message message);\n    parameters:\n    - id: message\n      type: System.Messaging.Message\n      description: The <xref href=\"System.Messaging.Message\"></xref> to inspect.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the XML formatter can deserialize the message; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Messaging.XmlMessageFormatter.CanRead*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: Neither the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> nor <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> property has been set.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.Clone\n  id: Clone\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: Clone()\n  nameWithType: XmlMessageFormatter.Clone()\n  fullName: System.Messaging.XmlMessageFormatter.Clone()\n  type: Method\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Creates an instance of the <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> class whose read/write properties (the sets of target types) are the same as the current <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> instance.\n  remarks: This method creates a copy of the formatter and initializes all its properties to the values of this <xref:System.Messaging.XmlMessageFormatter> object.\n  syntax:\n    content: public object Clone ();\n    parameters: []\n    return:\n      type: System.Object\n      description: An object whose properties are identical to those of this <xref href=\"System.Messaging.XmlMessageFormatter\"></xref> instance, but whose metadata does not specify it to be a formatter class instance.\n  overload: System.Messaging.XmlMessageFormatter.Clone*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)\n  id: Read(System.Messaging.Message)\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: Read(Message)\n  nameWithType: XmlMessageFormatter.Read(Message)\n  fullName: System.Messaging.XmlMessageFormatter.Read(Message)\n  type: Method\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Reads the contents from the given message and creates an object that contains the deserialized message.\n  remarks: \"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. One of these properties must be set before the message can be deserialized.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n The target types do not have to be specified in order to write to the queue.\"\n  syntax:\n    content: public object Read (System.Messaging.Message message);\n    parameters:\n    - id: message\n      type: System.Messaging.Message\n      description: The <xref href=\"System.Messaging.Message\"></xref>, in XML format, to deserialize.\n    return:\n      type: System.Object\n      description: The deserialized message.\n  overload: System.Messaging.XmlMessageFormatter.Read*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"Neither the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> nor <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> property has been set.  \\n  \\n -or-  \\n  \\n The instance serialized in the message body does not comply with any of the schemas represented by the types in the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames*> and <xref:System.Messaging.XmlMessageFormatter.TargetTypes*> properties.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>message</code> parameter is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames\n  id: TargetTypeNames\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: TargetTypeNames\n  nameWithType: XmlMessageFormatter.TargetTypeNames\n  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames\n  type: Property\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Specifies the set of possible types that will be deserialized by the formatter from the message provided.\n  remarks: \"Both the TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.  \\n  \\n TargetTypeNames requires every entry to be fully qualified, specifying its assembly name. Further, when working with multiple concurrent versions, the version number must also be appended to the target type name as well.  \\n  \\n The target types are only required when reading from the queue. The TargetTypeNames and <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> properties do not need to be set to write to the queue.\"\n  syntax:\n    content: public string[] TargetTypeNames { get; set; }\n    return:\n      type: System.String[]\n      description: An array of type <xref:System.String> that specifies the types of objects to deserialize from the message body when reading the message.\n  overload: System.Messaging.XmlMessageFormatter.TargetTypeNames*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The TargetTypeNames property is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.TargetTypes\n  id: TargetTypes\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: TargetTypes\n  nameWithType: XmlMessageFormatter.TargetTypes\n  fullName: System.Messaging.XmlMessageFormatter.TargetTypes\n  type: Property\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Specifies the set of possible types that will be deserialized by the formatter from the message provided.\n  remarks: \"Both the <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties tell the formatter what schemas to attempt to match when deserializing a message. This allows the formatter to interpret the message body.  \\n  \\n The instance serialized in the message body must comply with one of the schemas represented in the type array. When you read the message using the <xref:System.Messaging.MessageQueue.Receive%2A> method, the method creates an object of the type that corresponds to the schema identified and reads the message body into it.  \\n  \\n Only one of the two properties needs to be set when reading from the queue, but you can set both. The set of types is the combined set from the two properties. The decision of which property to use is specific to your application. If the message body contains a type whose schema does not match any of the types in the array for either property, an exception will be thrown when the message is read.  \\n  \\n The target types are only required when reading from the queue. The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> and TargetTypes properties do not need to be set to write to the queue.  \\n  \\n When specifying TargetTypes rather than <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type existence is checked at compile time rather than read time, reducing possibility for error.  \\n  \\n When using TargetTypes, you can add each object (for example, `MyClass`) to the list in a way demonstrated by the C# code `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.\"\n  example:\n  - \"The following code example sends and receives a message that contains an order to and from a queue.  \\n  \\n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.xmlme_1.cpp)]\\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.xmlme_1.cs)]\\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.xmlme_1.vb)]\"\n  syntax:\n    content: public Type[] TargetTypes { get; set; }\n    return:\n      type: System.Type[]\n      description: An array of type <xref:System.Type> that specifies the types of objects to deserialize from the message body when reading the message.\n  overload: System.Messaging.XmlMessageFormatter.TargetTypes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The TargetTypes property is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)\n  id: Write(System.Messaging.Message,System.Object)\n  parent: System.Messaging.XmlMessageFormatter\n  langs:\n  - csharp\n  name: Write(Message,Object)\n  nameWithType: XmlMessageFormatter.Write(Message,Object)\n  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)\n  type: Method\n  assemblies:\n  - System.Messaging\n  namespace: System.Messaging\n  summary: Serializes an object into the body of the message.\n  remarks: \"The target types need not be specified to write to the queue as they must be when reading. The <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> property is used by the formatter only when deserializing a message.  \\n  \\n The <xref:System.Messaging.XmlMessageFormatter> makes use of the <xref:System.Xml.Serialization.XmlSerializer> class, which defines what can be serialized. Only public fields and public properties can be serialized. Structures, structures with arrays, and arrays of structures are all serializable, as long as they do not use the encoded style with the SOAP protocol.\"\n  syntax:\n    content: public void Write (System.Messaging.Message message, object obj);\n    parameters:\n    - id: message\n      type: System.Messaging.Message\n      description: The <xref href=\"System.Messaging.Message\"></xref> whose <xref:System.Messaging.Message.Body*> property will contain the serialized object.\n    - id: obj\n      type: System.Object\n      description: The <xref:System.Object> to be serialized into the message body.\n  overload: System.Messaging.XmlMessageFormatter.Write*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>message</code> parameter is <xref uid=\\\"langword_csharp_null\\\" name=\\\"null\\\" href=\\\"\\\"></xref>.  \\n  \\n -or-  \\n  \\n The <code>obj</code> parameter is <xref uid=\\\"langword_csharp_null\\\" name=\\\"null\\\" href=\\\"\\\"></xref>.\"\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.Messaging.XmlMessageFormatter.#ctor\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: XmlMessageFormatter()\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter()\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()\n- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: XmlMessageFormatter(String[])\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])\n- uid: System.String[]\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String[]\n  spec.csharp:\n  - uid: System.String\n    name: String\n    nameWithType: String\n    fullName: String[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: XmlMessageFormatter(Type[])\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])\n  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])\n- uid: System.Type[]\n  parent: System\n  isExternal: true\n  name: Type\n  nameWithType: Type\n  fullName: System.Type[]\n  spec.csharp:\n  - uid: System.Type\n    name: Type\n    nameWithType: Type\n    fullName: Type[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: CanRead(Message)\n  nameWithType: XmlMessageFormatter.CanRead(Message)\n  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Messaging.Message\n  parent: System.Messaging\n  isExternal: false\n  name: Message\n  nameWithType: Message\n  fullName: System.Messaging.Message\n- uid: System.Messaging.XmlMessageFormatter.Clone\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Clone()\n  nameWithType: XmlMessageFormatter.Clone()\n  fullName: System.Messaging.XmlMessageFormatter.Clone()\n- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Read(Message)\n  nameWithType: XmlMessageFormatter.Read(Message)\n  fullName: System.Messaging.XmlMessageFormatter.Read(Message)\n- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: TargetTypeNames\n  nameWithType: XmlMessageFormatter.TargetTypeNames\n  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames\n- uid: System.Messaging.XmlMessageFormatter.TargetTypes\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: TargetTypes\n  nameWithType: XmlMessageFormatter.TargetTypes\n  fullName: System.Messaging.XmlMessageFormatter.TargetTypes\n- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Write(Message,Object)\n  nameWithType: XmlMessageFormatter.Write(Message,Object)\n  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)\n- uid: System.Messaging.XmlMessageFormatter.#ctor*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: XmlMessageFormatter\n  nameWithType: XmlMessageFormatter.XmlMessageFormatter\n- uid: System.Messaging.XmlMessageFormatter.CanRead*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: CanRead\n  nameWithType: XmlMessageFormatter.CanRead\n- uid: System.Messaging.XmlMessageFormatter.Clone*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Clone\n  nameWithType: XmlMessageFormatter.Clone\n- uid: System.Messaging.XmlMessageFormatter.Read*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Read\n  nameWithType: XmlMessageFormatter.Read\n- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: TargetTypeNames\n  nameWithType: XmlMessageFormatter.TargetTypeNames\n- uid: System.Messaging.XmlMessageFormatter.TargetTypes*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: TargetTypes\n  nameWithType: XmlMessageFormatter.TargetTypes\n- uid: System.Messaging.XmlMessageFormatter.Write*\n  parent: System.Messaging.XmlMessageFormatter\n  isExternal: false\n  name: Write\n  nameWithType: XmlMessageFormatter.Write\n"}