{"nodes":[{"pos":[300,434],"content":"Indicates that any copying of values of this type must use the copy constructor provided by the type.  This class cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Indicates that any copying of values of this type must use the copy constructor provided by the type.  This class cannot be inherited.","pos":[0,134],"nodes":[{"content":"Indicates that any copying of values of this type must use the copy constructor provided by the type.","pos":[0,101]},{"content":"This class cannot be inherited.","pos":[103,134]}]}]},{"pos":[447,2086],"content":"Any type modified by the IsCopyConstructed class must implement a method named `MarshalCopy` that calls the native copy constructor.       Any native C++ type that is emitted into metadata with copy constructors needs to have those methods called by the marshaler when copying values across the marshaling boundary.  The Microsoft C++ compiler modifies all native C++ types in method parameters and return types that have this modifier to trigger this behavior in the marshaling code.       Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.       You can emit custom modifiers into metadata using one of the following techniques:      -   Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.      -   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/add/includes/ajax-current-ext-md.md).      -   Using the unmanaged reflection API.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Any type modified by the IsCopyConstructed class must implement a method named <ph id=\"ph1\">`MarshalCopy`</ph> that calls the native copy constructor.","pos":[0,132],"source":"Any type modified by the IsCopyConstructed class must implement a method named `MarshalCopy` that calls the native copy constructor."},{"content":"Any native C++ type that is emitted into metadata with copy constructors needs to have those methods called by the marshaler when copying values across the marshaling boundary.","pos":[139,315]},{"content":"The Microsoft C++ compiler modifies all native C++ types in method parameters and return types that have this modifier to trigger this behavior in the marshaling code.","pos":[317,484]},{"content":"Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.","pos":[491,654]},{"content":"When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.","pos":[656,768]},{"content":"Compilers can apply custom modifiers to methods, parameters, and return values.","pos":[770,849]},{"content":"The JIT compiler must respond to required modifiers but can ignore optional modifiers.","pos":[851,937]},{"content":"You can emit custom modifiers into metadata using one of the following techniques:      -   Using methods in the &lt;xref:System.Reflection.Emit.TypeBuilder&gt; class such as &lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A&gt;, &lt;xref:System.Reflection.Emit.TypeBuilder.DefineField%2A&gt;, &lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A&gt;, and &lt;xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A&gt;.","pos":[944,1358],"source":"       You can emit custom modifiers into metadata using one of the following techniques:      -   Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>."},{"content":"-   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to <ph id=\"ph1\">`modopt`</ph> and <ph id=\"ph2\">`modreq`</ph>, and assembling the file with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>.","pos":[1364,1582],"source":"      -   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/add/includes/ajax-current-ext-md.md)."},{"content":"-   Using the unmanaged reflection API.","pos":[1588,1627]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.CompilerServices.IsCopyConstructed\n  id: IsCopyConstructed\n  children: []\n  langs:\n  - csharp\n  name: IsCopyConstructed\n  nameWithType: IsCopyConstructed\n  fullName: System.Runtime.CompilerServices.IsCopyConstructed\n  type: Class\n  summary: Indicates that any copying of values of this type must use the copy constructor provided by the type.  This class cannot be inherited.\n  remarks: \"Any type modified by the IsCopyConstructed class must implement a method named `MarshalCopy` that calls the native copy constructor.  \\n  \\n Any native C++ type that is emitted into metadata with copy constructors needs to have those methods called by the marshaler when copying values across the marshaling boundary.  The Microsoft C++ compiler modifies all native C++ types in method parameters and return types that have this modifier to trigger this behavior in the marshaling code.  \\n  \\n Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.  \\n  \\n You can emit custom modifiers into metadata using one of the following techniques:  \\n  \\n-   Using methods in the <xref:System.Reflection.Emit.TypeBuilder> class such as <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineField%2A>, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A>, and <xref:System.Reflection.Emit.TypeBuilder.DefineProperty%2A>.  \\n  \\n-   Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to `modopt` and `modreq`, and assembling the file with the [Ilasm.exe (IL Assembler)](~/add/includes/ajax-current-ext-md.md).  \\n  \\n-   Using the unmanaged reflection API.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public static class IsCopyConstructed\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n"}