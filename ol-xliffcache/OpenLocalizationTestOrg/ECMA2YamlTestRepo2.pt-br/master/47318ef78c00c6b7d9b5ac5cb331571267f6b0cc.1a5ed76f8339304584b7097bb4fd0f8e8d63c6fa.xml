{"nodes":[{"pos":[1182,1391],"content":"Provides a managed representation of a Win32 <ph id=\"ph1\">`OVERLAPPED`</ph> structure, including methods to transfer information from an Overlapped instance to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"Provides a managed representation of a Win32 `OVERLAPPED` structure, including methods to transfer information from an Overlapped instance to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[1404,2007],"content":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an Overlapped object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the Overlapped class.       Changes to the properties of an Overlapped object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an Overlapped object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the Overlapped class.       Changes to the properties of an Overlapped object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.","pos":[0,601],"nodes":[{"content":"The &lt;xref:System.Threading.Overlapped.Pack%2A&gt; and &lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt; methods transfer information from an Overlapped object to a &lt;xref:System.Threading.NativeOverlapped&gt; structure that can be passed to Win32 API functions for asynchronous file I/O.","pos":[0,279],"source":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an Overlapped object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O."},{"content":"The &lt;xref:System.Threading.Overlapped.Unpack%2A&gt; method transfers information from a &lt;xref:System.Threading.NativeOverlapped&gt; structure to an instance of the Overlapped class.","pos":[280,455],"source":" The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the Overlapped class."},{"content":"Changes to the properties of an Overlapped object affect its associated &lt;xref:System.Threading.NativeOverlapped&gt; structure, and vice versa.","pos":[462,601],"source":"       Changes to the properties of an Overlapped object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa."}]}]},{"pos":[2533,2629],"content":"Initializes a new, empty instance of the <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new, empty instance of the <xref href=\"System.Threading.Overlapped\"></xref> class."},{"pos":[3306,3590],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation."},{"pos":[3603,4341],"content":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.       Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Use the &lt;xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName&gt; property to get the handle of any managed synchronization event that derives from the &lt;xref:System.Threading.WaitHandle&gt; class.","pos":[0,205],"source":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class."},{"content":"Your implementation of &lt;xref:System.IAsyncResult&gt; provides status information on the I/O operation.","pos":[212,311],"source":"       Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation."},{"content":"Pass it to the constructor in the <ph id=\"ph1\">`ar`</ph> parameter, and retrieve it later with the &lt;xref:System.Threading.Overlapped.AsyncResult%2A&gt; property.","pos":[312,452],"source":" Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property."},{"content":"If a callback method is specified for the &lt;xref:System.Threading.Overlapped.Pack%2A&gt; or &lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt; method, the callback can retrieve your &lt;xref:System.IAsyncResult&gt; by unpacking the &lt;xref:System.Threading.NativeOverlapped&gt; structure it receives.","pos":[453,736],"source":" If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives."}]},{"pos":[4522,4587],"content":"The low word of the file position at which to start the transfer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The low word of the file position at which to start the transfer.","pos":[0,65]}]},{"pos":[4651,4717],"content":"The high word of the file position at which to start the transfer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The high word of the file position at which to start the transfer.","pos":[0,66]}]},{"pos":[4779,4854],"content":"The handle to an event that is signaled when the I/O operation is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"The handle to an event that is signaled when the I/O operation is complete.","pos":[0,75]}]},{"pos":[4919,5039],"content":"An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object that implements the &lt;xref:System.IAsyncResult&gt; interface and provides status information on the I/O operation.","pos":[0,120],"source":"An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation."}]},{"pos":[5657,5926],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation."},{"pos":[5939,6848],"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.       Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"To get the handle of a managed synchronization object that derives from the &lt;xref:System.Threading.WaitHandle&gt; class, use the &lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName&gt; property to get a &lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt; object, and then call the &lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt; method.","pos":[0,376],"source":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method."},{"content":"Your implementation of &lt;xref:System.IAsyncResult&gt; provides status information on the I/O operation.","pos":[383,482],"source":"       Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation."},{"content":"Pass it to the constructor in the <ph id=\"ph1\">`ar`</ph> parameter, and retrieve it later with the &lt;xref:System.Threading.Overlapped.AsyncResult%2A&gt; property.","pos":[483,623],"source":" Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property."},{"content":"If a callback method is specified for the &lt;xref:System.Threading.Overlapped.Pack%2A&gt; or &lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt; method, the callback can retrieve your &lt;xref:System.IAsyncResult&gt; by unpacking the &lt;xref:System.Threading.NativeOverlapped&gt; structure it receives.","pos":[624,907],"source":" If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives."}]},{"pos":[7032,7097],"content":"The low word of the file position at which to start the transfer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The low word of the file position at which to start the transfer.","pos":[0,65]}]},{"pos":[7161,7227],"content":"The high word of the file position at which to start the transfer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The high word of the file position at which to start the transfer.","pos":[0,66]}]},{"pos":[7290,7365],"content":"The handle to an event that is signaled when the I/O operation is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"The handle to an event that is signaled when the I/O operation is complete.","pos":[0,75]}]},{"pos":[7430,7550],"content":"An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object that implements the &lt;xref:System.IAsyncResult&gt; interface and provides status information on the I/O operation.","pos":[0,120],"source":"An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation."}]},{"pos":[7957,8035],"content":"Gets or sets the object that provides status information on the I/O operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the object that provides status information on the I/O operation.","pos":[0,78]}]},{"pos":[8168,8235],"content":"An object that implements the <xref:System.IAsyncResult> interface.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object that implements the &lt;xref:System.IAsyncResult&gt; interface.","pos":[0,67],"source":"An object that implements the <xref:System.IAsyncResult> interface."}]},{"pos":[8648,8766],"content":"Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.","pos":[0,118]}]},{"pos":[8779,9124],"content":"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.       Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.       Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.","pos":[0,343],"nodes":[{"content":"This property cannot be used on 64-bit platforms.","pos":[0,49]},{"content":"Use the &lt;xref:System.Threading.Overlapped.EventHandleIntPtr%2A&gt; property instead.","pos":[50,131],"source":" Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead."},{"content":"Use the &lt;xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName&gt; property to get the handle of any managed synchronization event that derives from the &lt;xref:System.Threading.WaitHandle&gt; class.","pos":[138,343],"source":"       Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class."}]}]},{"pos":[9242,9324],"content":"An <xref:System.Int32> value representing the handle of the synchronization event.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.Int32&gt; value representing the handle of the synchronization event.","pos":[0,82],"source":"An <xref:System.Int32> value representing the handle of the synchronization event."}]},{"pos":[9767,9872],"content":"Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.","pos":[0,105]}]},{"pos":[9884,10260],"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"To get the handle of a managed synchronization object that derives from the &lt;xref:System.Threading.WaitHandle&gt; class, use the &lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName&gt; property to get a &lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt; object, and then call the &lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt; method.","pos":[0,376],"source":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method."}]},{"pos":[10387,10448],"content":"An <xref:System.IntPtr> representing the handle of the event.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IntPtr&gt; representing the handle of the event.","pos":[0,61],"source":"An <xref:System.IntPtr> representing the handle of the event."}]},{"pos":[10959,11097],"content":"Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref:System.Threading.Overlapped.Pack*> method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Frees the unmanaged memory associated with a native overlapped structure allocated by the &lt;xref:System.Threading.Overlapped.Pack*&gt; method.","pos":[0,138],"source":"Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref:System.Threading.Overlapped.Pack*> method."}]},{"pos":[11109,11408],"content":"You must call the Free method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the Free method, you will leak memory. If you call the Free method more than once, memory will be corrupted.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"You must call the Free method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the Free method, you will leak memory. If you call the Free method more than once, memory will be corrupted.","pos":[0,299],"nodes":[{"content":"You must call the Free method exactly once on every &lt;xref:System.Threading.NativeOverlapped&gt; pointer you receive from the &lt;xref:System.Threading.Overlapped.Pack%2A&gt; method.","pos":[0,172],"source":"You must call the Free method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method."},{"content":"If you don't call the Free method, you will leak memory.","pos":[173,229]},{"content":"If you call the Free method more than once, memory will be corrupted.","pos":[230,299]}]}]},{"pos":[11626,11720],"content":"A pointer to the <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure to be freed.","needQuote":true,"needEscape":true,"source":"A pointer to the <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to be freed."},{"pos":[11883,11980],"content":"<ph id=\"ph1\">&lt;code&gt;nativeOverlappedPtr&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>nativeOverlappedPtr</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[12318,12466],"content":"Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","pos":[0,148],"nodes":[{"content":"Gets or sets the high-order word of the file position at which to start the transfer.","pos":[0,85]},{"content":"The file position is a byte offset from the start of the file.","pos":[86,148]}]}]},{"pos":[12582,12659],"content":"An <xref:System.Int32> value representing the high word of the file position.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.Int32&gt; value representing the high word of the file position.","pos":[0,77],"source":"An <xref:System.Int32> value representing the high word of the file position."}]},{"pos":[13061,13208],"content":"Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","pos":[0,147],"nodes":[{"content":"Gets or sets the low-order word of the file position at which to start the transfer.","pos":[0,84]},{"content":"The file position is a byte offset from the start of the file.","pos":[85,147]}]}]},{"pos":[13323,13399],"content":"An <xref:System.Int32> value representing the low word of the file position.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.Int32&gt; value representing the low word of the file position.","pos":[0,76],"source":"An <xref:System.Int32> value representing the low word of the file position."}]},{"pos":[13917,14103],"content":"Packs the current instance into a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete.","needQuote":true,"needEscape":true,"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete."},{"pos":[14116,14823],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.      > [!IMPORTANT] >  The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The &lt;xref:System.Threading.NativeOverlapped&gt; structure is fixed in physical memory until &lt;xref:System.Threading.Overlapped.Unpack%2A&gt; is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  The caller is responsible for pinning the buffer.","pos":[264,331],"source":"      > [!IMPORTANT] >  The caller is responsible for pinning the buffer."},{"content":"If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address.","pos":[332,509]},{"content":"For this reason, it is better to use the &lt;xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29&gt; method overload, in which the runtime pins the buffer.","pos":[510,704],"source":" For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer."}]},{"pos":[15041,15202],"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","needQuote":true,"needEscape":true,"source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."},{"pos":[15281,15372],"content":"An unmanaged pointer to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[15543,15628],"content":"The current <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been packed.","needQuote":true,"needEscape":true,"source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."},{"pos":[16127,16358],"content":"Packs the current instance into a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer.","needQuote":true,"needEscape":true,"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer."},{"pos":[16371,17028],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.       The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.      > [!NOTE] >  The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The &lt;xref:System.Threading.NativeOverlapped&gt; structure is fixed in physical memory until &lt;xref:System.Threading.Overlapped.Unpack%2A&gt; is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."},{"content":"The buffer or buffers specified in <ph id=\"ph1\">`userData`</ph> must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.","pos":[265,422],"source":"       The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  The runtime pins the buffer or buffers specified in <ph id=\"ph2\">`userData`</ph> for the duration of the I/O operation.","pos":[428,542],"source":"      > [!NOTE] >  The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation."},{"content":"If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","pos":[543,652]}]},{"pos":[17263,17424],"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","needQuote":true,"needEscape":true,"source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."},{"pos":[17489,17641],"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","pos":[0,152],"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation.","pos":[0,88]},{"content":"Each object represents a buffer, for example an array of bytes.","pos":[89,152]}]}]},{"pos":[17720,17811],"content":"An unmanaged pointer to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[17982,18067],"content":"The current <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been packed.","needQuote":true,"needEscape":true,"source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."},{"pos":[18512,18680],"content":"Unpacks the specified unmanaged <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure into a managed <bpt id=\"p2\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> object.","needQuote":true,"needEscape":true,"source":"Unpacks the specified unmanaged <xref href=\"System.Threading.NativeOverlapped\"></xref> structure into a managed <xref href=\"System.Threading.Overlapped\"></xref> object."},{"pos":[18692,18850],"content":"The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The &lt;xref:System.Threading.NativeOverlapped&gt; structure is not freed from physical memory until you call the &lt;xref:System.Threading.Overlapped.Free%2A&gt; method.","pos":[0,158],"source":"The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method."}]},{"pos":[19093,19184],"content":"An unmanaged pointer to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[19256,19377],"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object containing the information unpacked from the native structure.","needQuote":true,"needEscape":true,"source":"An <xref href=\"System.Threading.Overlapped\"></xref> object containing the information unpacked from the native structure."},{"pos":[19542,19639],"content":"<ph id=\"ph1\">&lt;code&gt;nativeOverlappedPtr&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>nativeOverlappedPtr</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[20119,20338],"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete. Does not propagate the calling stack.","needQuote":true,"needEscape":true,"nodes":[{"content":"Packs the current instance into a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure specifying the delegate to invoke when the asynchronous I/O operation is complete.","pos":[0,181],"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete."},{"content":"Does not propagate the calling stack.","pos":[182,219]}]},{"pos":[20351,21453],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.       The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.      > [!CAUTION] >  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The &lt;xref:System.Threading.NativeOverlapped&gt; structure is fixed in physical memory until &lt;xref:System.Threading.Overlapped.Unpack%2A&gt; is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."},{"content":"The caller is responsible for pinning the buffer.","pos":[265,314]},{"content":"If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address.","pos":[315,492]},{"content":"For this reason, it is better to use the &lt;xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29&gt; method overload, in which the runtime pins the buffer.","pos":[493,693],"source":" For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using the &lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt; method could inadvertently open up a security hole.","pos":[699,825],"source":"      > [!CAUTION] >  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[826,926]},{"content":"The &lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt; method does not propagate the calling stack.","pos":[927,1024],"source":" The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack."},{"content":"Malicious code might be able to exploit this to avoid permission checks.","pos":[1025,1097]}]},{"pos":[21677,21838],"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","needQuote":true,"needEscape":true,"source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."},{"pos":[21917,22008],"content":"An unmanaged pointer to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[22185,22270],"content":"The current <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been packed.","needQuote":true,"needEscape":true,"source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."},{"pos":[22799,23066],"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer. Does not propagate the calling stack.","needQuote":true,"needEscape":true,"nodes":[{"content":"Packs the current instance into a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer.","pos":[0,229],"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer."},{"content":"Does not propagate the calling stack.","pos":[230,267]}]},{"pos":[23079,24053],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.       The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.       The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.      > [!CAUTION] >  Using the UnsafePack method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The UnsafePack method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The &lt;xref:System.Threading.NativeOverlapped&gt; structure is fixed in physical memory until &lt;xref:System.Threading.Overlapped.Unpack%2A&gt; is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."},{"content":"The buffer or buffers specified in <ph id=\"ph1\">`userData`</ph> must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.","pos":[265,422],"source":"       The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O."},{"content":"The runtime pins the buffer or buffers specified in<ph id=\"ph1\">`userData`</ph> for the duration of the I/O operation.","pos":[429,529],"source":"       The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation."},{"content":"If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","pos":[530,639]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using the UnsafePack method could inadvertently open up a security hole.","pos":[645,733],"source":"      > [!CAUTION] >  Using the UnsafePack method could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[734,834]},{"content":"The UnsafePack method does not propagate the calling stack.","pos":[835,894]},{"content":"Malicious code might be able to exploit this to avoid permission checks.","pos":[895,967]}]},{"pos":[24294,24455],"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","needQuote":true,"needEscape":true,"source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."},{"pos":[24520,24672],"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","pos":[0,152],"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation.","pos":[0,88]},{"content":"Each object represents a buffer, for example an array of bytes.","pos":[89,152]}]}]},{"pos":[24751,24842],"content":"An unmanaged pointer to a <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure.","needQuote":true,"needEscape":true,"source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."},{"pos":[25021,25070],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[25181,25260],"content":"The current <bpt id=\"p1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is already packed.","needQuote":true,"needEscape":true,"source":"The current <xref href=\"System.Threading.Overlapped\"></xref> is already packed."}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Overlapped\n  id: Overlapped\n  children:\n  - System.Threading.Overlapped.#ctor\n  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  - System.Threading.Overlapped.AsyncResult\n  - System.Threading.Overlapped.EventHandle\n  - System.Threading.Overlapped.EventHandleIntPtr\n  - System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  - System.Threading.Overlapped.OffsetHigh\n  - System.Threading.Overlapped.OffsetLow\n  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  - System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  langs:\n  - csharp\n  name: Overlapped\n  nameWithType: Overlapped\n  fullName: System.Threading.Overlapped\n  type: Class\n  summary: Provides a managed representation of a Win32 `OVERLAPPED` structure, including methods to transfer information from an Overlapped instance to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  remarks: \"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an Overlapped object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the Overlapped class.  \\n  \\n Changes to the properties of an Overlapped object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class Overlapped\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.#ctor\n  id: '#ctor'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped()\n  nameWithType: Overlapped.Overlapped()\n  fullName: System.Threading.Overlapped.Overlapped()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new, empty instance of the <xref href=\"System.Threading.Overlapped\"></xref> class.\n  syntax:\n    content: public Overlapped ();\n    parameters: []\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  id: '#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped(Int32,Int32,Int32,IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)\n  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.\n  remarks: \"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.  \\n  \\n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.\"\n  syntax:\n    content: public Overlapped (int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);\n    parameters:\n    - id: offsetLo\n      type: System.Int32\n      description: The low word of the file position at which to start the transfer.\n    - id: offsetHi\n      type: System.Int32\n      description: The high word of the file position at which to start the transfer.\n    - id: hEvent\n      type: System.Int32\n      description: The handle to an event that is signaled when the I/O operation is complete.\n    - id: ar\n      type: System.IAsyncResult\n      description: An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation.\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  id: '#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.\n  remarks: \"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.  \\n  \\n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.\"\n  syntax:\n    content: public Overlapped (int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);\n    parameters:\n    - id: offsetLo\n      type: System.Int32\n      description: The low word of the file position at which to start the transfer.\n    - id: offsetHi\n      type: System.Int32\n      description: The high word of the file position at which to start the transfer.\n    - id: hEvent\n      type: System.IntPtr\n      description: The handle to an event that is signaled when the I/O operation is complete.\n    - id: ar\n      type: System.IAsyncResult\n      description: An object that implements the <xref:System.IAsyncResult> interface and provides status information on the I/O operation.\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.AsyncResult\n  id: AsyncResult\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n  fullName: System.Threading.Overlapped.AsyncResult\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets or sets the object that provides status information on the I/O operation.\n  syntax:\n    content: public IAsyncResult AsyncResult { get; set; }\n    return:\n      type: System.IAsyncResult\n      description: An object that implements the <xref:System.IAsyncResult> interface.\n  overload: System.Threading.Overlapped.AsyncResult*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.EventHandle\n  id: EventHandle\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n  fullName: System.Threading.Overlapped.EventHandle\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.\n  remarks: \"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.  \\n  \\n Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.\"\n  syntax:\n    content: public int EventHandle { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref:System.Int32> value representing the handle of the synchronization event.\n  overload: System.Threading.Overlapped.EventHandle*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.EventHandleIntPtr\n  id: EventHandleIntPtr\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n  fullName: System.Threading.Overlapped.EventHandleIntPtr\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.\n  remarks: To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.\n  syntax:\n    content: public IntPtr EventHandleIntPtr { get; set; }\n    return:\n      type: System.IntPtr\n      description: An <xref:System.IntPtr> representing the handle of the event.\n  overload: System.Threading.Overlapped.EventHandleIntPtr*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  id: Free(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Free(NativeOverlapped*)\n  nameWithType: Overlapped.Free(NativeOverlapped*)\n  fullName: System.Threading.Overlapped.Free(NativeOverlapped*)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref:System.Threading.Overlapped.Pack*> method.\n  remarks: You must call the Free method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the Free method, you will leak memory. If you call the Free method more than once, memory will be corrupted.\n  syntax:\n    content: public static void Free (System.Threading.NativeOverlapped* nativeOverlappedPtr);\n    parameters:\n    - id: nativeOverlappedPtr\n      type: System.Threading.NativeOverlapped*\n      description: A pointer to the <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to be freed.\n  overload: System.Threading.Overlapped.Free*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>nativeOverlappedPtr</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.OffsetHigh\n  id: OffsetHigh\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n  fullName: System.Threading.Overlapped.OffsetHigh\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.\n  syntax:\n    content: public int OffsetHigh { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref:System.Int32> value representing the high word of the file position.\n  overload: System.Threading.Overlapped.OffsetHigh*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.OffsetLow\n  id: OffsetLow\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n  fullName: System.Threading.Overlapped.OffsetLow\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.\n  syntax:\n    content: public int OffsetLow { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref:System.Int32> value representing the low word of the file position.\n  overload: System.Threading.Overlapped.OffsetLow*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  id: Pack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Pack(IOCompletionCallback)\n  nameWithType: Overlapped.Pack(IOCompletionCallback)\n  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n> [!IMPORTANT]\\n>  The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.\"\n  syntax:\n    content: public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.Pack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  id: Pack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Pack(IOCompletionCallback,Object)\n  nameWithType: Overlapped.Pack(IOCompletionCallback,Object)\n  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \\n  \\n> [!NOTE]\\n>  The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.\"\n  syntax:\n    content: public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb, object userData);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    - id: userData\n      type: System.Object\n      description: An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.Pack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  id: Unpack(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Unpack(NativeOverlapped*)\n  nameWithType: Overlapped.Unpack(NativeOverlapped*)\n  fullName: System.Threading.Overlapped.Unpack(NativeOverlapped*)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Unpacks the specified unmanaged <xref href=\"System.Threading.NativeOverlapped\"></xref> structure into a managed <xref href=\"System.Threading.Overlapped\"></xref> object.\n  remarks: The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method.\n  syntax:\n    content: public static System.Threading.Overlapped Unpack (System.Threading.NativeOverlapped* nativeOverlappedPtr);\n    parameters:\n    - id: nativeOverlappedPtr\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n    return:\n      type: System.Threading.Overlapped\n      description: An <xref href=\"System.Threading.Overlapped\"></xref> object containing the information unpacked from the native structure.\n  overload: System.Threading.Overlapped.Unpack*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>nativeOverlappedPtr</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  id: UnsafePack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: UnsafePack(IOCompletionCallback)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)\n  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete. Does not propagate the calling stack.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.  \\n  \\n> [!CAUTION]\\n>  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.\"\n  syntax:\n    content: public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.UnsafePack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  platform:\n  - net462\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  id: UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: UnsafePack(IOCompletionCallback,Object)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback,Object)\n  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer. Does not propagate the calling stack.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \\n  \\n The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.  \\n  \\n> [!CAUTION]\\n>  Using the UnsafePack method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The UnsafePack method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.\"\n  syntax:\n    content: public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb, object userData);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    - id: userData\n      type: System.Object\n      description: An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.UnsafePack*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> is already packed.\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.Security.SecurityException\n  isExternal: true\n  name: System.Security.SecurityException\n- uid: System.Threading.Overlapped.#ctor\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped()\n  nameWithType: Overlapped.Overlapped()\n  fullName: System.Threading.Overlapped.Overlapped()\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped(Int32,Int32,Int32,IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)\n  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,Int32,IAsyncResult)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: true\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n  fullName: System.Threading.Overlapped.Overlapped(Int32,Int32,IntPtr,IAsyncResult)\n- uid: System.IntPtr\n  parent: System\n  isExternal: true\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Threading.Overlapped.AsyncResult\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n  fullName: System.Threading.Overlapped.AsyncResult\n- uid: System.Threading.Overlapped.EventHandle\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n  fullName: System.Threading.Overlapped.EventHandle\n- uid: System.Threading.Overlapped.EventHandleIntPtr\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n  fullName: System.Threading.Overlapped.EventHandleIntPtr\n- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Free(NativeOverlapped*)\n  nameWithType: Overlapped.Free(NativeOverlapped*)\n  fullName: System.Threading.Overlapped.Free(NativeOverlapped*)\n- uid: System.Threading.Overlapped.OffsetHigh\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n  fullName: System.Threading.Overlapped.OffsetHigh\n- uid: System.Threading.Overlapped.OffsetLow\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n  fullName: System.Threading.Overlapped.OffsetLow\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack(IOCompletionCallback)\n  nameWithType: Overlapped.Pack(IOCompletionCallback)\n  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback)\n- uid: System.Threading.IOCompletionCallback\n  parent: System.Threading\n  isExternal: false\n  name: IOCompletionCallback\n  nameWithType: IOCompletionCallback\n  fullName: System.Threading.IOCompletionCallback\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack(IOCompletionCallback,Object)\n  nameWithType: Overlapped.Pack(IOCompletionCallback,Object)\n  fullName: System.Threading.Overlapped.Pack(IOCompletionCallback,Object)\n- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Unpack(NativeOverlapped*)\n  nameWithType: Overlapped.Unpack(NativeOverlapped*)\n  fullName: System.Threading.Overlapped.Unpack(NativeOverlapped*)\n- uid: System.Threading.Overlapped\n  parent: System.Threading\n  isExternal: false\n  name: Overlapped\n  nameWithType: Overlapped\n  fullName: System.Threading.Overlapped\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack(IOCompletionCallback)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)\n  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback)\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack(IOCompletionCallback,Object)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback,Object)\n  fullName: System.Threading.Overlapped.UnsafePack(IOCompletionCallback,Object)\n- uid: System.Threading.Overlapped.#ctor*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped\n  nameWithType: Overlapped.Overlapped\n- uid: System.Threading.Overlapped.AsyncResult*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n- uid: System.Threading.Overlapped.EventHandle*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n- uid: System.Threading.Overlapped.EventHandleIntPtr*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n- uid: System.Threading.Overlapped.Free*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Free\n  nameWithType: Overlapped.Free\n- uid: System.Threading.Overlapped.OffsetHigh*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n- uid: System.Threading.Overlapped.OffsetLow*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n- uid: System.Threading.Overlapped.Pack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack\n  nameWithType: Overlapped.Pack\n- uid: System.Threading.Overlapped.Unpack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Unpack\n  nameWithType: Overlapped.Unpack\n- uid: System.Threading.Overlapped.UnsafePack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack\n  nameWithType: Overlapped.UnsafePack\n"}