{"nodes":[{"pos":[2158,2267],"content":"Provides a <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that can be written to and updated.","needQuote":true,"needEscape":true,"source":"Provides a <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that can be written to and updated."},{"pos":[2280,4621],"content":"Use the WriteableBitmap class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.       The WriteableBitmap class uses two buffers. The *back buffer* is allocated in system memory and accumulates content that is not currently displayed. The *front buffer* is allocated in system memory and contains the content that is currently displayed. The rendering system copies the front buffer to video memory for display.       Two threads use these buffers. The *user interface (UI) thread* generates the UI but does not present it to the screen. The UI thread responds to user input, timers, and other events. An application can have multiple UI threads. The *render thread* composes and renders changes from the UI thread. There is only one render thread per application.       The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.       Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.       For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.      1.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.      2.  Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.      3.  Write changes to the back buffer. Other threads may write changes to the back buffer when the WriteableBitmap is locked.      4.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.      5.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.       When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Use the WriteableBitmap class to update and render a bitmap on a per-frame basis.","pos":[0,81]},{"content":"This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.","pos":[82,213]},{"content":"The WriteableBitmap class uses two buffers.","pos":[220,263]},{"content":"The <bpt id=\"p1\">*</bpt>back buffer<ept id=\"p1\">*</ept> is allocated in system memory and accumulates content that is not currently displayed.","pos":[264,368],"source":" The *back buffer* is allocated in system memory and accumulates content that is not currently displayed."},{"content":"The <bpt id=\"p1\">*</bpt>front buffer<ept id=\"p1\">*</ept> is allocated in system memory and contains the content that is currently displayed.","pos":[369,471],"source":" The *front buffer* is allocated in system memory and contains the content that is currently displayed."},{"content":"The rendering system copies the front buffer to video memory for display.","pos":[472,545]},{"content":"Two threads use these buffers.","pos":[552,582]},{"content":"The <bpt id=\"p1\">*</bpt>user interface (UI) thread<ept id=\"p1\">*</ept> generates the UI but does not present it to the screen.","pos":[583,671],"source":" The *user interface (UI) thread* generates the UI but does not present it to the screen."},{"content":"The UI thread responds to user input, timers, and other events.","pos":[672,735]},{"content":"An application can have multiple UI threads.","pos":[736,780]},{"content":"The <bpt id=\"p1\">*</bpt>render thread<ept id=\"p1\">*</ept> composes and renders changes from the UI thread.","pos":[781,849],"source":" The *render thread* composes and renders changes from the UI thread."},{"content":"There is only one render thread per application.","pos":[850,898]},{"content":"The UI thread writes content to the back buffer.","pos":[905,953]},{"content":"The render thread reads content from the front buffer and copies it to video memory.","pos":[954,1038]},{"content":"Changes to the back buffer are tracked with changed rectangular regions.","pos":[1039,1111]},{"content":"Call one of the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A&gt; overloads to update and display content in the back buffer automatically.","pos":[1118,1274],"source":"       Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically."},{"content":"For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.","pos":[1281,1392]},{"content":"1.","pos":[1398,1400]},{"content":"Call the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; method to reserve the back buffer for updates.","pos":[1402,1517],"source":"  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates."},{"content":"2.","pos":[1523,1525]},{"content":"Obtain a pointer to the back buffer by accessing the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A&gt; property.","pos":[1527,1655],"source":"  Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property."},{"content":"3.","pos":[1661,1663]},{"content":"Write changes to the back buffer.","pos":[1665,1698]},{"content":"Other threads may write changes to the back buffer when the WriteableBitmap is locked.","pos":[1699,1785]},{"content":"4.","pos":[1791,1793]},{"content":"Call the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt; method to indicate areas that have changed.","pos":[1795,1915],"source":"  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed."},{"content":"5.","pos":[1921,1923]},{"content":"Call the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; method to release the back buffer and allow presentation to the screen.","pos":[1925,2067],"source":"  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen."},{"content":"When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer.","pos":[2074,2213]},{"content":"The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","pos":[2214,2317]}]},{"pos":[11048,11233],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using the given <bpt id=\"p2\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class using the given <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref>."},{"pos":[11246,11658],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.       If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29&gt; constructor is preferred over using this constructor.","pos":[0,262],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor."},{"content":"If <ph id=\"ph1\">`source`</ph> does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.","pos":[269,410],"source":"       If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance."}]},{"pos":[11864,11957],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to use for initialization.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> to use for initialization."},{"pos":[12883,13019],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with the specified parameters.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class with the specified parameters."},{"pos":[13031,13362],"content":"The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. These formats are natively supported and do not require a format conversion. Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The preferred values for <ph id=\"ph1\">`pixelFormat`</ph> are &lt;xref:System.Windows.Media.PixelFormats.Bgr32%2A&gt; and &lt;xref:System.Windows.Media.PixelFormats.Pbgra32%2A&gt;.","pos":[0,149],"source":"The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>."},{"content":"These formats are natively supported and do not require a format conversion.","pos":[150,226]},{"content":"Other <ph id=\"ph1\">`pixelFormat`</ph> values require a format conversion for each frame update, which reduces performance.","pos":[227,331],"source":" Other `pixelFormat` values require a format conversion for each frame update, which reduces performance."}]},{"pos":[13649,13681],"content":"The desired width of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The desired width of the bitmap.","pos":[0,32]}]},{"pos":[13748,13781],"content":"The desired height of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The desired height of the bitmap.","pos":[0,33]}]},{"pos":[13842,13934],"content":"The horizontal <ph id=\"ph1\">[!INCLUDE[TLA#tla_dpi](~/add/includes/ajax-current-ext-md.md)]</ph> of the bitmap.","needQuote":true,"needEscape":true,"source":"The horizontal [!INCLUDE[TLA#tla_dpi](~/add/includes/ajax-current-ext-md.md)] of the bitmap."},{"pos":[13995,14076],"content":"The vertical <ph id=\"ph1\">[!INCLUDE[TLA#tla_dpi](../Token/TLA%23tla_dpi_md.md)]</ph> of the bitmap.","needQuote":true,"needEscape":true,"source":"The vertical [!INCLUDE[TLA#tla_dpi](../Token/TLA%23tla_dpi_md.md)] of the bitmap."},{"pos":[14163,14235],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.PixelFormat\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> of the bitmap.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Windows.Media.PixelFormat\"></xref> of the bitmap."},{"pos":[14328,14410],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapPalette\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> of the bitmap.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Windows.Media.Imaging.BitmapPalette\"></xref> of the bitmap."},{"pos":[14998,15044],"content":"Specifies the area of the bitmap that changed.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies the area of the bitmap that changed.","pos":[0,46]}]},{"pos":[15057,15810],"content":"Call the AddDirtyRect method to indicate changes your code has made to the back buffer.       When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.       Call the AddDirtyRect method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Call the AddDirtyRect method to indicate changes your code has made to the back buffer.       When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.       Call the AddDirtyRect method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","pos":[0,749],"nodes":[{"content":"Call the AddDirtyRect method to indicate changes your code has made to the back buffer.","pos":[0,87]},{"content":"When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation.","pos":[94,231]},{"content":"For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer.","pos":[232,344]},{"content":"However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.","pos":[345,466]},{"content":"Call the AddDirtyRect method only between calls to the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; methods, as described in the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; class remarks.","pos":[473,749],"source":"       Call the AddDirtyRect method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."}]}]},{"pos":[16228,16338],"content":"An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed. Dimensions are in pixels.","needQuote":true,"needEscape":true,"nodes":[{"content":"An <bpt id=\"p1\">&lt;xref href=\"System.Windows.Int32Rect\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> representing the area that changed.","pos":[0,84],"source":"An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed."},{"content":"Dimensions are in pixels.","pos":[85,110]}]},{"pos":[16534,16712],"content":"The bitmap has not been locked by a call to the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock<bpt id=\"p1\">*</bpt>&gt; or &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock<ept id=\"p1\">*</ept>&gt; methods.","needQuote":true,"needEscape":true,"source":"The bitmap has not been locked by a call to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock*> or <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock*> methods."},{"pos":[16827,16948],"content":"<ph id=\"ph1\">&lt;code&gt;dirtyRect&lt;/code&gt;</ph> falls outside the bounds of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>dirtyRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"pos":[17362,17396],"content":"Gets a pointer to the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a pointer to the back buffer.","pos":[0,34]}]},{"pos":[17409,18397],"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.       Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.       The address of the back buffer does not change.      ## Thread Safety    You can pass the BackBuffer pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.       Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.       The address of the back buffer does not change.      ## Thread Safety    You can pass the BackBuffer pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","pos":[0,981],"nodes":[{"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.","pos":[0,87]},{"content":"Update the back buffer only between calls to the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; methods.","pos":[94,277],"source":"       Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods."},{"content":"If you do not follow the Lock/Unlock workflow described in the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; class remarks, undefined behaviors, such as tearing, can occur.","pos":[278,456],"source":" If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur."},{"content":"The address of the back buffer does not change.","pos":[463,510]},{"content":"Thread Safety    You can pass the BackBuffer pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination.","pos":[519,689]},{"content":"In particular, you must ensure that the UI thread specifies changed areas by calling the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt; method, and that the UI thread unlocks the buffer by calling the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; method.","pos":[690,981],"source":" In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method."}]}]},{"pos":[18513,18588],"content":"An <xref:System.IntPtr> that points to the base address of the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IntPtr&gt; that points to the base address of the back buffer.","pos":[0,75],"source":"An <xref:System.IntPtr> that points to the base address of the back buffer."}]},{"pos":[19118,19192],"content":"Gets a value indicating the number of bytes in a single row of pixel data.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a value indicating the number of bytes in a single row of pixel data.","pos":[0,74]}]},{"pos":[19309,19381],"content":"An integer indicating the number of bytes in a single row of pixel data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An integer indicating the number of bytes in a single row of pixel data.","pos":[0,72]}]},{"pos":[19866,20183],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.","needQuote":true,"needEscape":true,"nodes":[{"content":"Creates a modifiable clone of this <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, making deep copies of this object's values.","pos":[0,145],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values."},{"content":"When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.","pos":[146,317]}]},{"pos":[20196,20541],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.       For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.       For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","pos":[0,343],"nodes":[{"content":"This method is used to produce modifiable copies of frozen &lt;xref:System.Windows.Freezable&gt; objects (or any &lt;xref:System.Windows.Freezable&gt; object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]},{"content":"For more information, see &lt;xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName&gt;.","pos":[251,343],"source":"       For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>."}]}]},{"pos":[20735,21057],"content":"A modifiable clone of the current object. The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true.\" name=\"true.\" href=\"\"></xref>","needQuote":true,"needEscape":true,"nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's &lt;xref:System.Windows.Freezable.IsFrozen<bpt id=\"p1\">*</bpt>&gt; property will be <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> even if the source's &lt;xref:System.Windows.Freezable.IsFrozen<ept id=\"p1\">*</ept>&gt; property was <bpt id=\"p3\">&lt;xref uid=\"langword_csharp_true.\" name=\"true.\" href=\"\"&gt;</bpt><ept id=\"p3\">&lt;/xref&gt;</ept>","pos":[42,322],"source":" The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true.\" name=\"true.\" href=\"\"></xref>"}]},{"pos":[21818,21830],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[22368,22639],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are.","needQuote":true,"needEscape":true,"nodes":[{"content":"Creates a modifiable clone of this <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object, making deep copies of this object's current values.","pos":[0,174],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values."},{"content":"Resource references, data bindings, and animations are not copied, but their current values are.","pos":[175,271]}]},{"pos":[22652,23009],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.       For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.       For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","pos":[0,355],"nodes":[{"content":"This method is used to produce modifiable copies of frozen &lt;xref:System.Windows.Freezable&gt; objects (or any &lt;xref:System.Windows.Freezable&gt; object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]},{"content":"For more information, see &lt;xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName&gt;.","pos":[251,355],"source":"       For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>."}]}]},{"pos":[23215,23536],"content":"A modifiable clone of the current object. The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.","needQuote":true,"needEscape":true,"nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's &lt;xref:System.Windows.Freezable.IsFrozen<bpt id=\"p1\">*</bpt>&gt; property will be <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> even if the source's &lt;xref:System.Windows.Freezable.IsFrozen<ept id=\"p1\">*</ept>&gt; property was <bpt id=\"p3\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p3\">&lt;/xref&gt;</ept>.","pos":[42,321],"source":" The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>."}]},{"pos":[24381,24393],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[25114,25126],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[25840,25852],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[25911,25923],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[26725,26737],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[27616,27628],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[28119,28156],"content":"Reserves the back buffer for updates.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reserves the back buffer for updates.","pos":[0,37]}]},{"pos":[28169,29137],"content":"The Lock method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.       You can use the Lock method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.       The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The Lock method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.       You can use the Lock method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.       The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","pos":[0,964],"nodes":[{"content":"The Lock method increments the lock count.","pos":[0,42]},{"content":"When a &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; is locked, the rendering system does not send updates until the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; is fully unlocked by calls to the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; method.","pos":[43,321],"source":" When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method."},{"content":"You can use the Lock method to support multi-threaded implementations.","pos":[328,398]},{"content":"In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads.","pos":[399,495]},{"content":"When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.","pos":[496,602]},{"content":"The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer.","pos":[609,730]},{"content":"If the latency from this block is too long, use the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A&gt; method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","pos":[731,964],"source":" If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked."}]}]},{"pos":[29963,30048],"content":"Attempts to lock the bitmap, waiting for no longer than the specified length of time.","needQuote":true,"needEscape":true,"nodes":[{"content":"Attempts to lock the bitmap, waiting for no longer than the specified length of time.","pos":[0,85]}]},{"pos":[30060,30206],"content":"When a lock is acquired, the behavior of the TryLock method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"When a lock is acquired, the behavior of the TryLock method is the same as the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; method.","pos":[0,146],"source":"When a lock is acquired, the behavior of the TryLock method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method."}]},{"pos":[30374,30570],"content":"A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait. A value of 0 returns immediately. A value of <xref:System.Windows.Duration.Forever*> blocks indefinitely.","needQuote":true,"needEscape":true,"nodes":[{"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Windows.Duration\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that represents the length of time to wait.","pos":[0,90],"source":"A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait."},{"content":"A value of 0 returns immediately.","pos":[91,124]},{"content":"A value of &lt;xref:System.Windows.Duration.Forever*&gt; blocks indefinitely.","pos":[125,196],"source":" A value of <xref:System.Windows.Duration.Forever*> blocks indefinitely."}]},{"pos":[30629,30790],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the lock was acquired; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the lock was acquired; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[30985,31058],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is set to <ph id=\"ph2\">&lt;xref:System.Windows.Duration.Automatic*&gt;</ph>.","needQuote":true,"needEscape":true,"source":"<code>timeout</code> is set to <xref:System.Windows.Duration.Automatic*>."},{"pos":[31456,31514],"content":"Releases the back buffer to make it available for display.","needQuote":true,"needEscape":true,"nodes":[{"content":"Releases the back buffer to make it available for display.","pos":[0,58]}]},{"pos":[31526,31727],"content":"The Unlock method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The Unlock method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.","pos":[0,201],"nodes":[{"content":"The Unlock method decrements the lock count.","pos":[0,44]},{"content":"When the lock count reaches 0, a render pass is requested if the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt; method has been called.","pos":[45,201],"source":" When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called."}]}]},{"pos":[32189,32367],"content":"The bitmap has not been locked by a call to the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock<bpt id=\"p1\">*</bpt>&gt; or &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock<ept id=\"p1\">*</ept>&gt; methods.","needQuote":true,"needEscape":true,"source":"The bitmap has not been locked by a call to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock*> or <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock*> methods."},{"pos":[33001,33058],"content":"Updates the pixels in the specified region of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]},{"pos":[33071,33661],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; overloads are preferred over using this method.","pos":[0,379],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  In partial trust, use the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; overload.","pos":[385,587],"source":"      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]},{"pos":[34102,34199],"content":"The rectangle of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to update.","needQuote":true,"needEscape":true,"source":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update."},{"pos":[34261,34303],"content":"The pixel array used to update the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The pixel array used to update the bitmap.","pos":[0,42]}]},{"pos":[34365,34409],"content":"The stride of the update region in <ph id=\"ph1\">`pixels`</ph>.","needQuote":true,"needEscape":true,"source":"The stride of the update region in `pixels`."},{"pos":[34471,34495],"content":"The input buffer offset.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input buffer offset.","pos":[0,24]}]},{"pos":[34695,34946],"content":"One or more of the following conditions is true.       <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>stride</code> &lt; 1       <code>offset</code> &lt; 0","needQuote":false,"needEscape":true,"nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceRect</ph><ept id=\"p1\">&lt;/code&gt;</ept> falls outside the bounds of the <bpt id=\"p2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[55,177],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">stride</ph><ept id=\"p1\">&lt;/code&gt;</ept> <ph id=\"ph2\">&amp;lt;</ph> 1       <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">offset</ph><ept id=\"p2\">&lt;/code&gt;</ept> <ph id=\"ph4\">&amp;lt;</ph> 0","pos":[184,243],"source":"<code>stride</code> &lt; 1       <code>offset</code> &lt; 0"}]},{"pos":[35050,35134],"content":"<ph id=\"ph1\">&lt;code&gt;pixels&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>pixels</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[35229,35320],"content":"<ph id=\"ph1\">&lt;code&gt;pixels&lt;/code&gt;</ph> has a rank other than 1 or 2, or its length is less than or equal to 0.","needQuote":true,"needEscape":true,"source":"<code>pixels</code> has a rank other than 1 or 2, or its length is less than or equal to 0."},{"pos":[35959,36016],"content":"Updates the pixels in the specified region of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]},{"pos":[36029,36619],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; overloads are preferred over using this method.","pos":[0,379],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  In partial trust, use the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; overload.","pos":[385,587],"source":"      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]},{"pos":[36843,36940],"content":"The rectangle of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to update.","needQuote":true,"needEscape":true,"source":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update."},{"pos":[37003,37046],"content":"The input buffer used to update the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]},{"pos":[37112,37141],"content":"The size of the input buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the input buffer.","pos":[0,29]}]},{"pos":[37203,37247],"content":"The stride of the update region in <ph id=\"ph1\">`buffer`</ph>.","needQuote":true,"needEscape":true,"source":"The stride of the update region in `buffer`."},{"pos":[37447,37702],"content":"One or more of the following conditions is true.       <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>bufferSize</code> &lt; 1       <code>stride</code> &lt; 1","needQuote":false,"needEscape":true,"nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceRect</ph><ept id=\"p1\">&lt;/code&gt;</ept> falls outside the bounds of the <bpt id=\"p2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[55,177],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bufferSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> <ph id=\"ph2\">&amp;lt;</ph> 1       <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">stride</ph><ept id=\"p2\">&lt;/code&gt;</ept> <ph id=\"ph4\">&amp;lt;</ph> 1","pos":[184,247],"source":"<code>bufferSize</code> &lt; 1       <code>stride</code> &lt; 1"}]},{"pos":[37806,37890],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[38568,38625],"content":"Updates the pixels in the specified region of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]},{"pos":[38638,39164],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.      > [!NOTE] >  Use this overload in partial trust.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Call the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A&gt; method to update the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; automatically with the contents of <ph id=\"ph1\">`sourceBuffer`</ph>.","pos":[0,199],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`."},{"content":"Calling this method is the equivalent of using the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; workflow described in the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; class remarks.","pos":[200,469],"source":" Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Use this overload in partial trust.","pos":[475,523],"source":"      > [!NOTE] >  Use this overload in partial trust."}]},{"pos":[39425,39465],"content":"The rectangle in <ph id=\"ph1\">`sourceBuffer`</ph> to copy.","needQuote":true,"needEscape":true,"source":"The rectangle in `sourceBuffer` to copy."},{"pos":[39533,39576],"content":"The input buffer used to update the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]},{"pos":[39650,39691],"content":"The stride of the input buffer, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stride of the input buffer, in bytes.","pos":[0,41]}]},{"pos":[39759,39830],"content":"The destination x-coordinate of the left-most pixel in the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","pos":[0,71]}]},{"pos":[39898,39968],"content":"The destination y-coordinate of the top-most pixel in the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","pos":[0,70]}]},{"pos":[40168,40557],"content":"One or more of the following conditions is true.       <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>sourceBufferStride</code> &lt; 1","needQuote":false,"needEscape":true,"nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceRect</ph><ept id=\"p1\">&lt;/code&gt;</ept> falls outside the bounds of the <bpt id=\"p2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[55,177],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">destinationX</ph><ept id=\"p1\">&lt;/code&gt;</ept> or <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">destinationY</ph><ept id=\"p2\">&lt;/code&gt;</ept> is outside the bounds of the <bpt id=\"p3\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p3\">&lt;/xref&gt;</ept>.","pos":[184,334],"source":"<code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceBufferStride</ph><ept id=\"p1\">&lt;/code&gt;</ept> <ph id=\"ph2\">&amp;lt;</ph> 1","pos":[341,379],"source":"<code>sourceBufferStride</code> &lt; 1"}]},{"pos":[40661,40751],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>sourceBuffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[40846,40943],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> has a rank other than 1 or 2, or its length is less than or equal to 0.","needQuote":true,"needEscape":true,"source":"<code>sourceBuffer</code> has a rank other than 1 or 2, or its length is less than or equal to 0."},{"pos":[41670,41727],"content":"Updates the pixels in the specified region of the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]},{"pos":[41740,42365],"content":"Call the WritePixels method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Call the WritePixels method to update the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; automatically with the contents of <ph id=\"ph1\">`sourceBuffer`</ph>.","pos":[0,144],"source":"Call the WritePixels method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`."},{"content":"Calling this method is the equivalent of using the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt; and &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt; workflow described in the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt; class remarks.","pos":[145,414],"source":" Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  In partial trust, use the &lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt; overload.","pos":[420,622],"source":"      > [!NOTE] >  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]},{"pos":[42649,42689],"content":"The rectangle in <ph id=\"ph1\">`sourceBuffer`</ph> to copy.","needQuote":true,"needEscape":true,"source":"The rectangle in `sourceBuffer` to copy."},{"pos":[42758,42801],"content":"The input buffer used to update the bitmap.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]},{"pos":[42873,42902],"content":"The size of the input buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the input buffer.","pos":[0,29]}]},{"pos":[42976,43017],"content":"The stride of the input buffer, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stride of the input buffer, in bytes.","pos":[0,41]}]},{"pos":[43085,43156],"content":"The destination x-coordinate of the left-most pixel in the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","pos":[0,71]}]},{"pos":[43224,43294],"content":"The destination y-coordinate of the top-most pixel in the back buffer.","needQuote":true,"needEscape":true,"nodes":[{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","pos":[0,70]}]},{"pos":[43494,43928],"content":"One or more of the following conditions is true.       <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.       <code>sourceBufferSize</code> &lt; 1       <code>sourceBufferStride</code> &lt; 1","needQuote":false,"needEscape":true,"nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceRect</ph><ept id=\"p1\">&lt;/code&gt;</ept> falls outside the bounds of the <bpt id=\"p2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[55,177],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">destinationX</ph><ept id=\"p1\">&lt;/code&gt;</ept> or <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">destinationY</ph><ept id=\"p2\">&lt;/code&gt;</ept> is outside the bounds of the <bpt id=\"p3\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;</bpt><ept id=\"p3\">&lt;/xref&gt;</ept>.","pos":[184,334],"source":"<code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceBufferSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> <ph id=\"ph2\">&amp;lt;</ph> 1       <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">sourceBufferStride</ph><ept id=\"p2\">&lt;/code&gt;</ept> <ph id=\"ph4\">&amp;lt;</ph> 1","pos":[341,422],"source":"<code>sourceBufferSize</code> &lt; 1       <code>sourceBufferStride</code> &lt; 1"}]},{"pos":[44032,44122],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>sourceBuffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Windows.Media.Imaging.WriteableBitmap\n  id: WriteableBitmap\n  children:\n  - System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  - System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  - System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  - System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  - System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  - System.Windows.Media.Imaging.WriteableBitmap.Clone\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  - System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  - System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.Lock\n  - System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  - System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  langs:\n  - csharp\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap\n  fullName: System.Windows.Media.Imaging.WriteableBitmap\n  type: Class\n  summary: Provides a <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that can be written to and updated.\n  remarks: \"Use the WriteableBitmap class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.  \\n  \\n The WriteableBitmap class uses two buffers. The *back buffer* is allocated in system memory and accumulates content that is not currently displayed. The *front buffer* is allocated in system memory and contains the content that is currently displayed. The rendering system copies the front buffer to video memory for display.  \\n  \\n Two threads use these buffers. The *user interface (UI) thread* generates the UI but does not present it to the screen. The UI thread responds to user input, timers, and other events. An application can have multiple UI threads. The *render thread* composes and renders changes from the UI thread. There is only one render thread per application.  \\n  \\n The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.  \\n  \\n Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.  \\n  \\n For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.  \\n  \\n1.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.  \\n  \\n2.  Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.  \\n  \\n3.  Write changes to the back buffer. Other threads may write changes to the back buffer when the WriteableBitmap is locked.  \\n  \\n4.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.  \\n  \\n5.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.  \\n  \\n When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \\\"tearing\\\".\"\n  example:\n  - \"The following example demonstrates how a WriteableBitmap can be used as the source of an <xref:System.Windows.Controls.Image> to draw pixels when the mouse moves.  \\n  \\n [!code-cs[WriteableBitmap2#WriteableBitmapFullPage](~/add/codesnippet/csharp/WriteableBitmapDemo/Program.cs#writeablebitmapfullpage)]\"\n  syntax:\n    content: 'public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource'\n  inheritance:\n  - System.Object\n  - System.Windows.Threading.DispatcherObject\n  - System.Windows.DependencyObject\n  - System.Windows.Freezable\n  - System.Windows.Media.Animation.Animatable\n  - System.Windows.Media.ImageSource\n  - System.Windows.Media.Imaging.BitmapSource\n  implements: []\n  inheritedMembers:\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)\n  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.DependencyObjectType\n  - System.Windows.DependencyObject.Equals(System.Object)\n  - System.Windows.DependencyObject.GetHashCode\n  - System.Windows.DependencyObject.GetLocalValueEnumerator\n  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.IsSealed\n  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)\n  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)\n  - System.Windows.Freezable.CanFreeze\n  - System.Windows.Freezable.Changed\n  - System.Windows.Freezable.CreateInstance\n  - System.Windows.Freezable.Freeze\n  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)\n  - System.Windows.Freezable.GetAsFrozen\n  - System.Windows.Freezable.GetCurrentValueAsFrozen\n  - System.Windows.Freezable.IsFrozen\n  - System.Windows.Freezable.OnChanged\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)\n  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\n  - System.Windows.Freezable.ReadPreamble\n  - System.Windows.Freezable.WritePostscript\n  - System.Windows.Freezable.WritePreamble\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)\n  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties\n  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)\n  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)\n  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)\n  - System.Windows.Media.ImageSource.ToString\n  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)\n  - System.Windows.Media.Imaging.BitmapSource.CheckIfSiteOfOrigin\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.Array,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.DecodeFailed\n  - System.Windows.Media.Imaging.BitmapSource.DownloadCompleted\n  - System.Windows.Media.Imaging.BitmapSource.DownloadFailed\n  - System.Windows.Media.Imaging.BitmapSource.DownloadProgress\n  - System.Windows.Media.Imaging.BitmapSource.DpiX\n  - System.Windows.Media.Imaging.BitmapSource.DpiY\n  - System.Windows.Media.Imaging.BitmapSource.Format\n  - System.Windows.Media.Imaging.BitmapSource.Height\n  - System.Windows.Media.Imaging.BitmapSource.IsDownloading\n  - System.Windows.Media.Imaging.BitmapSource.Metadata\n  - System.Windows.Media.Imaging.BitmapSource.Palette\n  - System.Windows.Media.Imaging.BitmapSource.PixelHeight\n  - System.Windows.Media.Imaging.BitmapSource.PixelWidth\n  - System.Windows.Media.Imaging.BitmapSource.Width\n  - System.Windows.Threading.DispatcherObject.CheckAccess\n  - System.Windows.Threading.DispatcherObject.Dispatcher\n  - System.Windows.Threading.DispatcherObject.VerifyAccess\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  id: '#ctor(System.Windows.Media.Imaging.BitmapSource)'\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WriteableBitmap(BitmapSource)\n  nameWithType: WriteableBitmap.WriteableBitmap(BitmapSource)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WriteableBitmap(BitmapSource)\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class using the given <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref>.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.  \\n  \\n If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.\"\n  syntax:\n    content: public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);\n    parameters:\n    - id: source\n      type: System.Windows.Media.Imaging.BitmapSource\n      description: The <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> to use for initialization.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  id: '#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)'\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n  nameWithType: WriteableBitmap.WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class with the specified parameters.\n  remarks: The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. These formats are natively supported and do not require a format conversion. Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.\n  syntax:\n    content: public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);\n    parameters:\n    - id: pixelWidth\n      type: System.Int32\n      description: The desired width of the bitmap.\n    - id: pixelHeight\n      type: System.Int32\n      description: The desired height of the bitmap.\n    - id: dpiX\n      type: System.Double\n      description: The horizontal [!INCLUDE[TLA#tla_dpi](~/add/includes/ajax-current-ext-md.md)] of the bitmap.\n    - id: dpiY\n      type: System.Double\n      description: The vertical [!INCLUDE[TLA#tla_dpi](../Token/TLA%23tla_dpi_md.md)] of the bitmap.\n    - id: pixelFormat\n      type: System.Windows.Media.PixelFormat\n      description: The <xref href=\"System.Windows.Media.PixelFormat\"></xref> of the bitmap.\n    - id: palette\n      type: System.Windows.Media.Imaging.BitmapPalette\n      description: The <xref href=\"System.Windows.Media.Imaging.BitmapPalette\"></xref> of the bitmap.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  id: AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: WriteableBitmap.AddDirtyRect(Int32Rect)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(Int32Rect)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Specifies the area of the bitmap that changed.\n  remarks: \"Call the AddDirtyRect method to indicate changes your code has made to the back buffer.  \\n  \\n When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.  \\n  \\n Call the AddDirtyRect method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.\"\n  example:\n  - \"The following code example shows how to specify the area of the back buffer that changed by using the AddDirtyRect method.  \\n  \\n [!code-cs[WriteableBitmap2#2](~/add/codesnippet/csharp/WriteableBitmapDemo/Program.cs#2)]\"\n  syntax:\n    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);\n    parameters:\n    - id: dirtyRect\n      type: System.Windows.Int32Rect\n      description: An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed. Dimensions are in pixels.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The bitmap has not been locked by a call to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock*> or <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock*> methods.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>dirtyRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  id: BackBuffer\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Gets a pointer to the back buffer.\n  remarks: \"The back buffer contains the bitmap contents in the pixel format requested by the user.  \\n  \\n Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.  \\n  \\n The address of the back buffer does not change.  \\n  \\n## Thread Safety  \\n You can pass the BackBuffer pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.\"\n  syntax:\n    content: public IntPtr BackBuffer { get; }\n    return:\n      type: System.IntPtr\n      description: An <xref:System.IntPtr> that points to the base address of the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  id: BackBufferStride\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Gets a value indicating the number of bytes in a single row of pixel data.\n  syntax:\n    content: public int BackBufferStride { get; }\n    return:\n      type: System.Int32\n      description: An integer indicating the number of bytes in a single row of pixel data.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone\n  id: Clone\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Clone()\n  nameWithType: WriteableBitmap.Clone()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Clone()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Media.Imaging.WriteableBitmap Clone ();\n    parameters: []\n    return:\n      type: System.Windows.Media.Imaging.WriteableBitmap\n      description: A modifiable clone of the current object. The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true.\" name=\"true.\" href=\"\"></xref>\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Clone*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  id: CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  id: CloneCurrentValue\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCurrentValue()\n  nameWithType: WriteableBitmap.CloneCurrentValue()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();\n    parameters: []\n    return:\n      type: System.Windows.Media.Imaging.WriteableBitmap\n      description: A modifiable clone of the current object. The cloned object's <xref:System.Windows.Freezable.IsFrozen*> property will be <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> even if the source's <xref:System.Windows.Freezable.IsFrozen*> property was <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  id: CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCurrentValueCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  id: CreateInstanceCore\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CreateInstanceCore()\n  nameWithType: WriteableBitmap.CreateInstanceCore()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override System.Windows.Freezable CreateInstanceCore ();\n    parameters: []\n    return:\n      type: System.Windows.Freezable\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  id: FreezeCore(System.Boolean)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: FreezeCore(Boolean)\n  nameWithType: WriteableBitmap.FreezeCore(Boolean)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(Boolean)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override bool FreezeCore (bool isChecking);\n    parameters:\n    - id: isChecking\n      type: System.Boolean\n      description: To be added.\n    return:\n      type: System.Boolean\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  id: GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetAsFrozenCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: To be added.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock\n  id: Lock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Lock()\n  nameWithType: WriteableBitmap.Lock()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Lock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Reserves the back buffer for updates.\n  remarks: \"The Lock method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.  \\n  \\n You can use the Lock method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.  \\n  \\n The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.\"\n  example:\n  - \"The following code example shows how to reserve the back buffer by using the Lock method.  \\n  \\n [!code-cs[WriteableBitmap2#2](~/add/codesnippet/csharp/WriteableBitmapDemo/Program.cs#2)]\"\n  syntax:\n    content: public void Lock ();\n    parameters: []\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Lock*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  id: TryLock(System.Windows.Duration)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: TryLock(Duration)\n  nameWithType: WriteableBitmap.TryLock(Duration)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.TryLock(Duration)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Attempts to lock the bitmap, waiting for no longer than the specified length of time.\n  remarks: When a lock is acquired, the behavior of the TryLock method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.\n  syntax:\n    content: public bool TryLock (System.Windows.Duration timeout);\n    parameters:\n    - id: timeout\n      type: System.Windows.Duration\n      description: A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait. A value of 0 returns immediately. A value of <xref:System.Windows.Duration.Forever*> blocks indefinitely.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the lock was acquired; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.TryLock*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is set to <xref:System.Windows.Duration.Automatic*>.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  id: Unlock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Unlock()\n  nameWithType: WriteableBitmap.Unlock()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Unlock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Releases the back buffer to make it available for display.\n  remarks: The Unlock method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.\n  example:\n  - \"The following code example shows how to release the back buffer by using the Unlock method.  \\n  \\n [!code-cs[WriteableBitmap2#2](~/add/codesnippet/csharp/WriteableBitmapDemo/Program.cs#2)]\"\n  syntax:\n    content: public void Unlock ();\n    parameters: []\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Unlock*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The bitmap has not been locked by a call to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock*> or <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock*> methods.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect,Array,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  example:\n  - \"The following code example shows how to update a pixel in the back buffer by using the WritePixels method.  \\n  \\n [!code-cs[WriteableBitmap2#3](~/add/codesnippet/csharp/WriteableBitmapDemo/Program.cs#3)]\"\n  syntax:\n    content: public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.\n    - id: pixels\n      type: System.Array\n      description: The pixel array used to update the bitmap.\n    - id: stride\n      type: System.Int32\n      description: The stride of the update region in `pixels`.\n    - id: offset\n      type: System.Int32\n      description: The input buffer offset.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>stride</code> &lt; 1  \\n  \\n <code>offset</code> &lt; 0\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>pixels</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>pixels</code> has a rank other than 1 or 2, or its length is less than or equal to 0.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect,IntPtr,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  syntax:\n    content: public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.\n    - id: buffer\n      type: System.IntPtr\n      description: The input buffer used to update the bitmap.\n    - id: bufferSize\n      type: System.Int32\n      description: The size of the input buffer.\n    - id: stride\n      type: System.Int32\n      description: The stride of the update region in `buffer`.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>bufferSize</code> &lt; 1  \\n  \\n <code>stride</code> &lt; 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \\n  \\n> [!NOTE]\\n>  Use this overload in partial trust.\"\n  syntax:\n    content: public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle in `sourceBuffer` to copy.\n    - id: sourceBuffer\n      type: System.Array\n      description: The input buffer used to update the bitmap.\n    - id: sourceBufferStride\n      type: System.Int32\n      description: The stride of the input buffer, in bytes.\n    - id: destinationX\n      type: System.Int32\n      description: The destination x-coordinate of the left-most pixel in the back buffer.\n    - id: destinationY\n      type: System.Int32\n      description: The destination y-coordinate of the top-most pixel in the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>sourceBufferStride</code> &lt; 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>sourceBuffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>sourceBuffer</code> has a rank other than 1 or 2, or its length is less than or equal to 0.\n  platform:\n  - net462\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"Call the WritePixels method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  syntax:\n    content: public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle in `sourceBuffer` to copy.\n    - id: sourceBuffer\n      type: System.IntPtr\n      description: The input buffer used to update the bitmap.\n    - id: sourceBufferSize\n      type: System.Int32\n      description: The size of the input buffer.\n    - id: sourceBufferStride\n      type: System.Int32\n      description: The stride of the input buffer, in bytes.\n    - id: destinationX\n      type: System.Int32\n      description: The destination x-coordinate of the left-most pixel in the back buffer.\n    - id: destinationY\n      type: System.Int32\n      description: The destination y-coordinate of the top-most pixel in the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>sourceBufferSize</code> &lt; 1  \\n  \\n <code>sourceBufferStride</code> &lt; 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>sourceBuffer</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\nreferences:\n- uid: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: System.Windows.Media.Imaging.BitmapSource\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap(BitmapSource)\n  nameWithType: WriteableBitmap.WriteableBitmap(BitmapSource)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WriteableBitmap(BitmapSource)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n  nameWithType: WriteableBitmap.WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WriteableBitmap(Int32,Int32,Double,Double,PixelFormat,BitmapPalette)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Double\n  parent: System\n  isExternal: true\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: System.Windows.Media.PixelFormat\n  parent: System.Windows.Media\n  isExternal: false\n  name: PixelFormat\n  nameWithType: PixelFormat\n  fullName: System.Windows.Media.PixelFormat\n- uid: System.Windows.Media.Imaging.BitmapPalette\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: BitmapPalette\n  nameWithType: BitmapPalette\n  fullName: System.Windows.Media.Imaging.BitmapPalette\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: WriteableBitmap.AddDirtyRect(Int32Rect)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(Int32Rect)\n- uid: System.Windows.Int32Rect\n  parent: System.Windows\n  isExternal: false\n  name: Int32Rect\n  nameWithType: Int32Rect\n  fullName: System.Windows.Int32Rect\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n- uid: System.IntPtr\n  parent: System\n  isExternal: true\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Clone()\n  nameWithType: WriteableBitmap.Clone()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Clone()\n- uid: System.Windows.Media.Imaging.WriteableBitmap\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap\n  fullName: System.Windows.Media.Imaging.WriteableBitmap\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(Freezable)\n- uid: System.Windows.Freezable\n  parent: System.Windows\n  isExternal: false\n  name: Freezable\n  nameWithType: Freezable\n  fullName: System.Windows.Freezable\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValue()\n  nameWithType: WriteableBitmap.CloneCurrentValue()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCurrentValueCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CreateInstanceCore()\n  nameWithType: WriteableBitmap.CreateInstanceCore()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: FreezeCore(Boolean)\n  nameWithType: WriteableBitmap.FreezeCore(Boolean)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetAsFrozenCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Lock()\n  nameWithType: WriteableBitmap.Lock()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Lock()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: TryLock(Duration)\n  nameWithType: WriteableBitmap.TryLock(Duration)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.TryLock(Duration)\n- uid: System.Windows.Duration\n  parent: System.Windows\n  isExternal: false\n  name: Duration\n  nameWithType: Duration\n  fullName: System.Windows.Duration\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Unlock()\n  nameWithType: WriteableBitmap.Unlock()\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.Unlock()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect,Array,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32)\n- uid: System.Array\n  parent: System\n  isExternal: true\n  name: Array\n  nameWithType: Array\n  fullName: System.Array\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect,IntPtr,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,Array,Int32,Int32,Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n  fullName: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(Int32Rect,IntPtr,Int32,Int32,Int32,Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap.WriteableBitmap\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: AddDirtyRect\n  nameWithType: WriteableBitmap.AddDirtyRect\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Clone\n  nameWithType: WriteableBitmap.Clone\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCore\n  nameWithType: WriteableBitmap.CloneCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValue\n  nameWithType: WriteableBitmap.CloneCurrentValue\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValueCore\n  nameWithType: WriteableBitmap.CloneCurrentValueCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CreateInstanceCore\n  nameWithType: WriteableBitmap.CreateInstanceCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: FreezeCore\n  nameWithType: WriteableBitmap.FreezeCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetAsFrozenCore\n  nameWithType: WriteableBitmap.GetAsFrozenCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Lock\n  nameWithType: WriteableBitmap.Lock\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: TryLock\n  nameWithType: WriteableBitmap.TryLock\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Unlock\n  nameWithType: WriteableBitmap.Unlock\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels\n  nameWithType: WriteableBitmap.WritePixels\n"}