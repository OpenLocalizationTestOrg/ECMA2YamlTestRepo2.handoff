{"nodes":[{"pos":[2878,2922],"content":"Represents a symbol writer for managed code.","needQuote":true,"needEscape":true,"nodes":[{"content":"Represents a symbol writer for managed code.","pos":[0,44]}]},{"pos":[2935,3284],"content":"The ISymbolWriter interface provides methods that define documents, sequence points, lexical scopes, and variables.      > [!NOTE] >  This interface is the managed counterpart of the `ISymUnmanagedWriter` interface, which is one of the unmanaged symbol store interfaces that provides an alternative way to read and write debug symbol information.","needQuote":false,"needEscape":true,"nodes":[{"content":"The ISymbolWriter interface provides methods that define documents, sequence points, lexical scopes, and variables.","pos":[0,115]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  This interface is the managed counterpart of the <ph id=\"ph2\">`ISymUnmanagedWriter`</ph> interface, which is one of the unmanaged symbol store interfaces that provides an alternative way to read and write debug symbol information.","pos":[121,346],"source":"      > [!NOTE] >  This interface is the managed counterpart of the `ISymUnmanagedWriter` interface, which is one of the unmanaged symbol store interfaces that provides an alternative way to read and write debug symbol information."}]},{"pos":[3807,3924],"content":"Closes <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and commits the symbols to the symbol store.","needQuote":true,"needEscape":true,"source":"Closes <xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"></xref> and commits the symbols to the symbol store."},{"pos":[3936,4041],"content":"After this call, <xref:System.Diagnostics.SymbolStore.ISymbolWriter> becomes invalid for further updates.","needQuote":true,"needEscape":true,"nodes":[{"content":"After this call, &lt;xref:System.Diagnostics.SymbolStore.ISymbolWriter&gt; becomes invalid for further updates.","pos":[0,105],"source":"After this call, <xref:System.Diagnostics.SymbolStore.ISymbolWriter> becomes invalid for further updates."}]},{"pos":[4601,4627],"content":"Closes the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the current method.","pos":[0,26]}]},{"pos":[4639,4707],"content":"After a method is closed, you cannot define a symbol from within it.","needQuote":true,"needEscape":true,"nodes":[{"content":"After a method is closed, you cannot define a symbol from within it.","pos":[0,68]}]},{"pos":[5294,5327],"content":"Closes the most recent namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the most recent namespace.","pos":[0,33]}]},{"pos":[5943,5976],"content":"Closes the current lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the current lexical scope.","pos":[0,33]}]},{"pos":[5988,6057],"content":"After a scope is closed, you cannot define a variable from within it.","needQuote":true,"needEscape":true,"nodes":[{"content":"After a scope is closed, you cannot define a variable from within it.","pos":[0,69]}]},{"pos":[6201,6251],"content":"The points past the last instruction in the scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The points past the last instruction in the scope.","pos":[0,50]}]},{"pos":[6932,6958],"content":"Defines a source document.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a source document.","pos":[0,26]}]},{"pos":[7201,7238],"content":"The URL that identifies the document.","needQuote":true,"needEscape":true,"nodes":[{"content":"The URL that identifies the document.","pos":[0,37]}]},{"pos":[7301,7365],"content":"The document language. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document language. This parameter can be <xref:System.Guid>.","pos":[0,64],"nodes":[{"content":"The document language.","pos":[0,22]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[23,64],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[7434,7529],"content":"The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.","pos":[0,95],"nodes":[{"content":"The identity of the vendor for the document language.","pos":[0,53]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[54,95],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[7596,7663],"content":"The type of the document. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The type of the document. This parameter can be <xref:System.Guid>.","pos":[0,67],"nodes":[{"content":"The type of the document.","pos":[0,25]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[26,67],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[7760,7800],"content":"The object that represents the document.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that represents the document.","pos":[0,40]}]},{"pos":[8909,8953],"content":"Defines a field in a type or a global field.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a field in a type or a global field.","pos":[0,44]}]},{"pos":[8965,9102],"content":"The DefineField method defines a single variable that is not within a method by using specified fields in classes, bit fields, and so on.","needQuote":true,"needEscape":true,"nodes":[{"content":"The DefineField method defines a single variable that is not within a method by using specified fields in classes, bit fields, and so on.","pos":[0,137]}]},{"pos":[9476,9510],"content":"The metadata type or method token.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata type or method token.","pos":[0,34]}]},{"pos":[9571,9586],"content":"The field name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The field name.","pos":[0,15]}]},{"pos":[9673,9719],"content":"A bitwise combination of the field attributes.","needQuote":true,"needEscape":true,"nodes":[{"content":"A bitwise combination of the field attributes.","pos":[0,46]}]},{"pos":[9785,9805],"content":"The field signature.","needQuote":true,"needEscape":true,"nodes":[{"content":"The field signature.","pos":[0,20]}]},{"pos":[9902,9944],"content":"The address types for <ph id=\"ph1\">`addr1`</ph> and <ph id=\"ph2\">`addr2`</ph>.","needQuote":true,"needEscape":true,"source":"The address types for `addr1` and `addr2`."},{"pos":[10005,10051],"content":"The first address for the field specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The first address for the field specification.","pos":[0,46]}]},{"pos":[10112,10159],"content":"The second address for the field specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The second address for the field specification.","pos":[0,47]}]},{"pos":[10220,10266],"content":"The third address for the field specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The third address for the field specification.","pos":[0,46]}]},{"pos":[11295,11328],"content":"Defines a single global variable.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a single global variable.","pos":[0,33]}]},{"pos":[11629,11654],"content":"The global variable name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The global variable name.","pos":[0,25]}]},{"pos":[11741,11797],"content":"A bitwise combination of the global variable attributes.","needQuote":true,"needEscape":true,"nodes":[{"content":"A bitwise combination of the global variable attributes.","pos":[0,56]}]},{"pos":[11863,11893],"content":"The global variable signature.","needQuote":true,"needEscape":true,"nodes":[{"content":"The global variable signature.","pos":[0,30]}]},{"pos":[11990,12042],"content":"The address types for <ph id=\"ph1\">`addr1`</ph>, <ph id=\"ph2\">`addr2`</ph>, and <ph id=\"ph3\">`addr3`</ph>.","needQuote":true,"needEscape":true,"source":"The address types for `addr1`, `addr2`, and `addr3`."},{"pos":[12103,12159],"content":"The first address for the global variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The first address for the global variable specification.","pos":[0,56]}]},{"pos":[12220,12277],"content":"The second address for the global variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The second address for the global variable specification.","pos":[0,57]}]},{"pos":[12338,12394],"content":"The third address for the global variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The third address for the global variable specification.","pos":[0,56]}]},{"pos":[13515,13570],"content":"Defines a single variable in the current lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a single variable in the current lexical scope.","pos":[0,55]}]},{"pos":[13583,14044],"content":"The `startOffset` and `endOffset` parameters are optional. If their value is zero, they are ignored and the variable is defined throughout the entire scope. If their value is nonzero, the variable falls within the offsets of the current scope.       You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope. (In this case, start and end offsets must not overlap.)","needQuote":false,"needEscape":true,"nodes":[{"content":"The <ph id=\"ph1\">`startOffset`</ph> and <ph id=\"ph2\">`endOffset`</ph> parameters are optional.","pos":[0,58],"source":"The `startOffset` and `endOffset` parameters are optional."},{"content":"If their value is zero, they are ignored and the variable is defined throughout the entire scope.","pos":[59,156]},{"content":"If their value is nonzero, the variable falls within the offsets of the current scope.","pos":[157,243]},{"content":"You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope.","pos":[250,403]},{"content":"(In this case, start and end offsets must not overlap.)","pos":[404,459]}]},{"pos":[14377,14401],"content":"The local variable name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The local variable name.","pos":[0,24]}]},{"pos":[14488,14543],"content":"A bitwise combination of the local variable attributes.","needQuote":true,"needEscape":true,"nodes":[{"content":"A bitwise combination of the local variable attributes.","pos":[0,55]}]},{"pos":[14609,14638],"content":"The local variable signature.","needQuote":true,"needEscape":true,"nodes":[{"content":"The local variable signature.","pos":[0,29]}]},{"pos":[14735,14787],"content":"The address types for <ph id=\"ph1\">`addr1`</ph>, <ph id=\"ph2\">`addr2`</ph>, and <ph id=\"ph3\">`addr3`</ph>.","needQuote":true,"needEscape":true,"source":"The address types for `addr1`, `addr2`, and `addr3`."},{"pos":[14848,14903],"content":"The first address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The first address for the local variable specification.","pos":[0,55]}]},{"pos":[14964,15020],"content":"The second address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The second address for the local variable specification.","pos":[0,56]}]},{"pos":[15081,15136],"content":"The third address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The third address for the local variable specification.","pos":[0,55]}]},{"pos":[15203,15424],"content":"The start offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The start offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.","pos":[0,221],"nodes":[{"content":"The start offset for the variable.","pos":[0,34]},{"content":"If this parameter is zero, it is ignored and the variable is defined throughout the entire scope.","pos":[35,132]},{"content":"If the parameter is nonzero, the variable falls within the offsets of the current scope.","pos":[133,221]}]}]},{"pos":[15489,15708],"content":"The end offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The end offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.","pos":[0,219],"nodes":[{"content":"The end offset for the variable.","pos":[0,32]},{"content":"If this parameter is zero, it is ignored and the variable is defined throughout the entire scope.","pos":[33,130]},{"content":"If the parameter is nonzero, the variable falls within the offsets of the current scope.","pos":[131,219]}]}]},{"pos":[16735,16874],"content":"Defines a single parameter in the current method. The type of each parameter is taken from its position within the signature of the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a single parameter in the current method. The type of each parameter is taken from its position within the signature of the method.","pos":[0,139],"nodes":[{"content":"Defines a single parameter in the current method.","pos":[0,49]},{"content":"The type of each parameter is taken from its position within the signature of the method.","pos":[50,139]}]}]},{"pos":[16886,17111],"content":"If parameters are defined in the metadata for a given method, you do not have to define them again with calls to this method. Symbol readers need to check for these in the normal metadata first, and then use the symbol store.","needQuote":true,"needEscape":true,"nodes":[{"content":"If parameters are defined in the metadata for a given method, you do not have to define them again with calls to this method. Symbol readers need to check for these in the normal metadata first, and then use the symbol store.","pos":[0,225],"nodes":[{"content":"If parameters are defined in the metadata for a given method, you do not have to define them again with calls to this method.","pos":[0,125]},{"content":"Symbol readers need to check for these in the normal metadata first, and then use the symbol store.","pos":[126,225]}]}]},{"pos":[17407,17426],"content":"The parameter name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The parameter name.","pos":[0,19]}]},{"pos":[17517,17567],"content":"A bitwise combination of the parameter attributes.","needQuote":true,"needEscape":true,"nodes":[{"content":"A bitwise combination of the parameter attributes.","pos":[0,50]}]},{"pos":[17631,17655],"content":"The parameter signature.","needQuote":true,"needEscape":true,"nodes":[{"content":"The parameter signature.","pos":[0,24]}]},{"pos":[17752,17804],"content":"The address types for <ph id=\"ph1\">`addr1`</ph>, <ph id=\"ph2\">`addr2`</ph>, and <ph id=\"ph3\">`addr3`</ph>.","needQuote":true,"needEscape":true,"source":"The address types for `addr1`, `addr2`, and `addr3`."},{"pos":[17865,17915],"content":"The first address for the parameter specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The first address for the parameter specification.","pos":[0,50]}]},{"pos":[17976,18027],"content":"The second address for the parameter specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The second address for the parameter specification.","pos":[0,51]}]},{"pos":[18088,18138],"content":"The third address for the parameter specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The third address for the parameter specification.","pos":[0,50]}]},{"pos":[19130,19191],"content":"Defines a group of sequence points within the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a group of sequence points within the current method.","pos":[0,61]}]},{"pos":[19203,19410],"content":"Each line and each column defines the start of a statement within a method. The arrays should be sorted in increasing order of offsets. The offset is always the offset from the start of the method, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Each line and each column defines the start of a statement within a method. The arrays should be sorted in increasing order of offsets. The offset is always the offset from the start of the method, in bytes.","pos":[0,207],"nodes":[{"content":"Each line and each column defines the start of a statement within a method.","pos":[0,75]},{"content":"The arrays should be sorted in increasing order of offsets.","pos":[76,135]},{"content":"The offset is always the offset from the start of the method, in bytes.","pos":[136,207]}]}]},{"pos":[19728,19796],"content":"The document object for which the sequence points are being defined.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document object for which the sequence points are being defined.","pos":[0,68]}]},{"pos":[19861,19927],"content":"The sequence point offsets measured from the beginning of methods.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence point offsets measured from the beginning of methods.","pos":[0,66]}]},{"pos":[19990,20033],"content":"The document lines for the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document lines for the sequence points.","pos":[0,43]}]},{"pos":[20098,20145],"content":"The document positions for the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document positions for the sequence points.","pos":[0,47]}]},{"pos":[20211,20258],"content":"The document end lines for the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document end lines for the sequence points.","pos":[0,47]}]},{"pos":[20326,20377],"content":"The document end positions for the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document end positions for the sequence points.","pos":[0,51]}]},{"pos":[21034,21097],"content":"Sets the metadata emitter interface to associate with a writer.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the metadata emitter interface to associate with a writer.","pos":[0,63]}]},{"pos":[21109,21279],"content":"Initialize also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods.","needQuote":true,"needEscape":true,"nodes":[{"content":"Initialize also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods.","pos":[0,170],"nodes":[{"content":"Initialize also sets the output file name where the debugging symbols are written.","pos":[0,82]},{"content":"This method can be called only once and must be called before any other writer methods.","pos":[83,170]}]}]},{"pos":[21457,21488],"content":"The metadata emitter interface.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata emitter interface.","pos":[0,31]}]},{"pos":[21553,21762],"content":"The file name for which the debugging symbols are written. Some writers require a file name, and others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.","needQuote":true,"needEscape":true,"nodes":[{"content":"The file name for which the debugging symbols are written. Some writers require a file name, and others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.","pos":[0,209],"nodes":[{"content":"The file name for which the debugging symbols are written.","pos":[0,58]},{"content":"Some writers require a file name, and others do not.","pos":[59,111]},{"content":"If a file name is specified for a writer that does not use file names, this parameter is ignored.","pos":[112,209]}]}]},{"pos":[21830,22043],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> indicates that this is a full rebuild; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> indicates that this is an incremental compilation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> indicates that this is a full rebuild; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> indicates that this is an incremental compilation."},{"pos":[22660,22708],"content":"Opens a method to place symbol information into.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a method to place symbol information into.","pos":[0,48]}]},{"pos":[22720,23002],"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.","pos":[0,282],"nodes":[{"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes.","pos":[0,116]},{"content":"There is an implicit lexical scope around the entire method.","pos":[117,177]},{"content":"Reopening a method that has been previously closed erases any previously defined symbols for the method.","pos":[178,282]}]}]},{"pos":[23209,23256],"content":"The metadata token for the method to be opened.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for the method to be opened.","pos":[0,47]}]},{"pos":[23815,23837],"content":"Opens a new namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a new namespace.","pos":[0,22]}]},{"pos":[23849,23959],"content":"Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.","needQuote":true,"needEscape":true,"nodes":[{"content":"Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.","pos":[0,110],"nodes":[{"content":"Call this method before defining methods or variables that exist within a namespace.","pos":[0,84]},{"content":"Namespaces can be nested.","pos":[85,110]}]}]},{"pos":[24100,24130],"content":"The name of the new namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"The name of the new namespace.","pos":[0,30]}]},{"pos":[24667,24715],"content":"Opens a new lexical scope in the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a new lexical scope in the current method.","pos":[0,48]}]},{"pos":[24728,24937],"content":"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.       Scope identifiers are valid only in the current method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.       Scope identifiers are valid only in the current method.","pos":[0,207],"nodes":[{"content":"This scope becomes the new current scope and is pushed onto a stack of scopes.","pos":[0,78]},{"content":"Scopes must form a hierarchy.","pos":[79,108]},{"content":"Siblings are not allowed to overlap.","pos":[109,145]},{"content":"Scope identifiers are valid only in the current method.","pos":[152,207]}]}]},{"pos":[25084,25185],"content":"The offset, in bytes, from the beginning of the method to the first instruction in the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The offset, in bytes, from the beginning of the method to the first instruction in the lexical scope.","pos":[0,101]}]},{"pos":[25242,25604],"content":"An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope*> are ignored. A scope identifier is valid only in the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"An opaque scope identifier that can be used with &lt;xref:System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange<bpt id=\"p1\">*</bpt>&gt; to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and &lt;xref:System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope<ept id=\"p1\">*</ept>&gt; are ignored.","pos":[0,306],"source":"An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope*> are ignored."},{"content":"A scope identifier is valid only in the current method.","pos":[307,362]}]},{"pos":[26668,26859],"content":"Specifies the true start and end of a method within a source file. Use SetMethodSourceRange to specify the extent of a method, independent of the sequence points that exist within the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies the true start and end of a method within a source file. Use SetMethodSourceRange to specify the extent of a method, independent of the sequence points that exist within the method.","pos":[0,191],"nodes":[{"content":"Specifies the true start and end of a method within a source file.","pos":[0,66]},{"content":"Use SetMethodSourceRange to specify the extent of a method, independent of the sequence points that exist within the method.","pos":[67,191]}]}]},{"pos":[27221,27270],"content":"The document that contains the starting position.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document that contains the starting position.","pos":[0,49]}]},{"pos":[27335,27360],"content":"The starting line number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The starting line number.","pos":[0,25]}]},{"pos":[27427,27447],"content":"The starting column.","needQuote":true,"needEscape":true,"nodes":[{"content":"The starting column.","pos":[0,20]}]},{"pos":[27549,27596],"content":"The document that contains the ending position.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document that contains the ending position.","pos":[0,47]}]},{"pos":[27659,27682],"content":"The ending line number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The ending line number.","pos":[0,23]}]},{"pos":[27747,27772],"content":"The ending column number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The ending column number.","pos":[0,25]}]},{"pos":[28424,28481],"content":"Defines the offset range for the specified lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines the offset range for the specified lexical scope.","pos":[0,57]}]},{"pos":[28656,28692],"content":"The identifier of the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The identifier of the lexical scope.","pos":[0,36]}]},{"pos":[28759,28813],"content":"The byte offset of the beginning of the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The byte offset of the beginning of the lexical scope.","pos":[0,54]}]},{"pos":[28878,28926],"content":"The byte offset of the end of the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The byte offset of the end of the lexical scope.","pos":[0,48]}]},{"pos":[29669,29744],"content":"Defines an attribute when given the attribute name and the attribute value.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines an attribute when given the attribute name and the attribute value.","pos":[0,75]}]},{"pos":[29756,29867],"content":"The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.","needQuote":true,"needEscape":true,"nodes":[{"content":"The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.","pos":[0,111]}]},{"pos":[30105,30165],"content":"The metadata token for which the attribute is being defined.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for which the attribute is being defined.","pos":[0,60]}]},{"pos":[30226,30245],"content":"The attribute name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The attribute name.","pos":[0,19]}]},{"pos":[30306,30326],"content":"The attribute value.","needQuote":true,"needEscape":true,"nodes":[{"content":"The attribute value.","pos":[0,20]}]},{"pos":[30920,31173],"content":"Sets the underlying <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_ISymUnmanagedWriter\" name=\"ISymUnmanagedWriter\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> (the corresponding unmanaged interface) that a managed <bpt id=\"p2\">&lt;xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> uses to emit symbols.","needQuote":true,"needEscape":true,"source":"Sets the underlying <xref uid=\"langword_csharp_ISymUnmanagedWriter\" name=\"ISymUnmanagedWriter\" href=\"\"></xref> (the corresponding unmanaged interface) that a managed <xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"></xref> uses to emit symbols."},{"pos":[31185,31409],"content":"The underlying `ISymUnmanagedWriter` (the corresponding unmanaged interface) represents a symbol writer for managed code. The interface provides methods for defining documents, sequence points, lexical scopes, and variables.","needQuote":true,"needEscape":true,"nodes":[{"content":"The underlying <ph id=\"ph1\">`ISymUnmanagedWriter`</ph> (the corresponding unmanaged interface) represents a symbol writer for managed code.","pos":[0,121],"source":"The underlying `ISymUnmanagedWriter` (the corresponding unmanaged interface) represents a symbol writer for managed code."},{"content":"The interface provides methods for defining documents, sequence points, lexical scopes, and variables.","pos":[122,224]}]},{"pos":[31580,31636],"content":"A pointer to code that represents the underlying writer.","needQuote":true,"needEscape":true,"nodes":[{"content":"A pointer to code that represents the underlying writer.","pos":[0,56]}]},{"pos":[32297,32374],"content":"Identifies the user-defined method as the entry point for the current module.","needQuote":true,"needEscape":true,"nodes":[{"content":"Identifies the user-defined method as the entry point for the current module.","pos":[0,77]}]},{"pos":[32386,32481],"content":"This is normally your main method, rather than compiler-generated stubs before the main method.","needQuote":true,"needEscape":true,"nodes":[{"content":"This is normally your main method, rather than compiler-generated stubs before the main method.","pos":[0,95]}]},{"pos":[32705,32768],"content":"The metadata token for the method that is the user entry point.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for the method that is the user entry point.","pos":[0,63]}]},{"pos":[33339,33434],"content":"Specifies that the given, fully qualified namespace name is used within the open lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies that the given, fully qualified namespace name is used within the open lexical scope.","pos":[0,95]}]},{"pos":[33446,33602],"content":"Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.","pos":[0,156],"nodes":[{"content":"Closing the current scope prevents this scope from using the namespace.","pos":[0,71]},{"content":"The namespace remains in use in all scopes that inherit from the current open scope.","pos":[72,156]}]}]},{"pos":[33752,33794],"content":"The fully qualified name of the namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"The fully qualified name of the namespace.","pos":[0,42]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter\n  id: ISymbolWriter\n  children:\n  - System.Diagnostics.SymbolStore.ISymbolWriter.Close\n  - System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod\n  - System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace\n  - System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  - System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(System.String)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  - System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(System.IntPtr)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  - System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(System.String)\n  langs:\n  - csharp\n  name: ISymbolWriter\n  nameWithType: ISymbolWriter\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter\n  type: Interface\n  summary: Represents a symbol writer for managed code.\n  remarks: \"The ISymbolWriter interface provides methods that define documents, sequence points, lexical scopes, and variables.  \\n  \\n> [!NOTE]\\n>  This interface is the managed counterpart of the `ISymUnmanagedWriter` interface, which is one of the unmanaged symbol store interfaces that provides an alternative way to read and write debug symbol information.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public interface ISymbolWriter\n  implements: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Close\n  id: Close\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: ISymbolWriter.Close()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.Close()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes <xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"></xref> and commits the symbols to the symbol store.\n  remarks: After this call, <xref:System.Diagnostics.SymbolStore.ISymbolWriter> becomes invalid for further updates.\n  syntax:\n    content: public void Close ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.Close*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod\n  id: CloseMethod\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: CloseMethod()\n  nameWithType: ISymbolWriter.CloseMethod()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the current method.\n  remarks: After a method is closed, you cannot define a symbol from within it.\n  syntax:\n    content: public void CloseMethod ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace\n  id: CloseNamespace\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: CloseNamespace()\n  nameWithType: ISymbolWriter.CloseNamespace()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the most recent namespace.\n  syntax:\n    content: public void CloseNamespace ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(System.Int32)\n  id: CloseScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: CloseScope(Int32)\n  nameWithType: ISymbolWriter.CloseScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the current lexical scope.\n  remarks: After a scope is closed, you cannot define a variable from within it.\n  syntax:\n    content: public void CloseScope (int endOffset);\n    parameters:\n    - id: endOffset\n      type: System.Int32\n      description: The points past the last instruction in the scope.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  id: DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineDocument(String,Guid,Guid,Guid)\n  nameWithType: ISymbolWriter.DefineDocument(String,Guid,Guid,Guid)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(String,Guid,Guid,Guid)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a source document.\n  syntax:\n    content: public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);\n    parameters:\n    - id: url\n      type: System.String\n      description: The URL that identifies the document.\n    - id: language\n      type: System.Guid\n      description: The document language. This parameter can be <xref:System.Guid>.\n    - id: languageVendor\n      type: System.Guid\n      description: The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.\n    - id: documentType\n      type: System.Guid\n      description: The type of the document. This parameter can be <xref:System.Guid>.\n    return:\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The object that represents the document.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a field in a type or a global field.\n  remarks: The DefineField method defines a single variable that is not within a method by using specified fields in classes, bit fields, and so on.\n  syntax:\n    content: public void DefineField (System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: parent\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata type or method token.\n    - id: name\n      type: System.String\n      description: The field name.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: A bitwise combination of the field attributes.\n    - id: signature\n      type: System.Byte[]\n      description: The field signature.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: The address types for `addr1` and `addr2`.\n    - id: addr1\n      type: System.Int32\n      description: The first address for the field specification.\n    - id: addr2\n      type: System.Int32\n      description: The second address for the field specification.\n    - id: addr3\n      type: System.Int32\n      description: The third address for the field specification.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a single global variable.\n  syntax:\n    content: public void DefineGlobalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: name\n      type: System.String\n      description: The global variable name.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: A bitwise combination of the global variable attributes.\n    - id: signature\n      type: System.Byte[]\n      description: The global variable signature.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: The address types for `addr1`, `addr2`, and `addr3`.\n    - id: addr1\n      type: System.Int32\n      description: The first address for the global variable specification.\n    - id: addr2\n      type: System.Int32\n      description: The second address for the global variable specification.\n    - id: addr3\n      type: System.Int32\n      description: The third address for the global variable specification.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  id: DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a single variable in the current lexical scope.\n  remarks: \"The `startOffset` and `endOffset` parameters are optional. If their value is zero, they are ignored and the variable is defined throughout the entire scope. If their value is nonzero, the variable falls within the offsets of the current scope.  \\n  \\n You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope. (In this case, start and end offsets must not overlap.)\"\n  syntax:\n    content: public void DefineLocalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);\n    parameters:\n    - id: name\n      type: System.String\n      description: The local variable name.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: A bitwise combination of the local variable attributes.\n    - id: signature\n      type: System.Byte[]\n      description: The local variable signature.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: The address types for `addr1`, `addr2`, and `addr3`.\n    - id: addr1\n      type: System.Int32\n      description: The first address for the local variable specification.\n    - id: addr2\n      type: System.Int32\n      description: The second address for the local variable specification.\n    - id: addr3\n      type: System.Int32\n      description: The third address for the local variable specification.\n    - id: startOffset\n      type: System.Int32\n      description: The start offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.\n    - id: endOffset\n      type: System.Int32\n      description: The end offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a single parameter in the current method. The type of each parameter is taken from its position within the signature of the method.\n  remarks: If parameters are defined in the metadata for a given method, you do not have to define them again with calls to this method. Symbol readers need to check for these in the normal metadata first, and then use the symbol store.\n  syntax:\n    content: public void DefineParameter (string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: name\n      type: System.String\n      description: The parameter name.\n    - id: attributes\n      type: System.Reflection.ParameterAttributes\n      description: A bitwise combination of the parameter attributes.\n    - id: sequence\n      type: System.Int32\n      description: The parameter signature.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: The address types for `addr1`, `addr2`, and `addr3`.\n    - id: addr1\n      type: System.Int32\n      description: The first address for the parameter specification.\n    - id: addr2\n      type: System.Int32\n      description: The second address for the parameter specification.\n    - id: addr3\n      type: System.Int32\n      description: The third address for the parameter specification.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  id: DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  nameWithType: ISymbolWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a group of sequence points within the current method.\n  remarks: Each line and each column defines the start of a statement within a method. The arrays should be sorted in increasing order of offsets. The offset is always the offset from the start of the method, in bytes.\n  syntax:\n    content: public void DefineSequencePoints (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);\n    parameters:\n    - id: document\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The document object for which the sequence points are being defined.\n    - id: offsets\n      type: System.Int32[]\n      description: The sequence point offsets measured from the beginning of methods.\n    - id: lines\n      type: System.Int32[]\n      description: The document lines for the sequence points.\n    - id: columns\n      type: System.Int32[]\n      description: The document positions for the sequence points.\n    - id: endLines\n      type: System.Int32[]\n      description: The document end lines for the sequence points.\n    - id: endColumns\n      type: System.Int32[]\n      description: The document end positions for the sequence points.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  id: Initialize(System.IntPtr,System.String,System.Boolean)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: Initialize(IntPtr,String,Boolean)\n  nameWithType: ISymbolWriter.Initialize(IntPtr,String,Boolean)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(IntPtr,String,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Sets the metadata emitter interface to associate with a writer.\n  remarks: Initialize also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods.\n  syntax:\n    content: public void Initialize (IntPtr emitter, string filename, bool fFullBuild);\n    parameters:\n    - id: emitter\n      type: System.IntPtr\n      description: The metadata emitter interface.\n    - id: filename\n      type: System.String\n      description: The file name for which the debugging symbols are written. Some writers require a file name, and others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.\n    - id: fFullBuild\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> indicates that this is a full rebuild; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> indicates that this is an incremental compilation.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  id: OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: OpenMethod(SymbolToken)\n  nameWithType: ISymbolWriter.OpenMethod(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(SymbolToken)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a method to place symbol information into.\n  remarks: The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.\n  syntax:\n    content: public void OpenMethod (System.Diagnostics.SymbolStore.SymbolToken method);\n    parameters:\n    - id: method\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for the method to be opened.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(System.String)\n  id: OpenNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: OpenNamespace(String)\n  nameWithType: ISymbolWriter.OpenNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a new namespace.\n  remarks: Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.\n  syntax:\n    content: public void OpenNamespace (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the new namespace.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(System.Int32)\n  id: OpenScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: OpenScope(Int32)\n  nameWithType: ISymbolWriter.OpenScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a new lexical scope in the current method.\n  remarks: \"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.  \\n  \\n Scope identifiers are valid only in the current method.\"\n  syntax:\n    content: public int OpenScope (int startOffset);\n    parameters:\n    - id: startOffset\n      type: System.Int32\n      description: The offset, in bytes, from the beginning of the method to the first instruction in the lexical scope.\n    return:\n      type: System.Int32\n      description: An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope*> are ignored. A scope identifier is valid only in the current method.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  id: SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  nameWithType: ISymbolWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Specifies the true start and end of a method within a source file. Use SetMethodSourceRange to specify the extent of a method, independent of the sequence points that exist within the method.\n  syntax:\n    content: public void SetMethodSourceRange (System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);\n    parameters:\n    - id: startDoc\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The document that contains the starting position.\n    - id: startLine\n      type: System.Int32\n      description: The starting line number.\n    - id: startColumn\n      type: System.Int32\n      description: The starting column.\n    - id: endDoc\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The document that contains the ending position.\n    - id: endLine\n      type: System.Int32\n      description: The ending line number.\n    - id: endColumn\n      type: System.Int32\n      description: The ending column number.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  id: SetScopeRange(System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: SetScopeRange(Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.SetScopeRange(Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines the offset range for the specified lexical scope.\n  syntax:\n    content: public void SetScopeRange (int scopeID, int startOffset, int endOffset);\n    parameters:\n    - id: scopeID\n      type: System.Int32\n      description: The identifier of the lexical scope.\n    - id: startOffset\n      type: System.Int32\n      description: The byte offset of the beginning of the lexical scope.\n    - id: endOffset\n      type: System.Int32\n      description: The byte offset of the end of the lexical scope.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  id: SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: SetSymAttribute(SymbolToken,String,Byte[])\n  nameWithType: ISymbolWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines an attribute when given the attribute name and the attribute value.\n  remarks: The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.\n  syntax:\n    content: public void SetSymAttribute (System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);\n    parameters:\n    - id: parent\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for which the attribute is being defined.\n    - id: name\n      type: System.String\n      description: The attribute name.\n    - id: data\n      type: System.Byte[]\n      description: The attribute value.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(System.IntPtr)\n  id: SetUnderlyingWriter(System.IntPtr)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: SetUnderlyingWriter(IntPtr)\n  nameWithType: ISymbolWriter.SetUnderlyingWriter(IntPtr)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(IntPtr)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Sets the underlying <xref uid=\"langword_csharp_ISymUnmanagedWriter\" name=\"ISymUnmanagedWriter\" href=\"\"></xref> (the corresponding unmanaged interface) that a managed <xref href=\"System.Diagnostics.SymbolStore.ISymbolWriter\"></xref> uses to emit symbols.\n  remarks: The underlying `ISymUnmanagedWriter` (the corresponding unmanaged interface) represents a symbol writer for managed code. The interface provides methods for defining documents, sequence points, lexical scopes, and variables.\n  syntax:\n    content: public void SetUnderlyingWriter (IntPtr underlyingWriter);\n    parameters:\n    - id: underlyingWriter\n      type: System.IntPtr\n      description: A pointer to code that represents the underlying writer.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  id: SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: SetUserEntryPoint(SymbolToken)\n  nameWithType: ISymbolWriter.SetUserEntryPoint(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(SymbolToken)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Identifies the user-defined method as the entry point for the current module.\n  remarks: This is normally your main method, rather than compiler-generated stubs before the main method.\n  syntax:\n    content: public void SetUserEntryPoint (System.Diagnostics.SymbolStore.SymbolToken entryMethod);\n    parameters:\n    - id: entryMethod\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for the method that is the user entry point.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(System.String)\n  id: UsingNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  langs:\n  - csharp\n  name: UsingNamespace(String)\n  nameWithType: ISymbolWriter.UsingNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Diagnostics.SymbolStore\n  summary: Specifies that the given, fully qualified namespace name is used within the open lexical scope.\n  remarks: Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.\n  syntax:\n    content: public void UsingNamespace (string fullName);\n    parameters:\n    - id: fullName\n      type: System.String\n      description: The fully qualified name of the namespace.\n  overload: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Close\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: Close()\n  nameWithType: ISymbolWriter.Close()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.Close()\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseMethod()\n  nameWithType: ISymbolWriter.CloseMethod()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod()\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseNamespace()\n  nameWithType: ISymbolWriter.CloseNamespace()\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace()\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseScope(Int32)\n  nameWithType: ISymbolWriter.CloseScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineDocument(String,Guid,Guid,Guid)\n  nameWithType: ISymbolWriter.DefineDocument(String,Guid,Guid,Guid)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(String,Guid,Guid,Guid)\n- uid: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: ISymbolDocumentWriter\n  nameWithType: ISymbolDocumentWriter\n  fullName: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Guid\n  parent: System\n  isExternal: true\n  name: Guid\n  nameWithType: Guid\n  fullName: System.Guid\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymbolToken\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: SymbolToken\n  nameWithType: SymbolToken\n  fullName: System.Diagnostics.SymbolStore.SymbolToken\n- uid: System.Reflection.FieldAttributes\n  parent: System.Reflection\n  isExternal: true\n  name: FieldAttributes\n  nameWithType: FieldAttributes\n  fullName: System.Reflection.FieldAttributes\n- uid: System.Byte[]\n  parent: System\n  isExternal: true\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Diagnostics.SymbolStore.SymAddressKind\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: SymAddressKind\n  nameWithType: SymAddressKind\n  fullName: System.Diagnostics.SymbolStore.SymAddressKind\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n- uid: System.Reflection.ParameterAttributes\n  parent: System.Reflection\n  isExternal: true\n  name: ParameterAttributes\n  nameWithType: ParameterAttributes\n  fullName: System.Reflection.ParameterAttributes\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  nameWithType: ISymbolWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n- uid: System.Int32[]\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32[]\n  spec.csharp:\n  - uid: System.Int32\n    name: Int32\n    nameWithType: Int32\n    fullName: Int32[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: Initialize(IntPtr,String,Boolean)\n  nameWithType: ISymbolWriter.Initialize(IntPtr,String,Boolean)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(IntPtr,String,Boolean)\n- uid: System.IntPtr\n  parent: System\n  isExternal: true\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenMethod(SymbolToken)\n  nameWithType: ISymbolWriter.OpenMethod(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(SymbolToken)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenNamespace(String)\n  nameWithType: ISymbolWriter.OpenNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(String)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenScope(Int32)\n  nameWithType: ISymbolWriter.OpenScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(Int32)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  nameWithType: ISymbolWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetScopeRange(Int32,Int32,Int32)\n  nameWithType: ISymbolWriter.SetScopeRange(Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetSymAttribute(SymbolToken,String,Byte[])\n  nameWithType: ISymbolWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(SymbolToken,String,Byte[])\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(System.IntPtr)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetUnderlyingWriter(IntPtr)\n  nameWithType: ISymbolWriter.SetUnderlyingWriter(IntPtr)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(IntPtr)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetUserEntryPoint(SymbolToken)\n  nameWithType: ISymbolWriter.SetUserEntryPoint(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(SymbolToken)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: UsingNamespace(String)\n  nameWithType: ISymbolWriter.UsingNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(String)\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Close*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: Close\n  nameWithType: ISymbolWriter.Close\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseMethod\n  nameWithType: ISymbolWriter.CloseMethod\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseNamespace\n  nameWithType: ISymbolWriter.CloseNamespace\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: CloseScope\n  nameWithType: ISymbolWriter.CloseScope\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineDocument\n  nameWithType: ISymbolWriter.DefineDocument\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineField*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineField\n  nameWithType: ISymbolWriter.DefineField\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineGlobalVariable\n  nameWithType: ISymbolWriter.DefineGlobalVariable\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineLocalVariable\n  nameWithType: ISymbolWriter.DefineLocalVariable\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineParameter\n  nameWithType: ISymbolWriter.DefineParameter\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: DefineSequencePoints\n  nameWithType: ISymbolWriter.DefineSequencePoints\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.Initialize*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: Initialize\n  nameWithType: ISymbolWriter.Initialize\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenMethod\n  nameWithType: ISymbolWriter.OpenMethod\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenNamespace\n  nameWithType: ISymbolWriter.OpenNamespace\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: OpenScope\n  nameWithType: ISymbolWriter.OpenScope\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetMethodSourceRange\n  nameWithType: ISymbolWriter.SetMethodSourceRange\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetScopeRange\n  nameWithType: ISymbolWriter.SetScopeRange\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetSymAttribute\n  nameWithType: ISymbolWriter.SetSymAttribute\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetUnderlyingWriter\n  nameWithType: ISymbolWriter.SetUnderlyingWriter\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: SetUserEntryPoint\n  nameWithType: ISymbolWriter.SetUserEntryPoint\n- uid: System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace*\n  parent: System.Diagnostics.SymbolStore.ISymbolWriter\n  isExternal: false\n  name: UsingNamespace\n  nameWithType: ISymbolWriter.UsingNamespace\n"}