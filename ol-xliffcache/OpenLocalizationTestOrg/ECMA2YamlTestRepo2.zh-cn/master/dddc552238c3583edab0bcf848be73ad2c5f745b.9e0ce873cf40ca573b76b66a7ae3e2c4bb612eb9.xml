{"nodes":[{"pos":[3195,3239],"content":"Represents a symbol writer for managed code.","needQuote":true,"needEscape":true,"nodes":[{"content":"Represents a symbol writer for managed code.","pos":[0,44]}]},{"pos":[3251,3358],"content":"The SymWriter class provides methods that define documents, sequence points, lexical scopes, and variables.","needQuote":true,"needEscape":true,"nodes":[{"content":"The SymWriter class provides methods that define documents, sequence points, lexical scopes, and variables.","pos":[0,107]}]},{"pos":[4211,4313],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class."},{"pos":[4897,5057],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class, specifying whether to create an underlying symbol writer.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class, specifying whether to create an underlying symbol writer."},{"pos":[5216,5544],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if an underlying symbol writer will be provided by calling the &lt;xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*&gt; method; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> if a default underlying symbol writer should be created instead.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if an underlying symbol writer will be provided by calling the <xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*> method; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if a default underlying symbol writer should be created instead."},{"pos":[5993,6110],"content":"Closes the <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and commits the symbols to the symbol store.","needQuote":true,"needEscape":true,"source":"Closes the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> and commits the symbols to the symbol store."},{"pos":[6122,6227],"content":"After this call, the <xref:System.Diagnostics.SymbolStore.SymWriter> becomes invalid for further updates.","needQuote":true,"needEscape":true,"nodes":[{"content":"After this call, the &lt;xref:System.Diagnostics.SymbolStore.SymWriter&gt; becomes invalid for further updates.","pos":[0,105],"source":"After this call, the <xref:System.Diagnostics.SymbolStore.SymWriter> becomes invalid for further updates."}]},{"pos":[6778,6804],"content":"Closes the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the current method.","pos":[0,26]}]},{"pos":[6816,6892],"content":"After a method is closed, you cannot define a symbol from within the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"After a method is closed, you cannot define a symbol from within the method.","pos":[0,76]}]},{"pos":[7470,7503],"content":"Closes the most recent namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the most recent namespace.","pos":[0,33]}]},{"pos":[8110,8143],"content":"Closes the current lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closes the current lexical scope.","pos":[0,33]}]},{"pos":[8155,8232],"content":"After a scope is closed, you cannot define a variable from within the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"After a scope is closed, you cannot define a variable from within the method.","pos":[0,77]}]},{"pos":[8384,8442],"content":"The IL offset just past the last instruction in the scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The IL offset just past the last instruction in the scope.","pos":[0,58]}]},{"pos":[9106,9132],"content":"Defines a source document.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a source document.","pos":[0,26]}]},{"pos":[9383,9420],"content":"The URL that identifies the document.","needQuote":true,"needEscape":true,"nodes":[{"content":"The URL that identifies the document.","pos":[0,37]}]},{"pos":[9483,9547],"content":"The document language. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document language. This parameter can be <xref:System.Guid>.","pos":[0,64],"nodes":[{"content":"The document language.","pos":[0,22]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[23,64],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[9616,9711],"content":"The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.","pos":[0,95],"nodes":[{"content":"The identity of the vendor for the document language.","pos":[0,53]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[54,95],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[9778,9845],"content":"The type of the document. This parameter can be <xref:System.Guid>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The type of the document. This parameter can be <xref:System.Guid>.","pos":[0,67],"nodes":[{"content":"The type of the document.","pos":[0,25]},{"content":"This parameter can be &lt;xref:System.Guid&gt;.","pos":[26,67],"source":" This parameter can be <xref:System.Guid>."}]}]},{"pos":[9942,10056],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.ISymbolDocumentWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that represents the document.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Diagnostics.SymbolStore.ISymbolDocumentWriter\"></xref> object that represents the document."},{"pos":[11148,11206],"content":"Throws a <xref:System.NotSupportedException> in all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"Throws a &lt;xref:System.NotSupportedException&gt; in all cases.","pos":[0,58],"source":"Throws a <xref:System.NotSupportedException> in all cases."}]},{"pos":[11588,11615],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[11676,11703],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[11790,11817],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[11883,11910],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[12007,12034],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[12095,12122],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[12183,12210],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[12271,12298],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[12481,12494],"content":"In all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"In all cases.","pos":[0,13]}]},{"pos":[13423,13481],"content":"Throws a <xref:System.NotSupportedException> in all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"Throws a &lt;xref:System.NotSupportedException&gt; in all cases.","pos":[0,58],"source":"Throws a <xref:System.NotSupportedException> in all cases."}]},{"pos":[13790,13817],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[13904,13931],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[13997,14024],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[14121,14148],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[14209,14236],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[14297,14324],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[14385,14412],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[14604,14617],"content":"In all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"In all cases.","pos":[0,13]}]},{"pos":[15629,15684],"content":"Defines a single variable in the current lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a single variable in the current lexical scope.","pos":[0,55]}]},{"pos":[15697,16149],"content":"The `startOffset` and `endOffset` parameters are optional. If their value is zero, they are ignored and the variable is defined throughout the entire scope. If their value is nonzero, they fall within the offsets of the current scope.       You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope. (In this case, start and end offsets must not overlap.)","needQuote":false,"needEscape":true,"nodes":[{"content":"The <ph id=\"ph1\">`startOffset`</ph> and <ph id=\"ph2\">`endOffset`</ph> parameters are optional.","pos":[0,58],"source":"The `startOffset` and `endOffset` parameters are optional."},{"content":"If their value is zero, they are ignored and the variable is defined throughout the entire scope.","pos":[59,156]},{"content":"If their value is nonzero, they fall within the offsets of the current scope.","pos":[157,234]},{"content":"You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope.","pos":[241,394]},{"content":"(In this case, start and end offsets must not overlap.)","pos":[395,450]}]},{"pos":[16490,16514],"content":"The local variable name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The local variable name.","pos":[0,24]}]},{"pos":[16601,16703],"content":"The local variable attributes specified using the <xref:System.Reflection.FieldAttributes> enumerator.","needQuote":true,"needEscape":true,"nodes":[{"content":"The local variable attributes specified using the &lt;xref:System.Reflection.FieldAttributes&gt; enumerator.","pos":[0,102],"source":"The local variable attributes specified using the <xref:System.Reflection.FieldAttributes> enumerator."}]},{"pos":[16769,16798],"content":"The local variable signature.","needQuote":true,"needEscape":true,"nodes":[{"content":"The local variable signature.","pos":[0,29]}]},{"pos":[16895,17020],"content":"The address types for <ph id=\"ph1\">`addr1`</ph>, <ph id=\"ph2\">`addr2`</ph>, and <ph id=\"ph3\">`addr3`</ph> using <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymAddressKind\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The address types for `addr1`, `addr2`, and `addr3` using <xref href=\"System.Diagnostics.SymbolStore.SymAddressKind\"></xref>."},{"pos":[17081,17136],"content":"The first address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The first address for the local variable specification.","pos":[0,55]}]},{"pos":[17197,17253],"content":"The second address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The second address for the local variable specification.","pos":[0,56]}]},{"pos":[17314,17369],"content":"The third address for the local variable specification.","needQuote":true,"needEscape":true,"nodes":[{"content":"The third address for the local variable specification.","pos":[0,55]}]},{"pos":[17436,17624],"content":"The start offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The start offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.","pos":[0,188],"nodes":[{"content":"The start offset for the variable.","pos":[0,34]},{"content":"If zero, this parameter is ignored and the variable is defined throughout the entire scope.","pos":[35,126]},{"content":"If nonzero, it falls within the offsets of the current scope.","pos":[127,188]}]}]},{"pos":[17689,17875],"content":"The end offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The end offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.","pos":[0,186],"nodes":[{"content":"The end offset for the variable.","pos":[0,32]},{"content":"If zero, this parameter is ignored and the variable is defined throughout the entire scope.","pos":[33,124]},{"content":"If nonzero, it falls within the offsets of the current scope.","pos":[125,186]}]}]},{"pos":[18885,18943],"content":"Throws a <xref:System.NotSupportedException> in all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"Throws a &lt;xref:System.NotSupportedException&gt; in all cases.","pos":[0,58],"source":"Throws a <xref:System.NotSupportedException> in all cases."}]},{"pos":[19247,19274],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19365,19392],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19456,19483],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19580,19607],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19668,19695],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19756,19783],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[19844,19871],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[20058,20071],"content":"In all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"In all cases.","pos":[0,13]}]},{"pos":[20959,21020],"content":"Defines a group of sequence points within the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines a group of sequence points within the current method.","pos":[0,61]}]},{"pos":[21032,21606],"content":"Sequence points are used to map between source file locations and IL offsets.  Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an <xref:System.Diagnostics.SymbolStore.ISymbolDocument> object.  Each element at a specific index of every array corresponds to a specific sequence point. Each line and each column defines the start of a statement within a method. The arrays should be sorted in the increasing order of offsets. The offset is always the offset from the start of the method, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sequence points are used to map between source file locations and IL offsets.  Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an <xref:System.Diagnostics.SymbolStore.ISymbolDocument> object.  Each element at a specific index of every array corresponds to a specific sequence point. Each line and each column defines the start of a statement within a method. The arrays should be sorted in the increasing order of offsets. The offset is always the offset from the start of the method, in bytes.","pos":[0,574],"nodes":[{"content":"Sequence points are used to map between source file locations and IL offsets.","pos":[0,77]},{"content":"Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an &lt;xref:System.Diagnostics.SymbolStore.ISymbolDocument&gt; object.","pos":[79,271],"source":"  Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an <xref:System.Diagnostics.SymbolStore.ISymbolDocument> object."},{"content":"Each element at a specific index of every array corresponds to a specific sequence point.","pos":[273,362]},{"content":"Each line and each column defines the start of a statement within a method.","pos":[363,438]},{"content":"The arrays should be sorted in the increasing order of offsets.","pos":[439,502]},{"content":"The offset is always the offset from the start of the method, in bytes.","pos":[503,574]}]}]},{"pos":[21932,22000],"content":"The document object for which the sequence points are being defined.","needQuote":true,"needEscape":true,"nodes":[{"content":"The document object for which the sequence points are being defined.","pos":[0,68]}]},{"pos":[22065,22144],"content":"The IL offset of the sequence points measured from the beginning of the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"The IL offset of the sequence points measured from the beginning of the method.","pos":[0,79]}]},{"pos":[22207,22256],"content":"The starting line numbers of the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The starting line numbers of the sequence points.","pos":[0,49]}]},{"pos":[22321,22372],"content":"The starting column numbers of the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The starting column numbers of the sequence points.","pos":[0,51]}]},{"pos":[22438,22485],"content":"The ending line numbers of the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The ending line numbers of the sequence points.","pos":[0,47]}]},{"pos":[22553,22602],"content":"The ending column numbers of the sequence points.","needQuote":true,"needEscape":true,"nodes":[{"content":"The ending column numbers of the sequence points.","pos":[0,49]}]},{"pos":[23076,23203],"content":"Releases the resources used by the current instance of the <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Releases the resources used by the current instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class."},{"pos":[23799,24091],"content":"Called by the &lt;xref:System.Diagnostics.SymbolStore.SymWriter.Dispose<bpt id=\"p1\">*</bpt>&gt; and &lt;xref:System.Diagnostics.SymbolStore.SymWriter.Finalize<ept id=\"p1\">*</ept>&gt; methods to release the managed and unmanaged resources used by the current instance of the <bpt id=\"p2\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Called by the <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose*> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize*> methods to release the managed and unmanaged resources used by the current instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class."},{"pos":[24103,24309],"content":"This method is called only by the public <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> methods; do not call this method directly.","needQuote":true,"needEscape":true,"nodes":[{"content":"This method is called only by the public &lt;xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A&gt; and &lt;xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A&gt; methods; do not call this method directly.","pos":[0,206],"source":"This method is called only by the public <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> methods; do not call this method directly."}]},{"pos":[24452,24656],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to release managed and unmanaged resources; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to release only unmanaged resources.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to release managed and unmanaged resources; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to release only unmanaged resources."},{"pos":[25122,25297],"content":"Releases unmanaged resources and performs other cleanup operations before the <bpt id=\"p1\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is reclaimed by garbage collection.","needQuote":true,"needEscape":true,"source":"Releases unmanaged resources and performs other cleanup operations before the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> is reclaimed by garbage collection."},{"pos":[25309,25618],"content":"This method overrides  <xref:System.Object.Finalize%2A>. Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.","needQuote":true,"needEscape":true,"nodes":[{"content":"This method overrides  &lt;xref:System.Object.Finalize%2A&gt;.","pos":[0,56],"source":"This method overrides  <xref:System.Object.Finalize%2A>."},{"content":"Application code should not call this method; an object's <ph id=\"ph1\">`Finalize`</ph> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the &lt;xref:System.GC.SuppressFinalize%2A&gt; method.","pos":[57,309],"source":" Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method."}]},{"pos":[26362,26374],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[27003,27069],"content":"Sets the metadata emitter interface to associate with this writer.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the metadata emitter interface to associate with this writer.","pos":[0,66]}]},{"pos":[27081,27317],"content":"<xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods are called.","needQuote":true,"needEscape":true,"nodes":[{"content":"<xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods are called.","pos":[0,236],"nodes":[{"content":"&lt;xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A&gt; also sets the output file name where the debugging symbols are written.","pos":[0,137],"source":"<xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> also sets the output file name where the debugging symbols are written."},{"content":"This method can be called only once and must be called before any other writer methods are called.","pos":[138,236]}]}]},{"pos":[27503,27534],"content":"The metadata emitter interface.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata emitter interface.","pos":[0,31]}]},{"pos":[27599,27810],"content":"The file name for which the debugging symbols are written. Some writers require a file name, while others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.","needQuote":true,"needEscape":true,"nodes":[{"content":"The file name for which the debugging symbols are written. Some writers require a file name, while others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.","pos":[0,211],"nodes":[{"content":"The file name for which the debugging symbols are written.","pos":[0,58]},{"content":"Some writers require a file name, while others do not.","pos":[59,113]},{"content":"If a file name is specified for a writer that does not use file names, this parameter is ignored.","pos":[114,211]}]}]},{"pos":[27878,28078],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> indicates that this is a full rebuild; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> indicates an incremental compilation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> indicates that this is a full rebuild; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> indicates an incremental compilation."},{"pos":[28610,28716],"content":"Initializes the symbol writer. This method should not be called directly; it is called by the constructor.","needQuote":true,"needEscape":true,"nodes":[{"content":"Initializes the symbol writer. This method should not be called directly; it is called by the constructor.","pos":[0,106],"nodes":[{"content":"Initializes the symbol writer.","pos":[0,30]},{"content":"This method should not be called directly; it is called by the constructor.","pos":[31,106]}]}]},{"pos":[28881,29209],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if an underlying symbol writer will be provided by calling the &lt;xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*&gt; method; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> if a default underlying symbol writer should be created instead.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if an underlying symbol writer will be provided by calling the <xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*> method; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if a default underlying symbol writer should be created instead."},{"pos":[29809,29861],"content":"Opens a method in which to place symbol information.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a method in which to place symbol information.","pos":[0,52]}]},{"pos":[29873,30155],"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.","pos":[0,282],"nodes":[{"content":"The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes.","pos":[0,116]},{"content":"There is an implicit lexical scope around the entire method.","pos":[117,177]},{"content":"Reopening a method that has been previously closed erases any previously defined symbols for the method.","pos":[178,282]}]}]},{"pos":[30370,30417],"content":"The metadata token for the method to be opened.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for the method to be opened.","pos":[0,47]}]},{"pos":[30959,30981],"content":"Opens a new namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a new namespace.","pos":[0,22]}]},{"pos":[30993,31103],"content":"Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.","needQuote":true,"needEscape":true,"nodes":[{"content":"Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.","pos":[0,110],"nodes":[{"content":"Call this method before defining methods or variables that exist within a namespace.","pos":[0,84]},{"content":"Namespaces can be nested.","pos":[85,110]}]}]},{"pos":[31252,31282],"content":"The name of the new namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"The name of the new namespace.","pos":[0,30]}]},{"pos":[31802,31850],"content":"Opens a new lexical scope in the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"Opens a new lexical scope in the current method.","pos":[0,48]}]},{"pos":[31863,32072],"content":"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.       Scope identifiers are only valid in the current method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.       Scope identifiers are only valid in the current method.","pos":[0,207],"nodes":[{"content":"This scope becomes the new current scope and is pushed onto a stack of scopes.","pos":[0,78]},{"content":"Scopes must form a hierarchy.","pos":[79,108]},{"content":"Siblings are not allowed to overlap.","pos":[109,145]},{"content":"Scope identifiers are only valid in the current method.","pos":[152,207]}]}]},{"pos":[32227,32329],"content":"The IL offset in bytes from the beginning of the method to the first instruction in the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The IL offset in bytes from the beginning of the method to the first instruction in the lexical scope.","pos":[0,102]}]},{"pos":[32386,32740],"content":"An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.SymWriter.CloseScope*> are ignored. A scope identifier is valid only in the current method.","needQuote":true,"needEscape":true,"nodes":[{"content":"An opaque scope identifier that can be used with &lt;xref:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange<bpt id=\"p1\">*</bpt>&gt; to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and &lt;xref:System.Diagnostics.SymbolStore.SymWriter.CloseScope<ept id=\"p1\">*</ept>&gt; are ignored.","pos":[0,298],"source":"An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.SymWriter.CloseScope*> are ignored."},{"content":"A scope identifier is valid only in the current method.","pos":[299,354]}]},{"pos":[33787,33845],"content":"Throws a <xref:System.NotSupportedException> in all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"Throws a &lt;xref:System.NotSupportedException&gt; in all cases.","pos":[0,58],"source":"Throws a <xref:System.NotSupportedException> in all cases."}]},{"pos":[34215,34242],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34307,34334],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34401,34428],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34530,34557],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34620,34647],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34712,34739],"content":"This parameter is not used.","needQuote":true,"needEscape":true,"nodes":[{"content":"This parameter is not used.","pos":[0,27]}]},{"pos":[34931,34944],"content":"In all cases.","needQuote":true,"needEscape":true,"nodes":[{"content":"In all cases.","pos":[0,13]}]},{"pos":[35487,35544],"content":"Defines the offset range for the specified lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines the offset range for the specified lexical scope.","pos":[0,57]}]},{"pos":[35727,35845],"content":"The identifier of the lexical scope returned by the <xref:System.Diagnostics.SymbolStore.SymWriter.OpenScope*> method.","needQuote":true,"needEscape":true,"nodes":[{"content":"The identifier of the lexical scope returned by the &lt;xref:System.Diagnostics.SymbolStore.SymWriter.OpenScope*&gt; method.","pos":[0,118],"source":"The identifier of the lexical scope returned by the <xref:System.Diagnostics.SymbolStore.SymWriter.OpenScope*> method."}]},{"pos":[35912,35964],"content":"The IL offset of the beginning of the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The IL offset of the beginning of the lexical scope.","pos":[0,52]}]},{"pos":[36029,36075],"content":"The IL offset of the end of the lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"The IL offset of the end of the lexical scope.","pos":[0,46]}]},{"pos":[36801,36876],"content":"Defines an attribute when given the attribute name and the attribute value.","needQuote":true,"needEscape":true,"nodes":[{"content":"Defines an attribute when given the attribute name and the attribute value.","pos":[0,75]}]},{"pos":[36888,36999],"content":"The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.","needQuote":true,"needEscape":true,"nodes":[{"content":"The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.","pos":[0,111]}]},{"pos":[37245,37305],"content":"The metadata token for which the attribute is being defined.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for which the attribute is being defined.","pos":[0,60]}]},{"pos":[37366,37385],"content":"The attribute name.","needQuote":true,"needEscape":true,"nodes":[{"content":"The attribute name.","pos":[0,19]}]},{"pos":[37446,37466],"content":"The attribute value.","needQuote":true,"needEscape":true,"nodes":[{"content":"The attribute value.","pos":[0,20]}]},{"pos":[38043,38266],"content":"Sets the underlying <bpt id=\"p1\">[</bpt>ISymUnmanagedWriter Interface<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept> (the corresponding unmanaged API) that a managed <bpt id=\"p2\">&lt;xref href=\"System.Diagnostics.SymbolStore.SymWriter\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> uses to emit symbols.","needQuote":true,"needEscape":true,"source":"Sets the underlying [ISymUnmanagedWriter Interface](~/add/includes/ajax-current-ext-md.md) (the corresponding unmanaged API) that a managed <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> uses to emit symbols."},{"pos":[38278,38558],"content":"The underlying [ISymUnmanagedWriter Interface](../Topic/ISymUnmanagedWriter%20Interface.md) (the corresponding unmanaged API) interface represents a symbol writer for managed code. The interface provides methods to define documents, sequence points, lexical scopes, and variables.","needQuote":true,"needEscape":true,"nodes":[{"content":"The underlying <bpt id=\"p1\">[</bpt>ISymUnmanagedWriter Interface<ept id=\"p1\">](../Topic/ISymUnmanagedWriter%20Interface.md)</ept> (the corresponding unmanaged API) interface represents a symbol writer for managed code.","pos":[0,180],"source":"The underlying [ISymUnmanagedWriter Interface](../Topic/ISymUnmanagedWriter%20Interface.md) (the corresponding unmanaged API) interface represents a symbol writer for managed code."},{"content":"The interface provides methods to define documents, sequence points, lexical scopes, and variables.","pos":[181,280]}]},{"pos":[38737,38812],"content":"An <xref:System.IntPtr> type pointer to code that is the underlying writer.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IntPtr&gt; type pointer to code that is the underlying writer.","pos":[0,75],"source":"An <xref:System.IntPtr> type pointer to code that is the underlying writer."}]},{"pos":[39456,39533],"content":"Identifies the user-defined method as the entry point for the current module.","needQuote":true,"needEscape":true,"nodes":[{"content":"Identifies the user-defined method as the entry point for the current module.","pos":[0,77]}]},{"pos":[39545,39578],"content":"This is normally the main method.","needQuote":true,"needEscape":true,"nodes":[{"content":"This is normally the main method.","pos":[0,33]}]},{"pos":[39810,39873],"content":"The metadata token for the method that is the user entry point.","needQuote":true,"needEscape":true,"nodes":[{"content":"The metadata token for the method that is the user entry point.","pos":[0,63]}]},{"pos":[40427,40522],"content":"Specifies that the given, fully qualified namespace name is used within the open lexical scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies that the given, fully qualified namespace name is used within the open lexical scope.","pos":[0,95]}]},{"pos":[40534,40690],"content":"Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.","needQuote":true,"needEscape":true,"nodes":[{"content":"Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.","pos":[0,156],"nodes":[{"content":"Closing the current scope prevents this scope from using the namespace.","pos":[0,71]},{"content":"The namespace remains in use in all scopes that inherit from the current open scope.","pos":[72,156]}]}]},{"pos":[40848,40890],"content":"The fully qualified name of the namespace.","needQuote":true,"needEscape":true,"nodes":[{"content":"The fully qualified name of the namespace.","pos":[0,42]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Diagnostics.SymbolStore.SymWriter\n  id: SymWriter\n  children:\n  - System.Diagnostics.SymbolStore.SymWriter.#ctor\n  - System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)\n  - System.Diagnostics.SymbolStore.SymWriter.Close\n  - System.Diagnostics.SymbolStore.SymWriter.CloseMethod\n  - System.Diagnostics.SymbolStore.SymWriter.CloseNamespace\n  - System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  - System.Diagnostics.SymbolStore.SymWriter.Dispose\n  - System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)\n  - System.Diagnostics.SymbolStore.SymWriter.Finalize\n  - System.Diagnostics.SymbolStore.SymWriter.GetWriter\n  - System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  - System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)\n  - System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  - System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)\n  - System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  - System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  - System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)\n  - System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  - System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)\n  langs:\n  - csharp\n  name: SymWriter\n  nameWithType: SymWriter\n  fullName: System.Diagnostics.SymbolStore.SymWriter\n  type: Class\n  summary: Represents a symbol writer for managed code.\n  remarks: The SymWriter class provides methods that define documents, sequence points, lexical scopes, and variables.\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class SymWriter : System.Diagnostics.SymbolStore.SymWriterBase, IDisposable, System.Diagnostics.SymbolStore.ISymbolWriter\n  inheritance:\n  - System.Object\n  - System.Diagnostics.SymbolStore.SymWriterBase\n  implements:\n  - System.Diagnostics.SymbolStore.ISymbolWriter\n  - System.IDisposable\n  inheritedMembers:\n  - System.Diagnostics.SymbolStore.SymWriterBase.{dtor}\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.#ctor\n  id: '#ctor'\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SymWriter()\n  nameWithType: SymWriter.SymWriter()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SymWriter()\n  type: Constructor\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Initializes a new instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class.\n  syntax:\n    content: public SymWriter ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)\n  id: '#ctor(System.Boolean)'\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SymWriter(Boolean)\n  nameWithType: SymWriter.SymWriter(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SymWriter(Boolean)\n  type: Constructor\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Initializes a new instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class, specifying whether to create an underlying symbol writer.\n  syntax:\n    content: public SymWriter (bool noUnderlyingWriter);\n    parameters:\n    - id: noUnderlyingWriter\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if an underlying symbol writer will be provided by calling the <xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*> method; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if a default underlying symbol writer should be created instead.\n  overload: System.Diagnostics.SymbolStore.SymWriter.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.Close\n  id: Close\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: SymWriter.Close()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Close()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> and commits the symbols to the symbol store.\n  remarks: After this call, the <xref:System.Diagnostics.SymbolStore.SymWriter> becomes invalid for further updates.\n  syntax:\n    content: public virtual void Close ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.Close*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseMethod\n  id: CloseMethod\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: CloseMethod()\n  nameWithType: SymWriter.CloseMethod()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseMethod()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the current method.\n  remarks: After a method is closed, you cannot define a symbol from within the method.\n  syntax:\n    content: public virtual void CloseMethod ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.CloseMethod*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace\n  id: CloseNamespace\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: CloseNamespace()\n  nameWithType: SymWriter.CloseNamespace()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the most recent namespace.\n  syntax:\n    content: public virtual void CloseNamespace ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)\n  id: CloseScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: CloseScope(Int32)\n  nameWithType: SymWriter.CloseScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseScope(Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Closes the current lexical scope.\n  remarks: After a scope is closed, you cannot define a variable from within the method.\n  syntax:\n    content: public virtual void CloseScope (int endOffset);\n    parameters:\n    - id: endOffset\n      type: System.Int32\n      description: The IL offset just past the last instruction in the scope.\n  overload: System.Diagnostics.SymbolStore.SymWriter.CloseScope*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  id: DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineDocument(String,Guid,Guid,Guid)\n  nameWithType: SymWriter.DefineDocument(String,Guid,Guid,Guid)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineDocument(String,Guid,Guid,Guid)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a source document.\n  syntax:\n    content: public virtual System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);\n    parameters:\n    - id: url\n      type: System.String\n      description: The URL that identifies the document.\n    - id: language\n      type: System.Guid\n      description: The document language. This parameter can be <xref:System.Guid>.\n    - id: languageVendor\n      type: System.Guid\n      description: The identity of the vendor for the document language. This parameter can be <xref:System.Guid>.\n    - id: documentType\n      type: System.Guid\n      description: The type of the document. This parameter can be <xref:System.Guid>.\n    return:\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The <xref href=\"System.Diagnostics.SymbolStore.ISymbolDocumentWriter\"></xref> object that represents the document.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineDocument*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Throws a <xref:System.NotSupportedException> in all cases.\n  syntax:\n    content: public virtual void DefineField (System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: parent\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: This parameter is not used.\n    - id: name\n      type: System.String\n      description: This parameter is not used.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: This parameter is not used.\n    - id: signature\n      type: System.Byte[]\n      description: This parameter is not used.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: This parameter is not used.\n    - id: addr1\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr2\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr3\n      type: System.Int32\n      description: This parameter is not used.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineField*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: In all cases.\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Throws a <xref:System.NotSupportedException> in all cases.\n  syntax:\n    content: public virtual void DefineGlobalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: name\n      type: System.String\n      description: This parameter is not used.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: This parameter is not used.\n    - id: signature\n      type: System.Byte[]\n      description: This parameter is not used.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: This parameter is not used.\n    - id: addr1\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr2\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr3\n      type: System.Int32\n      description: This parameter is not used.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: In all cases.\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  id: DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a single variable in the current lexical scope.\n  remarks: \"The `startOffset` and `endOffset` parameters are optional. If their value is zero, they are ignored and the variable is defined throughout the entire scope. If their value is nonzero, they fall within the offsets of the current scope.  \\n  \\n You can call DefineLocalVariable multiple times for a variable of the same name that occurs multiple times in different offset ranges throughout a scope. (In this case, start and end offsets must not overlap.)\"\n  syntax:\n    content: public virtual void DefineLocalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);\n    parameters:\n    - id: name\n      type: System.String\n      description: The local variable name.\n    - id: attributes\n      type: System.Reflection.FieldAttributes\n      description: The local variable attributes specified using the <xref:System.Reflection.FieldAttributes> enumerator.\n    - id: signature\n      type: System.Byte[]\n      description: The local variable signature.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: The address types for `addr1`, `addr2`, and `addr3` using <xref href=\"System.Diagnostics.SymbolStore.SymAddressKind\"></xref>.\n    - id: addr1\n      type: System.Int32\n      description: The first address for the local variable specification.\n    - id: addr2\n      type: System.Int32\n      description: The second address for the local variable specification.\n    - id: addr3\n      type: System.Int32\n      description: The third address for the local variable specification.\n    - id: startOffset\n      type: System.Int32\n      description: The start offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.\n    - id: endOffset\n      type: System.Int32\n      description: The end offset for the variable. If zero, this parameter is ignored and the variable is defined throughout the entire scope. If nonzero, it falls within the offsets of the current scope.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  id: DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Throws a <xref:System.NotSupportedException> in all cases.\n  syntax:\n    content: public virtual void DefineParameter (string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);\n    parameters:\n    - id: name\n      type: System.String\n      description: This parameter is not used.\n    - id: attributes\n      type: System.Reflection.ParameterAttributes\n      description: This parameter is not used.\n    - id: sequence\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addrKind\n      type: System.Diagnostics.SymbolStore.SymAddressKind\n      description: This parameter is not used.\n    - id: addr1\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr2\n      type: System.Int32\n      description: This parameter is not used.\n    - id: addr3\n      type: System.Int32\n      description: This parameter is not used.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineParameter*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: In all cases.\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  id: DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  nameWithType: SymWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines a group of sequence points within the current method.\n  remarks: Sequence points are used to map between source file locations and IL offsets.  Each sequence point consists of an IL offset and source file region, specified by start and end line/column numbers relative to an <xref:System.Diagnostics.SymbolStore.ISymbolDocument> object.  Each element at a specific index of every array corresponds to a specific sequence point. Each line and each column defines the start of a statement within a method. The arrays should be sorted in the increasing order of offsets. The offset is always the offset from the start of the method, in bytes.\n  syntax:\n    content: public virtual void DefineSequencePoints (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);\n    parameters:\n    - id: document\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: The document object for which the sequence points are being defined.\n    - id: offsets\n      type: System.Int32[]\n      description: The IL offset of the sequence points measured from the beginning of the method.\n    - id: lines\n      type: System.Int32[]\n      description: The starting line numbers of the sequence points.\n    - id: columns\n      type: System.Int32[]\n      description: The starting column numbers of the sequence points.\n    - id: endLines\n      type: System.Int32[]\n      description: The ending line numbers of the sequence points.\n    - id: endColumns\n      type: System.Int32[]\n      description: The ending column numbers of the sequence points.\n  overload: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.Dispose\n  id: Dispose\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: SymWriter.Dispose()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Dispose()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Releases the resources used by the current instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class.\n  syntax:\n    content: public override sealed void Dispose ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.Dispose*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: SymWriter.Dispose(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Called by the <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose*> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize*> methods to release the managed and unmanaged resources used by the current instance of the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> class.\n  remarks: This method is called only by the public <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> and <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> methods; do not call this method directly.\n  syntax:\n    content: protected virtual void Dispose (bool A_0);\n    parameters:\n    - id: A_0\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to release managed and unmanaged resources; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to release only unmanaged resources.\n  overload: System.Diagnostics.SymbolStore.SymWriter.Dispose*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.Finalize\n  id: Finalize\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: SymWriter.Finalize()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Finalize()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Releases unmanaged resources and performs other cleanup operations before the <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> is reclaimed by garbage collection.\n  remarks: This method overrides  <xref:System.Object.Finalize%2A>. Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.\n  syntax:\n    content: ~SymWriter ();\n    parameters: []\n  overload: System.Diagnostics.SymbolStore.SymWriter.Finalize*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.GetWriter\n  id: GetWriter\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: GetWriter()\n  nameWithType: SymWriter.GetWriter()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.GetWriter()\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  syntax:\n    content: public System.Diagnostics.SymbolStore.Private.ISymUnmanagedWriter* GetWriter ();\n    parameters: []\n    return:\n      type: System.Diagnostics.SymbolStore.Private.ISymUnmanagedWriter*\n      description: To be added.\n  overload: System.Diagnostics.SymbolStore.SymWriter.GetWriter*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  id: Initialize(System.IntPtr,System.String,System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: Initialize(IntPtr,String,Boolean)\n  nameWithType: SymWriter.Initialize(IntPtr,String,Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Initialize(IntPtr,String,Boolean)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Sets the metadata emitter interface to associate with this writer.\n  remarks: <xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> also sets the output file name where the debugging symbols are written. This method can be called only once and must be called before any other writer methods are called.\n  syntax:\n    content: public virtual void Initialize (IntPtr emitter, string filename, bool fFullBuild);\n    parameters:\n    - id: emitter\n      type: System.IntPtr\n      description: The metadata emitter interface.\n    - id: filename\n      type: System.String\n      description: The file name for which the debugging symbols are written. Some writers require a file name, while others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.\n    - id: fFullBuild\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> indicates that this is a full rebuild; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> indicates an incremental compilation.\n  overload: System.Diagnostics.SymbolStore.SymWriter.Initialize*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)\n  id: InitWriter(System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: InitWriter(Boolean)\n  nameWithType: SymWriter.InitWriter(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.InitWriter(Boolean)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Initializes the symbol writer. This method should not be called directly; it is called by the constructor.\n  syntax:\n    content: public void InitWriter (bool noUnderlyingWriter);\n    parameters:\n    - id: noUnderlyingWriter\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if an underlying symbol writer will be provided by calling the <xref:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*> method; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> if a default underlying symbol writer should be created instead.\n  overload: System.Diagnostics.SymbolStore.SymWriter.InitWriter*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  id: OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: OpenMethod(SymbolToken)\n  nameWithType: SymWriter.OpenMethod(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenMethod(SymbolToken)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a method in which to place symbol information.\n  remarks: The specified method becomes the current method for calls to define sequence points, parameters, and lexical scopes. There is an implicit lexical scope around the entire method. Reopening a method that has been previously closed erases any previously defined symbols for the method.\n  syntax:\n    content: public virtual void OpenMethod (System.Diagnostics.SymbolStore.SymbolToken method);\n    parameters:\n    - id: method\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for the method to be opened.\n  overload: System.Diagnostics.SymbolStore.SymWriter.OpenMethod*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)\n  id: OpenNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: OpenNamespace(String)\n  nameWithType: SymWriter.OpenNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(String)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a new namespace.\n  remarks: Call this method before defining methods or variables that exist within a namespace. Namespaces can be nested.\n  syntax:\n    content: public virtual void OpenNamespace (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the new namespace.\n  overload: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)\n  id: OpenScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: OpenScope(Int32)\n  nameWithType: SymWriter.OpenScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenScope(Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Opens a new lexical scope in the current method.\n  remarks: \"This scope becomes the new current scope and is pushed onto a stack of scopes. Scopes must form a hierarchy. Siblings are not allowed to overlap.  \\n  \\n Scope identifiers are only valid in the current method.\"\n  syntax:\n    content: public virtual int OpenScope (int startOffset);\n    parameters:\n    - id: startOffset\n      type: System.Int32\n      description: The IL offset in bytes from the beginning of the method to the first instruction in the lexical scope.\n    return:\n      type: System.Int32\n      description: An opaque scope identifier that can be used with <xref:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange*> to define the start and end offsets of a scope at a later time. In this case, the offsets passed to OpenScope and <xref:System.Diagnostics.SymbolStore.SymWriter.CloseScope*> are ignored. A scope identifier is valid only in the current method.\n  overload: System.Diagnostics.SymbolStore.SymWriter.OpenScope*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  id: SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  nameWithType: SymWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Throws a <xref:System.NotSupportedException> in all cases.\n  syntax:\n    content: public virtual void SetMethodSourceRange (System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);\n    parameters:\n    - id: startDoc\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: This parameter is not used.\n    - id: startLine\n      type: System.Int32\n      description: This parameter is not used.\n    - id: startColumn\n      type: System.Int32\n      description: This parameter is not used.\n    - id: endDoc\n      type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n      description: This parameter is not used.\n    - id: endLine\n      type: System.Int32\n      description: This parameter is not used.\n    - id: endColumn\n      type: System.Int32\n      description: This parameter is not used.\n  overload: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: In all cases.\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  id: SetScopeRange(System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SetScopeRange(Int32,Int32,Int32)\n  nameWithType: SymWriter.SetScopeRange(Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(Int32,Int32,Int32)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines the offset range for the specified lexical scope.\n  syntax:\n    content: public virtual void SetScopeRange (int scopeID, int startOffset, int endOffset);\n    parameters:\n    - id: scopeID\n      type: System.Int32\n      description: The identifier of the lexical scope returned by the <xref:System.Diagnostics.SymbolStore.SymWriter.OpenScope*> method.\n    - id: startOffset\n      type: System.Int32\n      description: The IL offset of the beginning of the lexical scope.\n    - id: endOffset\n      type: System.Int32\n      description: The IL offset of the end of the lexical scope.\n  overload: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  id: SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SetSymAttribute(SymbolToken,String,Byte[])\n  nameWithType: SymWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Defines an attribute when given the attribute name and the attribute value.\n  remarks: The SetSymAttribute method is only associated with symbolic information and is not a metadata custom attribute.\n  syntax:\n    content: public virtual void SetSymAttribute (System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);\n    parameters:\n    - id: parent\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for which the attribute is being defined.\n    - id: name\n      type: System.String\n      description: The attribute name.\n    - id: data\n      type: System.Byte[]\n      description: The attribute value.\n  overload: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)\n  id: SetUnderlyingWriter(System.IntPtr)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SetUnderlyingWriter(IntPtr)\n  nameWithType: SymWriter.SetUnderlyingWriter(IntPtr)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(IntPtr)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Sets the underlying [ISymUnmanagedWriter Interface](~/add/includes/ajax-current-ext-md.md) (the corresponding unmanaged API) that a managed <xref href=\"System.Diagnostics.SymbolStore.SymWriter\"></xref> uses to emit symbols.\n  remarks: The underlying [ISymUnmanagedWriter Interface](../Topic/ISymUnmanagedWriter%20Interface.md) (the corresponding unmanaged API) interface represents a symbol writer for managed code. The interface provides methods to define documents, sequence points, lexical scopes, and variables.\n  syntax:\n    content: public virtual void SetUnderlyingWriter (IntPtr underlyingWriter);\n    parameters:\n    - id: underlyingWriter\n      type: System.IntPtr\n      description: An <xref:System.IntPtr> type pointer to code that is the underlying writer.\n  overload: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  id: SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: SetUserEntryPoint(SymbolToken)\n  nameWithType: SymWriter.SetUserEntryPoint(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(SymbolToken)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Identifies the user-defined method as the entry point for the current module.\n  remarks: This is normally the main method.\n  syntax:\n    content: public virtual void SetUserEntryPoint (System.Diagnostics.SymbolStore.SymbolToken entryMethod);\n    parameters:\n    - id: entryMethod\n      type: System.Diagnostics.SymbolStore.SymbolToken\n      description: The metadata token for the method that is the user entry point.\n  overload: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)\n  id: UsingNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  langs:\n  - csharp\n  name: UsingNamespace(String)\n  nameWithType: SymWriter.UsingNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(String)\n  type: Method\n  assemblies:\n  - ISymWrapper\n  namespace: System.Diagnostics.SymbolStore\n  summary: Specifies that the given, fully qualified namespace name is used within the open lexical scope.\n  remarks: Closing the current scope prevents this scope from using the namespace. The namespace remains in use in all scopes that inherit from the current open scope.\n  syntax:\n    content: public virtual void UsingNamespace (string fullName);\n    parameters:\n    - id: fullName\n      type: System.String\n      description: The fully qualified name of the namespace.\n  overload: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Diagnostics.SymbolStore.SymWriterBase\n  isExternal: false\n  name: System.Diagnostics.SymbolStore.SymWriterBase\n- uid: System.NotSupportedException\n  isExternal: true\n  name: System.NotSupportedException\n- uid: System.Diagnostics.SymbolStore.SymWriter.#ctor\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SymWriter()\n  nameWithType: SymWriter.SymWriter()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SymWriter()\n- uid: System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SymWriter(Boolean)\n  nameWithType: SymWriter.SymWriter(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SymWriter(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Diagnostics.SymbolStore.SymWriter.Close\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Close()\n  nameWithType: SymWriter.Close()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Close()\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseMethod\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseMethod()\n  nameWithType: SymWriter.CloseMethod()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseMethod()\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseNamespace()\n  nameWithType: SymWriter.CloseNamespace()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace()\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseScope(Int32)\n  nameWithType: SymWriter.CloseScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.CloseScope(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineDocument(String,Guid,Guid,Guid)\n  nameWithType: SymWriter.DefineDocument(String,Guid,Guid,Guid)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineDocument(String,Guid,Guid,Guid)\n- uid: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: ISymbolDocumentWriter\n  nameWithType: ISymbolDocumentWriter\n  fullName: System.Diagnostics.SymbolStore.ISymbolDocumentWriter\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Guid\n  parent: System\n  isExternal: true\n  name: Guid\n  nameWithType: Guid\n  fullName: System.Guid\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineField(SymbolToken,String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymbolToken\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: SymbolToken\n  nameWithType: SymbolToken\n  fullName: System.Diagnostics.SymbolStore.SymbolToken\n- uid: System.Reflection.FieldAttributes\n  parent: System.Reflection\n  isExternal: true\n  name: FieldAttributes\n  nameWithType: FieldAttributes\n  fullName: System.Reflection.FieldAttributes\n- uid: System.Byte[]\n  parent: System\n  isExternal: true\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Diagnostics.SymbolStore.SymAddressKind\n  parent: System.Diagnostics.SymbolStore\n  isExternal: false\n  name: SymAddressKind\n  nameWithType: SymAddressKind\n  fullName: System.Diagnostics.SymbolStore.SymAddressKind\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(String,FieldAttributes,Byte[],SymAddressKind,Int32,Int32,Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  nameWithType: SymWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineParameter(String,ParameterAttributes,Int32,SymAddressKind,Int32,Int32,Int32)\n- uid: System.Reflection.ParameterAttributes\n  parent: System.Reflection\n  isExternal: true\n  name: ParameterAttributes\n  nameWithType: ParameterAttributes\n  fullName: System.Reflection.ParameterAttributes\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  nameWithType: SymWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n  fullName: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(ISymbolDocumentWriter,Int32[],Int32[],Int32[],Int32[],Int32[])\n- uid: System.Int32[]\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32[]\n  spec.csharp:\n  - uid: System.Int32\n    name: Int32\n    nameWithType: Int32\n    fullName: Int32[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Diagnostics.SymbolStore.SymWriter.Dispose\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Dispose()\n  nameWithType: SymWriter.Dispose()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Dispose()\n- uid: System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: SymWriter.Dispose(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Dispose(Boolean)\n- uid: System.Diagnostics.SymbolStore.SymWriter.Finalize\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Finalize()\n  nameWithType: SymWriter.Finalize()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Finalize()\n- uid: System.Diagnostics.SymbolStore.SymWriter.GetWriter\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: GetWriter()\n  nameWithType: SymWriter.GetWriter()\n  fullName: System.Diagnostics.SymbolStore.SymWriter.GetWriter()\n- uid: System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Initialize(IntPtr,String,Boolean)\n  nameWithType: SymWriter.Initialize(IntPtr,String,Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.Initialize(IntPtr,String,Boolean)\n- uid: System.IntPtr\n  parent: System\n  isExternal: true\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: InitWriter(Boolean)\n  nameWithType: SymWriter.InitWriter(Boolean)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.InitWriter(Boolean)\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenMethod(SymbolToken)\n  nameWithType: SymWriter.OpenMethod(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenMethod(SymbolToken)\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenNamespace(String)\n  nameWithType: SymWriter.OpenNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(String)\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenScope(Int32)\n  nameWithType: SymWriter.OpenScope(Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.OpenScope(Int32)\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  nameWithType: SymWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(ISymbolDocumentWriter,Int32,Int32,ISymbolDocumentWriter,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetScopeRange(Int32,Int32,Int32)\n  nameWithType: SymWriter.SetScopeRange(Int32,Int32,Int32)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(Int32,Int32,Int32)\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetSymAttribute(SymbolToken,String,Byte[])\n  nameWithType: SymWriter.SetSymAttribute(SymbolToken,String,Byte[])\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(SymbolToken,String,Byte[])\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetUnderlyingWriter(IntPtr)\n  nameWithType: SymWriter.SetUnderlyingWriter(IntPtr)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(IntPtr)\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetUserEntryPoint(SymbolToken)\n  nameWithType: SymWriter.SetUserEntryPoint(SymbolToken)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(SymbolToken)\n- uid: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: UsingNamespace(String)\n  nameWithType: SymWriter.UsingNamespace(String)\n  fullName: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(String)\n- uid: System.Diagnostics.SymbolStore.SymWriter.#ctor*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SymWriter\n  nameWithType: SymWriter.SymWriter\n- uid: System.Diagnostics.SymbolStore.SymWriter.Close*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Close\n  nameWithType: SymWriter.Close\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseMethod*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseMethod\n  nameWithType: SymWriter.CloseMethod\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseNamespace*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseNamespace\n  nameWithType: SymWriter.CloseNamespace\n- uid: System.Diagnostics.SymbolStore.SymWriter.CloseScope*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: CloseScope\n  nameWithType: SymWriter.CloseScope\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineDocument*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineDocument\n  nameWithType: SymWriter.DefineDocument\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineField*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineField\n  nameWithType: SymWriter.DefineField\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineGlobalVariable\n  nameWithType: SymWriter.DefineGlobalVariable\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineLocalVariable\n  nameWithType: SymWriter.DefineLocalVariable\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineParameter*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineParameter\n  nameWithType: SymWriter.DefineParameter\n- uid: System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: DefineSequencePoints\n  nameWithType: SymWriter.DefineSequencePoints\n- uid: System.Diagnostics.SymbolStore.SymWriter.Dispose*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Dispose\n  nameWithType: SymWriter.Dispose\n- uid: System.Diagnostics.SymbolStore.SymWriter.Finalize*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Finalize\n  nameWithType: SymWriter.Finalize\n- uid: System.Diagnostics.SymbolStore.SymWriter.GetWriter*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: GetWriter\n  nameWithType: SymWriter.GetWriter\n- uid: System.Diagnostics.SymbolStore.SymWriter.Initialize*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: Initialize\n  nameWithType: SymWriter.Initialize\n- uid: System.Diagnostics.SymbolStore.SymWriter.InitWriter*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: InitWriter\n  nameWithType: SymWriter.InitWriter\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenMethod*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenMethod\n  nameWithType: SymWriter.OpenMethod\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenNamespace*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenNamespace\n  nameWithType: SymWriter.OpenNamespace\n- uid: System.Diagnostics.SymbolStore.SymWriter.OpenScope*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: OpenScope\n  nameWithType: SymWriter.OpenScope\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetMethodSourceRange\n  nameWithType: SymWriter.SetMethodSourceRange\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetScopeRange*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetScopeRange\n  nameWithType: SymWriter.SetScopeRange\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetSymAttribute\n  nameWithType: SymWriter.SetSymAttribute\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetUnderlyingWriter\n  nameWithType: SymWriter.SetUnderlyingWriter\n- uid: System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: SetUserEntryPoint\n  nameWithType: SymWriter.SetUserEntryPoint\n- uid: System.Diagnostics.SymbolStore.SymWriter.UsingNamespace*\n  parent: System.Diagnostics.SymbolStore.SymWriter\n  isExternal: false\n  name: UsingNamespace\n  nameWithType: SymWriter.UsingNamespace\n"}