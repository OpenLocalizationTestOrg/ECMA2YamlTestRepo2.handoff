{"nodes":[{"pos":[5878,5992],"content":"Implements an <xref href=\"System.IO.Log.IRecordSequence\"></xref> on top of a file. This class cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Implements an <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.IRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> on top of a file.","pos":[0,82],"source":"Implements an <xref href=\"System.IO.Log.IRecordSequence\"></xref> on top of a file."},{"content":"This class cannot be inherited.","pos":[83,114]}]},{"pos":[6005,6710],"content":"The FileRecordSequence is a record sequence based on a single log file in the file system. It is a simple implementation of the <xref:System.IO.Log.IRecordSequence> interface, on top of a simple file-based log.       To manipulate a file-based log, the account that your application is running in must have sufficient privileges, as dictated by the file system security at the time the FileRecordSequence is constructed. In addition, a demand for FullTrust is made at construction time. The permission verification results are cached thereafter in keeping with the Windows security model. You should ensure that you do not accidentally expose the contents of the record sequence to an unauthorized user.","needQuote":false,"needEscape":true,"nodes":[{"content":"The FileRecordSequence is a record sequence based on a single log file in the file system. It is a simple implementation of the <xref:System.IO.Log.IRecordSequence> interface, on top of a simple file-based log.       To manipulate a file-based log, the account that your application is running in must have sufficient privileges, as dictated by the file system security at the time the FileRecordSequence is constructed. In addition, a demand for FullTrust is made at construction time. The permission verification results are cached thereafter in keeping with the Windows security model. You should ensure that you do not accidentally expose the contents of the record sequence to an unauthorized user.","pos":[0,703],"nodes":[{"content":"The FileRecordSequence is a record sequence based on a single log file in the file system.","pos":[0,90]},{"content":"It is a simple implementation of the &lt;xref:System.IO.Log.IRecordSequence&gt; interface, on top of a simple file-based log.","pos":[91,210],"source":" It is a simple implementation of the <xref:System.IO.Log.IRecordSequence> interface, on top of a simple file-based log."},{"content":"To manipulate a file-based log, the account that your application is running in must have sufficient privileges, as dictated by the file system security at the time the FileRecordSequence is constructed.","pos":[217,420]},{"content":"In addition, a demand for FullTrust is made at construction time.","pos":[421,486]},{"content":"The permission verification results are cached thereafter in keeping with the Windows security model.","pos":[487,588]},{"content":"You should ensure that you do not accidentally expose the contents of the record sequence to an unauthorized user.","pos":[589,703]}]}]},{"pos":[7689,7805],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with a specified file.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file."},{"pos":[7817,8186],"content":"This constructor creates read/write access to the file, and opens the file with share Read access. This means that requests to open the file for writing by this or another process fails until this <xref:System.IO.Log.FileRecordSequence> instance has been disposed of, but read attempts will succeed. If `path` is not found, a new file is created with a size of 0 bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"This constructor creates read/write access to the file, and opens the file with share Read access.","pos":[0,98]},{"content":"This means that requests to open the file for writing by this or another process fails until this &lt;xref:System.IO.Log.FileRecordSequence&gt; instance has been disposed of, but read attempts will succeed.","pos":[99,299],"source":" This means that requests to open the file for writing by this or another process fails until this <xref:System.IO.Log.FileRecordSequence> instance has been disposed of, but read attempts will succeed."},{"content":"If <ph id=\"ph1\">`path`</ph> is not found, a new file is created with a size of 0 bytes.","pos":[300,369],"source":" If `path` is not found, a new file is created with a size of 0 bytes."}]},{"pos":[8655,8786],"content":"A relative or absolute path for the file that this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> instance will encapsulate.","needQuote":true,"needEscape":true,"source":"A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate."},{"pos":[8947,9000],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not valid.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> is not valid."},{"pos":[9109,9165],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> cannot be found.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> cannot be found."},{"pos":[9254,9325],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[9426,9494],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[9609,9678],"content":"Access for the specified log store is denied by the operating system.","needQuote":true,"needEscape":true,"nodes":[{"content":"Access for the specified log store is denied by the operating system.","pos":[0,69]}]},{"pos":[10189,10324],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with a specified file and an access mode.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file and an access mode."},{"pos":[10494,10625],"content":"A relative or absolute path for the file that this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> instance will encapsulate.","needQuote":true,"needEscape":true,"source":"A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate."},{"pos":[10695,10809],"content":"A valid <bpt id=\"p1\">&lt;xref href=\"System.IO.FileAccess\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value that controls the kind of access users have to a log file.","needQuote":true,"needEscape":true,"source":"A valid <xref href=\"System.IO.FileAccess\"></xref> value that controls the kind of access users have to a log file."},{"pos":[10970,11023],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not valid.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> is not valid."},{"pos":[11132,11188],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> cannot be found.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> cannot be found."},{"pos":[11277,11348],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[11449,11517],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[11632,11701],"content":"Access for the specified log store is denied by the operating system.","needQuote":true,"needEscape":true,"nodes":[{"content":"Access for the specified log store is denied by the operating system.","pos":[0,69]}]},{"pos":[12256,12405],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class with a specified file, an access mode, and a file size.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file, an access mode, and a file size."},{"pos":[12585,12716],"content":"A relative or absolute path for the file that this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> instance will encapsulate.","needQuote":true,"needEscape":true,"source":"A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate."},{"pos":[12786,12900],"content":"A valid <bpt id=\"p1\">&lt;xref href=\"System.IO.FileAccess\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value that controls the kind of access users have to a log file.","needQuote":true,"needEscape":true,"source":"A valid <xref href=\"System.IO.FileAccess\"></xref> value that controls the kind of access users have to a log file."},{"pos":[12960,12998],"content":"The size of the log file to be opened.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the log file to be opened.","pos":[0,38]}]},{"pos":[13179,13236],"content":"One or more of the parameters are out of the valid range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the parameters are out of the valid range.","pos":[0,57]}]},{"pos":[13331,13384],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not valid.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> is not valid."},{"pos":[13493,13549],"content":"The file specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">path</ph><ept id=\"p1\">&lt;/code&gt;</ept> cannot be found.","needQuote":true,"needEscape":true,"source":"The file specified by <code>path</code> cannot be found."},{"pos":[13638,13709],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[13810,13878],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[13993,14062],"content":"Access for the specified log store is denied by the operating system.","needQuote":true,"needEscape":true,"nodes":[{"content":"Access for the specified log store is denied by the operating system.","pos":[0,69]}]},{"pos":[14606,14689],"content":"Moves the base sequence number of the log forward. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Moves the base sequence number of the log forward. This method cannot be inherited.","pos":[0,83],"nodes":[{"content":"Moves the base sequence number of the log forward.","pos":[0,50]},{"content":"This method cannot be inherited.","pos":[51,83]}]}]},{"pos":[14913,14965],"content":"The new base sequence number of the record sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number of the record sequence.","pos":[0,52]}]},{"pos":[15146,15192],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>newBaseSequenceNumber</code> is invalid."},{"pos":[15307,15409],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSequenceNumber&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","needQuote":true,"needEscape":true,"source":"<code>newBaseSequenceNumber</code> is not between the base and last sequence numbers of this sequence."},{"pos":[15498,15549],"content":"An I/O error occurred while modifying the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while modifying the sequence.","pos":[0,51]}]},{"pos":[15656,15718],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[15819,15887],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[16690,16804],"content":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,81],"source":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[82,114]}]},{"pos":[16817,17324],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"Normally, this method completes before the record has been written.","pos":[219,286]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[287,505],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[17875,17958],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[18044,18111],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[18197,18254],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[18350,18468],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[18541,18588],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[18758,18852],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[18967,19013],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[19116,19211],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[19300,19374],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[19481,19543],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[19644,19712],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[19829,19857],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[20749,20863],"content":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,81],"source":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[82,114]}]},{"pos":[20876,21383],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"Normally, this method completes before the record has been written.","pos":[219,286]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[287,505],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[22073,22156],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[22242,22309],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[22395,22452],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[22548,22666],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[22739,22786],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[22956,23050],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[23165,23211],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[23314,23409],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[23498,23572],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[23679,23741],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[23842,23910],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[24027,24055],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[24996,25159],"content":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.","pos":[0,130],"source":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence."},{"content":"This method cannot be inherited.","pos":[131,163]}]},{"pos":[25172,25981],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[219,355],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[356,512]},{"content":"Normally, this method completes before the record has been written.","pos":[519,586]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[587,805],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[26366,26449],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[26535,26602],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[26688,26745],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[26841,26959],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[27050,27175],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[27248,27295],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[27465,27559],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[27674,27720],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[27815,27882],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence..","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence.."},{"pos":[27985,28080],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[28169,28243],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[28350,28412],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[28513,28581],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[28698,28726],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[28857,28952],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[29982,30145],"content":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a log record to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>, using space previously reserved in the sequence.","pos":[0,130],"source":"Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence."},{"content":"This method cannot be inherited.","pos":[131,163]}]},{"pos":[30158,30967],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[219,355],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[356,512]},{"content":"Normally, this method completes before the record has been written.","pos":[519,586]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[587,805],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[31420,31503],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[31589,31656],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[31742,31799],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[31895,32013],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[32104,32229],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[32302,32349],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[32519,32613],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[32728,32774],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[32869,32936],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence..","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence.."},{"pos":[33039,33134],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[33223,33297],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[33404,33466],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[33567,33635],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[33752,33780],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[33911,34006],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[34409,34529],"content":"Gets the sequence number of the first valid record in the current <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Gets the sequence number of the first valid record in the current <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"pos":[34542,34934],"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. All other sequence numbers are invalid.       The value of this property can be changed by calling the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> or <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. All other sequence numbers are invalid.       The value of this property can be changed by calling the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> or <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> method.","pos":[0,390],"nodes":[{"content":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than &lt;xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A&gt;.","pos":[0,147],"source":"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>."},{"content":"All other sequence numbers are invalid.","pos":[148,187]},{"content":"The value of this property can be changed by calling the &lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt; or &lt;xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A&gt; method.","pos":[194,390],"source":"       The value of this property can be changed by calling the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> or <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> method."}]}]},{"pos":[35363,35486],"content":"The lowest sequence number that corresponds to a valid record in the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The lowest sequence number that corresponds to a valid record in the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"pos":[35672,35738],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[36699,36772],"content":"Begins an asynchronous append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous append operation. This method cannot be inherited.","pos":[0,73],"nodes":[{"content":"Begins an asynchronous append operation.","pos":[0,40]},{"content":"This method cannot be inherited.","pos":[41,73]}]}]},{"pos":[36785,37755],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,230],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[231,454],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[461,574],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[575,673]},{"content":"Normally, this method completes before the record has been written.","pos":[680,747]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[748,966],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[38117,38200],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[38286,38353],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[38439,38496],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[38592,38710],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[38782,38858],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[38920,39026],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[39090,39190],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[39365,39459],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[39574,39620],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[39723,39818],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[39907,39978],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[40085,40147],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[40248,40316],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[40433,40461],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[41511,41584],"content":"Begins an asynchronous append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous append operation. This method cannot be inherited.","pos":[0,73],"nodes":[{"content":"Begins an asynchronous append operation.","pos":[0,40]},{"content":"This method cannot be inherited.","pos":[41,73]}]}]},{"pos":[41597,42567],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,230],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[231,454],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[461,574],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[575,673]},{"content":"Normally, this method completes before the record has been written.","pos":[680,747]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[748,966],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[42997,43080],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[43166,43233],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[43319,43376],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[43472,43590],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[43662,43738],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[43800,43906],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[43970,44070],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[44245,44339],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[44454,44500],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[44603,44698],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[44787,44858],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[44965,45027],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[45128,45196],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[45313,45341],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[46440,46561],"content":"Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.","pos":[0,121],"nodes":[{"content":"Begins an asynchronous append operation using space previously reserved in the sequence.","pos":[0,88]},{"content":"This method cannot be inherited.","pos":[89,121]}]}]},{"pos":[46574,47846],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,230],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[231,454],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[461,574],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[575,673]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[680,816],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[817,973]},{"content":"Normally, this method completes before the record has been written.","pos":[980,1047]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[1048,1266],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[48258,48341],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[48427,48494],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[48580,48637],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[48733,48851],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[48942,49067],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[49139,49215],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[49277,49383],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[49447,49547],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[49722,49816],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[49931,49977],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[50072,50138],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence."},{"pos":[50241,50336],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[50425,50496],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[50603,50665],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[50766,50834],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[50951,50979],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[51110,51205],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[52393,52514],"content":"Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.","pos":[0,121],"nodes":[{"content":"Begins an asynchronous append operation using space previously reserved in the sequence.","pos":[0,88]},{"content":"This method cannot be inherited.","pos":[89,121]}]}]},{"pos":[52527,53799],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.       Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,230],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[231,454],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[461,574],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[575,673]},{"content":"The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id=\"ph1\">`reservations`</ph> parameter.","pos":[680,816],"source":"       The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter."},{"content":"If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.","pos":[817,973]},{"content":"Normally, this method completes before the record has been written.","pos":[980,1047]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[1048,1266],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[54279,54362],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[54448,54515],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[54601,54658],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[54754,54872],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[54963,55088],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this record.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record."},{"pos":[55160,55236],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[55298,55404],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[55468,55568],"content":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous append, which could still be pending.","pos":[0,100],"source":"An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending."}]},{"pos":[55743,55837],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[55952,55998],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[56093,56159],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence."},{"pos":[56262,56357],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[56446,56517],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[56624,56686],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[56787,56855],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[56972,57000],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[57131,57226],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[57828,57949],"content":"Begins an asynchronous flush operation, using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous flush operation, using space previously reserved in the sequence. This method cannot be inherited.","pos":[0,121],"nodes":[{"content":"Begins an asynchronous flush operation, using space previously reserved in the sequence.","pos":[0,88]},{"content":"This method cannot be inherited.","pos":[89,121]}]}]},{"pos":[57962,58913],"content":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> are durably written.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> are durably written.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called.","pos":[0,947],"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by the current method to the &lt;xref:System.IO.Log.FileRecordSequence.EndFlush%2A&gt; method to ensure that the flush completes and resources are freed appropriately.","pos":[0,217],"source":"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately."},{"content":"If an error occurs during an asynchronous flush, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndFlush%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[218,433],"source":" If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.FileRecordSequence&gt; are durably written.","pos":[440,576],"source":"       Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> are durably written."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[583,718]},{"content":"Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndFlush%2A&gt; method is called.","pos":[719,947],"source":" Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called."}]}]},{"pos":[59155,59316],"content":"The sequence number of the latest record that must be written. If <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the latest record that must be written.","pos":[0,62]},{"content":"If <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.SequenceNumber\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is invalid, then all records must be written.","pos":[63,161],"source":" If <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written."}]},{"pos":[59388,59463],"content":"An optional asynchronous callback, to be called when the flush is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the flush is complete.","pos":[0,75]}]},{"pos":[59525,59630],"content":"A user-provided object that distinguishes this particular asynchronous flush request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous flush request from other requests.","pos":[0,105]}]},{"pos":[59694,59803],"content":"An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous flush operation, which could still be pending.","pos":[0,109],"source":"An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending."}]},{"pos":[59970,60078],"content":"One or more of the arguments is invalid.       <code>sequenceNumber</code> is not valid for this sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"One or more of the arguments is invalid.","pos":[0,40]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sequenceNumber</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not valid for this sequence.","pos":[47,106],"source":"<code>sequenceNumber</code> is not valid for this sequence."}]},{"pos":[60194,60289],"content":"<ph id=\"ph1\">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","needQuote":true,"needEscape":true,"source":"<code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence."},{"pos":[60378,60424],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[60531,60593],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[60694,60762],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[61965,62050],"content":"Begins an asynchronous reserve and append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous reserve and append operation. This method cannot be inherited.","pos":[0,85],"nodes":[{"content":"Begins an asynchronous reserve and append operation.","pos":[0,52]},{"content":"This method cannot be inherited.","pos":[53,85]}]}]},{"pos":[62063,63623],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,240],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[241,474],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[481,594],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[595,693]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[700,830]},{"content":"If the append fails, no space is reserved.","pos":[831,873]},{"content":"Normally, this method may complete before the record has been written.","pos":[880,950]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[951,1169],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1176,1311]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1312,1552],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called."}]},{"pos":[64075,64158],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[64244,64311],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[64397,64454],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[64550,64668],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[64768,64819],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[64889,64924],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[64996,65072],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[65134,65240],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[65304,65408],"content":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.","pos":[0,104],"source":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."}]},{"pos":[65593,65687],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[65802,65848],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[65943,66009],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence."},{"pos":[66112,66207],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[66296,66370],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[66477,66539],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[66640,66708],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[66825,66853],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[66984,67079],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[68371,68456],"content":"Begins an asynchronous reserve and append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous reserve and append operation. This method cannot be inherited.","pos":[0,85],"nodes":[{"content":"Begins an asynchronous reserve and append operation.","pos":[0,52]},{"content":"This method cannot be inherited.","pos":[53,85]}]}]},{"pos":[68469,70029],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method, to ensure that the append operation has completed and resources can be freed appropriately.","pos":[0,240],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous append, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[241,474],"source":" If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[481,594],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[595,693]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[700,830]},{"content":"If the append fails, no space is reserved.","pos":[831,873]},{"content":"Normally, this method may complete before the record has been written.","pos":[880,950]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[951,1169],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1176,1311]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1312,1552],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called."}]},{"pos":[70549,70632],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[70718,70785],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[70871,70928],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[71024,71142],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[71242,71293],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[71363,71398],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[71470,71546],"content":"An optional asynchronous callback, to be called when the append is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the append is complete.","pos":[0,76]}]},{"pos":[71608,71714],"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous append request from other requests.","pos":[0,106]}]},{"pos":[71778,71882],"content":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents this asynchronous operation, which could still be pending.","pos":[0,104],"source":"An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending."}]},{"pos":[72067,72161],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[72276,72322],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[72417,72483],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence."},{"pos":[72586,72681],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[72770,72844],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[72951,73013],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[73114,73182],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[73299,73327],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[73458,73553],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[74471,74605],"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.","pos":[0,134],"nodes":[{"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence.","pos":[0,101]},{"content":"This method cannot be inherited.","pos":[102,134]}]}]},{"pos":[74618,76266],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method, to assure that the restart area write operation has completed and resources can be freed appropriately.","pos":[0,252],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[253,508],"source":" If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[515,628],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[629,727]},{"content":"When the operation successfully completes, the base sequence number has been updated.","pos":[734,819]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[820,914]},{"content":"If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[921,1110],"source":"       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection."},{"content":"If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.","pos":[1111,1257]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1264,1399]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method is called.","pos":[1400,1640],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called."}]},{"pos":[76586,76669],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[76754,76880],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[76970,77101],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[77173,77261],"content":"An optional asynchronous callback, to be called when the restart area write is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the restart area write is complete.","pos":[0,88]}]},{"pos":[77323,77441],"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","pos":[0,118]}]},{"pos":[77505,77627],"content":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.","pos":[0,122],"source":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."}]},{"pos":[77812,77906],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[78022,78206],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[78303,78449],"content":"<code>reservations</code> was not created by this record sequence.       -or-       <code>newBaseSeqNum</code> is not valid for this sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","pos":[0,66],"source":"<code>reservations</code> was not created by this record sequence."},{"content":"-or-       <ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","pos":[73,142],"source":"       -or-       <code>newBaseSeqNum</code> is not valid for this sequence."}]},{"pos":[78553,78648],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[78737,78808],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[78915,78977],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[79078,79146],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[79263,79291],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[79422,79517],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[80524,80658],"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.","pos":[0,134],"nodes":[{"content":"Begins an asynchronous restart area write operation, using space previously reserved in the sequence.","pos":[0,101]},{"content":"This method cannot be inherited.","pos":[102,134]}]}]},{"pos":[80671,82319],"content":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"You should pass the &lt;xref:System.IAsyncResult&gt; returned by this method to the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method, to assure that the restart area write operation has completed and resources can be freed appropriately.","pos":[0,252],"source":"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately."},{"content":"If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method is called with the &lt;xref:System.IAsyncResult&gt; returned by this method.","pos":[253,508],"source":" If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method."},{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[515,628],"source":"       Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[629,727]},{"content":"When the operation successfully completes, the base sequence number has been updated.","pos":[734,819]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[820,914]},{"content":"If a &lt;xref:System.IO.Log.ReservationCollection&gt; is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[921,1110],"source":"       If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection."},{"content":"If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.","pos":[1111,1257]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1264,1399]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A&gt; method is called.","pos":[1400,1640],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called."}]},{"pos":[82707,82790],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[82875,83001],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[83091,83222],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[83294,83382],"content":"An optional asynchronous callback, to be called when the restart area write is complete.","needQuote":true,"needEscape":true,"nodes":[{"content":"An optional asynchronous callback, to be called when the restart area write is complete.","pos":[0,88]}]},{"pos":[83444,83562],"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.","pos":[0,118]}]},{"pos":[83626,83748],"content":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"An &lt;xref:System.IAsyncResult&gt; that represents the asynchronous restart area write operation, which could still be pending.","pos":[0,122],"source":"An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending."}]},{"pos":[83933,84027],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[84143,84327],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[84424,84570],"content":"<code>reservations</code> was not created by this record sequence.       -or-       <code>newBaseSeqNum</code> is not valid for this sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","pos":[0,66],"source":"<code>reservations</code> was not created by this record sequence."},{"content":"-or-       <ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","pos":[73,142],"source":"       -or-       <code>newBaseSeqNum</code> is not valid for this sequence."}]},{"pos":[84674,84769],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[84858,84929],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[85036,85098],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[85199,85267],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[85384,85412],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[85543,85638],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[86090,86194],"content":"Creates a new <xref href=\"System.IO.Log.ReservationCollection\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Creates a new <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,71],"source":"Creates a new <xref href=\"System.IO.Log.ReservationCollection\"></xref>."},{"content":"This method cannot be inherited.","pos":[72,104]}]},{"pos":[86391,86466],"content":"The newly created <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The newly created <xref href=\"System.IO.Log.ReservationCollection\"></xref>."},{"pos":[86655,86723],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[87075,87138],"content":"Immediately releases the unmanaged resources used by an object.","needQuote":true,"needEscape":true,"nodes":[{"content":"Immediately releases the unmanaged resources used by an object.","pos":[0,63]}]},{"pos":[87361,87407],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[87514,87576],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[87677,87745],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[88185,88256],"content":"Ends an asynchronous append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ends an asynchronous append operation. This method cannot be inherited.","pos":[0,71],"nodes":[{"content":"Ends an asynchronous append operation.","pos":[0,38]},{"content":"This method cannot be inherited.","pos":[39,71]}]}]},{"pos":[88269,88633],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> method.","pos":[0,362],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.","pos":[58,201]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.FileRecordSequence.BeginAppend%2A&gt; method.","pos":[208,362],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> method."}]}]},{"pos":[88811,88867],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[88940,88987],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[89152,89183],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>result</code> is invalid."},{"pos":[89294,89409],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation."},{"pos":[89498,89569],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[89676,89738],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[89839,89907],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[90342,90412],"content":"Ends an asynchronous flush operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ends an asynchronous flush operation. This method cannot be inherited.","pos":[0,70],"nodes":[{"content":"Ends an asynchronous flush operation.","pos":[0,37]},{"content":"This method cannot be inherited.","pos":[38,70]}]}]},{"pos":[90425,90787],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> method.","pos":[0,360],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.","pos":[58,200]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.FileRecordSequence.BeginFlush%2A&gt; method.","pos":[207,360],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> method."}]}]},{"pos":[90964,91020],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[91093,91140],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[91304,91335],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>result</code> is invalid."},{"pos":[91446,91561],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation."},{"pos":[91650,91721],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[91828,91890],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[91991,92059],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[92549,92632],"content":"Ends an asynchronous reserve and append operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ends an asynchronous reserve and append operation. This method cannot be inherited.","pos":[0,83],"nodes":[{"content":"Ends an asynchronous reserve and append operation.","pos":[0,50]},{"content":"This method cannot be inherited.","pos":[51,83]}]}]},{"pos":[92645,93029],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> method.","pos":[0,382],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.","pos":[58,211]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A&gt; method.","pos":[218,382],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> method."}]}]},{"pos":[93217,93273],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[93346,93393],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[93568,93599],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>result</code> is invalid."},{"pos":[93710,93825],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation."},{"pos":[93914,93985],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[94092,94154],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[94255,94323],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[94813,94896],"content":"Ends an asynchronous restart area write operation. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ends an asynchronous restart area write operation. This method cannot be inherited.","pos":[0,83],"nodes":[{"content":"Ends an asynchronous restart area write operation.","pos":[0,50]},{"content":"This method cannot be inherited.","pos":[51,83]}]}]},{"pos":[94909,95293],"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> method.","pos":[0,382],"nodes":[{"content":"This method blocks until the I/O operation has completed.","pos":[0,57]},{"content":"Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.","pos":[58,211]},{"content":"This method must be called exactly once on every &lt;xref:System.IAsyncResult&gt; returned by the &lt;xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A&gt; method.","pos":[218,382],"source":"       This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> method."}]}]},{"pos":[95481,95537],"content":"A reference to the outstanding asynchronous I/O request.","needQuote":true,"needEscape":true,"nodes":[{"content":"A reference to the outstanding asynchronous I/O request.","pos":[0,56]}]},{"pos":[95610,95656],"content":"The sequence number of the written log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written log record.","pos":[0,46]}]},{"pos":[95831,95862],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is invalid.","needQuote":true,"needEscape":true,"source":"<code>result</code> is invalid."},{"pos":[95973,96088],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> has already been called for this asynchronous operation.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation."},{"pos":[96177,96248],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[96355,96417],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[96518,96586],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[96928,97013],"content":"Ensures that all appended records have been written. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ensures that all appended records have been written. This method cannot be inherited.","pos":[0,85],"nodes":[{"content":"Ensures that all appended records have been written.","pos":[0,52]},{"content":"This method cannot be inherited.","pos":[53,85]}]}]},{"pos":[97025,97167],"content":"Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> have been durably written.","needQuote":true,"needEscape":true,"nodes":[{"content":"Calling this method ensures that all records that have been appended to the &lt;xref:System.IO.Log.FileRecordSequence&gt; have been durably written.","pos":[0,142],"source":"Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> have been durably written."}]},{"pos":[97328,97375],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[97530,97576],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[97683,97745],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[97846,97914],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[98358,98443],"content":"Ensures that all appended records have been written. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Ensures that all appended records have been written. This method cannot be inherited.","pos":[0,85],"nodes":[{"content":"Ensures that all appended records have been written.","pos":[0,52]},{"content":"This method cannot be inherited.","pos":[53,85]}]}]},{"pos":[98455,98598],"content":"Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.","needQuote":true,"needEscape":true,"nodes":[{"content":"Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.","pos":[0,143]}]},{"pos":[98812,98978],"content":"The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the latest record that must be written.","pos":[0,62]},{"content":"If this <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.SequenceNumber\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> is invalid, then all records must be written.","pos":[63,166],"source":" If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written."}]},{"pos":[99051,99098],"content":"The sequence number of the last record written.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the last record written.","pos":[0,47]}]},{"pos":[99279,99374],"content":"<ph id=\"ph1\">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","needQuote":true,"needEscape":true,"source":"<code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence."},{"pos":[99469,99528],"content":"<ph id=\"ph1\">&lt;code&gt;sequenceNumber&lt;/code&gt;</ph> is not valid for this sequence.","needQuote":true,"needEscape":true,"source":"<code>sequenceNumber</code> is not valid for this sequence."},{"pos":[99617,99663],"content":"An I/O error occurred while flushing the data.","needQuote":true,"needEscape":true,"nodes":[{"content":"An I/O error occurred while flushing the data.","pos":[0,46]}]},{"pos":[99770,99832],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[99933,100001],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[100404,100476],"content":"Gets the sequence number which is greater than the last record appended.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the sequence number which is greater than the last record appended.","pos":[0,72]}]},{"pos":[100488,100802],"content":"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber. All other sequence numbers are invalid.","needQuote":true,"needEscape":true,"nodes":[{"content":"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber. All other sequence numbers are invalid.","pos":[0,314],"nodes":[{"content":"This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.","pos":[0,126]},{"content":"Valid sequence numbers are greater than or equal to &lt;xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A&gt; and less than LastSequenceNumber.","pos":[127,274],"source":" Valid sequence numbers are greater than or equal to <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber."},{"content":"All other sequence numbers are invalid.","pos":[275,314]}]}]},{"pos":[100962,101027],"content":"A sequence number which is greater than the last record appended.","needQuote":true,"needEscape":true,"nodes":[{"content":"A sequence number which is greater than the last record appended.","pos":[0,65]}]},{"pos":[101213,101279],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[101687,101784],"content":"Gets the size of the largest record that can be appended to or read from this sequence, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the size of the largest record that can be appended to or read from this sequence, in bytes.","pos":[0,97]}]},{"pos":[101905,101997],"content":"The size of the largest record that can be appended to or read from this sequence, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the largest record that can be appended to or read from this sequence, in bytes.","pos":[0,92]}]},{"pos":[102184,102250],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[102887,102980],"content":"Returns an enumerable collection of records in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Returns an enumerable collection of records in the sequence. This method cannot be inherited.","pos":[0,93],"nodes":[{"content":"Returns an enumerable collection of records in the sequence.","pos":[0,60]},{"content":"This method cannot be inherited.","pos":[61,93]}]}]},{"pos":[102992,103155],"content":"This method returns an enumerable collection of records in the sequence. The order of the enumerated records depends on the value of the `logRecordEnum` parameter.","needQuote":true,"needEscape":true,"nodes":[{"content":"This method returns an enumerable collection of records in the sequence.","pos":[0,72]},{"content":"The order of the enumerated records depends on the value of the <ph id=\"ph1\">`logRecordEnum`</ph> parameter.","pos":[73,163],"source":" The order of the enumerated records depends on the value of the `logRecordEnum` parameter."}]},{"pos":[103747,103812],"content":"The sequence number of the first record where the reading starts.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the first record where the reading starts.","pos":[0,65]}]},{"pos":[103906,104128],"content":"A valid <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.LogRecordEnumeratorType\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> value that specifies the manner (that is, forward or backward) in which records should be read from a <bpt id=\"p2\">&lt;xref href=\"System.IO.Log.LogRecordSequence\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"A valid <xref href=\"System.IO.Log.LogRecordEnumeratorType\"></xref> value that specifies the manner (that is, forward or backward) in which records should be read from a <xref href=\"System.IO.Log.LogRecordSequence\"></xref>."},{"pos":[104236,104288],"content":"An enumerable collection of records in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An enumerable collection of records in the sequence.","pos":[0,52]}]},{"pos":[104478,104524],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[104627,104723],"content":"The operation cannot be performed because the record sequence was opened with write-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with write-only access.","pos":[0,96]}]},{"pos":[104813,104943],"content":"The record sequence is corrupted.       -or-       The record was written with an incompatible version of the record sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"The record sequence is corrupted.       -or-       The record was written with an incompatible version of the record sequence.","pos":[0,126],"nodes":[{"content":"The record sequence is corrupted.","pos":[0,33]},{"content":"-or-       The record was written with an incompatible version of the record sequence.","pos":[40,126]}]}]},{"pos":[105056,105213],"content":"The enumeration has ended.       -or-       The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.","needQuote":false,"needEscape":true,"nodes":[{"content":"The enumeration has ended.       -or-       The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.","pos":[0,153],"nodes":[{"content":"The enumeration has ended.","pos":[0,26]},{"content":"-or-       The enumeration has not been started.","pos":[33,81]},{"content":"A call to &lt;xref:System.Collections.IEnumerator.MoveNext*&gt; must be made.","pos":[82,153],"source":" A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made."}]}]},{"pos":[105321,105383],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[105484,105552],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[105949,106052],"content":"Returns an enumerable collection of the restart areas in the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Returns an enumerable collection of the restart areas in the sequence. This method cannot be inherited.","pos":[0,103],"nodes":[{"content":"Returns an enumerable collection of the restart areas in the sequence.","pos":[0,70]},{"content":"This method cannot be inherited.","pos":[71,103]}]}]},{"pos":[106064,106322],"content":"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.","needQuote":true,"needEscape":true,"nodes":[{"content":"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.","pos":[0,258],"nodes":[{"content":"The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.","pos":[0,139]},{"content":"Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.","pos":[140,258]}]}]},{"pos":[106564,106626],"content":"An enumerable collection of the restart areas in the sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"An enumerable collection of the restart areas in the sequence.","pos":[0,62]}]},{"pos":[106806,106902],"content":"The operation cannot be performed because the record sequence was opened with write-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with write-only access.","pos":[0,96]}]},{"pos":[106992,107122],"content":"The record sequence is corrupted.       -or-       The record was written with an incompatible version of the record sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"The record sequence is corrupted.       -or-       The record was written with an incompatible version of the record sequence.","pos":[0,126],"nodes":[{"content":"The record sequence is corrupted.","pos":[0,33]},{"content":"-or-       The record was written with an incompatible version of the record sequence.","pos":[40,126]}]}]},{"pos":[107235,107392],"content":"The enumeration has ended.       -or-       The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.","needQuote":false,"needEscape":true,"nodes":[{"content":"The enumeration has ended.       -or-       The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.","pos":[0,153],"nodes":[{"content":"The enumeration has ended.","pos":[0,26]},{"content":"-or-       The enumeration has not been started.","pos":[33,81]},{"content":"A call to &lt;xref:System.Collections.IEnumerator.MoveNext*&gt; must be made.","pos":[82,153],"source":" A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made."}]}]},{"pos":[107500,107562],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[107663,107731],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[108776,108887],"content":"Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.","pos":[0,111],"nodes":[{"content":"Automatically makes a single reservation and appends a record to the sequence.","pos":[0,78]},{"content":"This method cannot be inherited.","pos":[79,111]}]}]},{"pos":[108900,109592],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[219,349]},{"content":"If the append fails, no space is reserved.","pos":[350,392]},{"content":"Normally, this method may complete before the record has been written.","pos":[399,469]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[470,688],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[110017,110100],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[110186,110253],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[110339,110396],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[110492,110610],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[110710,110822],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the collection to make reservations in.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the collection to make reservations in."},{"pos":[110892,110927],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[111000,111047],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[111227,111321],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[111436,111482],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[111577,111644],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence..","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence.."},{"pos":[111747,111842],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[111931,112005],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[112112,112174],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[112275,112343],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[112460,112488],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[113622,113733],"content":"Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.","pos":[0,111],"nodes":[{"content":"Automatically makes a single reservation and appends a record to the sequence.","pos":[0,78]},{"content":"This method cannot be inherited.","pos":[79,111]}]}]},{"pos":[113746,114438],"content":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.       The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.       Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Data contained in the <ph id=\"ph1\">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.","pos":[0,113],"source":"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record."},{"content":"However, no provision is made for splitting data back into array segments when the record is read.","pos":[114,212]},{"content":"The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.","pos":[219,349]},{"content":"If the append fails, no space is reserved.","pos":[350,392]},{"content":"Normally, this method may complete before the record has been written.","pos":[399,469]},{"content":"To ensure that a record has been written, either specify the &lt;xref:System.IO.Log.RecordAppendOptions&gt; flag using the <ph id=\"ph1\">`recordAppendOptions`</ph> parameter, or call the &lt;xref:System.IO.Log.FileRecordSequence.Flush%2A&gt; method.","pos":[470,688],"source":" To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method."}]},{"pos":[114931,115014],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[115100,115167],"content":"The sequence number of the next record in the user-specified order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in the user-specified order.","pos":[0,67]}]},{"pos":[115253,115310],"content":"The sequence number of the next record in Previous order.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the next record in Previous order.","pos":[0,57]}]},{"pos":[115406,115524],"content":"A valid value of <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.RecordAppendOptions\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that specifies how the data should be written.","needQuote":true,"needEscape":true,"source":"A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written."},{"pos":[115624,115675],"content":"The reservation collection to make reservations in.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservation collection to make reservations in.","pos":[0,51]}]},{"pos":[115745,115780],"content":"The reservations to make, in bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The reservations to make, in bytes.","pos":[0,35]}]},{"pos":[115853,115900],"content":"The sequence number of the appended log record.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the appended log record.","pos":[0,47]}]},{"pos":[116080,116174],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[116289,116335],"content":"One or more of the arguments are out of range.","needQuote":true,"needEscape":true,"nodes":[{"content":"One or more of the arguments are out of range.","pos":[0,46]}]},{"pos":[116430,116497],"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence..","needQuote":true,"needEscape":true,"source":"<code>reservations</code> was not created by this record sequence.."},{"pos":[116600,116695],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[116784,116858],"content":"The request could not be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request could not be performed because of an unexpected I/O exception.","pos":[0,74]}]},{"pos":[116965,117027],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[117128,117196],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[117313,117341],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[117719,117774],"content":"Gets the total number of bytes that have been reserved.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the total number of bytes that have been reserved.","pos":[0,55]}]},{"pos":[117889,117953],"content":"The total size of all reservations made in this record sequence.","needQuote":true,"needEscape":true,"nodes":[{"content":"The total size of all reservations made in this record sequence.","pos":[0,64]}]},{"pos":[118134,118200],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[118618,118685],"content":"Gets the sequence number of the most recently written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the sequence number of the most recently written restart area.","pos":[0,67]}]},{"pos":[118697,119170],"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","needQuote":true,"needEscape":true,"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[0,473],"nodes":[{"content":"A restart area is used to temporarily store information containing a client's last checkpoint operation.","pos":[0,104]},{"content":"The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.","pos":[105,229]},{"content":"When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.","pos":[230,344]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[345,473]}]}]},{"pos":[119333,119395],"content":"The sequence number of the most recently written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the most recently written restart area.","pos":[0,62]}]},{"pos":[119584,119650],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[120018,120118],"content":"Gets or sets a value indicating whether or not appends are automatically retried if the log is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets a value indicating whether or not appends are automatically retried if the log is full.","pos":[0,100]}]},{"pos":[120130,120354],"content":"If the value of this property is <ph id=\"ph1\">`true`</ph>, and an &lt;xref:System.IO.Log.FileRecordSequence.Append%2A&gt; call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.","needQuote":true,"needEscape":true,"source":"If the value of this property is `true`, and an <xref:System.IO.Log.FileRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append."},{"pos":[120474,120743],"content":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>. The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.","needQuote":true,"needEscape":true,"nodes":[{"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if appends are automatically retried if the log is full; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","pos":[0,192],"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"content":"The default is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[193,269],"source":" The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>."}]},{"pos":[120922,120988],"content":"The property was accessed after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The property was accessed after the sequence has been disposed of.","pos":[0,66]}]},{"pos":[121348,121460],"content":"Occurs when the record sequence determines that the tail must be moved forward. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Occurs when the record sequence determines that the tail must be moved forward. This method cannot be inherited.","pos":[0,112],"nodes":[{"content":"Occurs when the record sequence determines that the tail must be moved forward.","pos":[0,79]},{"content":"This method cannot be inherited.","pos":[80,112]}]}]},{"pos":[121472,121664],"content":"You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","needQuote":true,"needEscape":true,"nodes":[{"content":"You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","pos":[0,192],"nodes":[{"content":"You can fire this event when the record sequence has run out of space.","pos":[0,70]},{"content":"When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.","pos":[71,192]}]}]},{"pos":[121859,121871],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[122407,122523],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[122536,123221],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","pos":[0,681],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"The data in the byte array segments will be concatenated into a single byte array for appending as the record.","pos":[475,585]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[586,681]}]}]},{"pos":[123421,123504],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[123577,123625],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[123805,123899],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[124002,124097],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[124186,124257],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[124364,124426],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[124527,124595],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[124712,124740],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[125348,125464],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[125477,126162],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.","pos":[0,681],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"The data in the byte array segments will be concatenated into a single byte array for appending as the record.","pos":[475,585]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[586,681]}]}]},{"pos":[126430,126513],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[126586,126634],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[126814,126908],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[127011,127106],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[127195,127266],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[127373,127435],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[127536,127604],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[127721,127749],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[128371,128487],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[128500,129400],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[0,894],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[475,613]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[614,709]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[716,799]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[800,894]}]}]},{"pos":[129644,129727],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[129812,129938],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[130011,130059],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[130239,130333],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[130449,130633],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[130729,130787],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","needQuote":true,"needEscape":true,"source":"<code>newBaseSeqNum</code> is not valid for this sequence."},{"pos":[130890,130985],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[131074,131145],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[131252,131314],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[131415,131483],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[131600,131628],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[132339,132455],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[132468,133368],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[0,894],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[475,613]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[614,709]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[716,799]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[800,894]}]}]},{"pos":[133680,133763],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[133848,133974],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[134047,134095],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[134275,134369],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[134485,134669],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[134765,134823],"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","needQuote":true,"needEscape":true,"source":"<code>newBaseSeqNum</code> is not valid for this sequence."},{"pos":[134926,135021],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[135110,135181],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[135288,135350],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[135451,135519],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[135636,135664],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[136424,136540],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[136553,138155],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","pos":[0,1592],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[475,613]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[614,709]},{"content":"If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[716,874]},{"content":"If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.","pos":[875,1024]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[1031,1114]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[1115,1209]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1216,1351]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1352,1592],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called."}]}]},{"pos":[138449,138532],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[138617,138743],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[138834,138965],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[139038,139086],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[139266,139360],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[139476,139660],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[139757,139903],"content":"<code>reservations</code> was not created by this record sequence.       -or-       <code>newBaseSeqNum</code> is not valid for this sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","pos":[0,66],"source":"<code>reservations</code> was not created by this record sequence."},{"content":"-or-       <ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","pos":[73,142],"source":"       -or-       <code>newBaseSeqNum</code> is not valid for this sequence."}]},{"pos":[140007,140102],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[140191,140262],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[140369,140431],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[140532,140600],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[140717,140745],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[140876,140971],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."},{"pos":[141820,141936],"content":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Writes a restart area to the <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.FileRecordSequence\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,83],"source":"Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>."},{"content":"This method cannot be inherited.","pos":[84,116]}]},{"pos":[141949,143551],"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","needQuote":false,"needEscape":true,"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.       When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.       If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.       When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.       If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.","pos":[0,1592],"nodes":[{"content":"A restart area can be used to temporarily store information containing a client's last checkpoint operation.","pos":[0,108]},{"content":"When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation.","pos":[109,228]},{"content":"This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.","pos":[229,357]},{"content":"A restart area can be read using the &lt;xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A&gt; method.","pos":[364,468],"source":"       A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method."},{"content":"When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.","pos":[475,613]},{"content":"No provision is made for splitting data back into array segments when the restart area is read.","pos":[614,709]},{"content":"If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.","pos":[716,874]},{"content":"If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.","pos":[875,1024]},{"content":"When this method successfully completes, the base sequence number has been updated.","pos":[1031,1114]},{"content":"All log records with sequence numbers less than the new base sequence number are inaccessible.","pos":[1115,1209]},{"content":"If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.","pos":[1216,1351]},{"content":"Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the &lt;xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A&gt; method is called.","pos":[1352,1592],"source":" Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called."}]}]},{"pos":[143913,143996],"content":"A list of byte array segments that will be concatenated and appended as the record.","needQuote":true,"needEscape":true,"nodes":[{"content":"A list of byte array segments that will be concatenated and appended as the record.","pos":[0,83]}]},{"pos":[144081,144207],"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","needQuote":true,"needEscape":true,"nodes":[{"content":"The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.","pos":[0,126],"nodes":[{"content":"The new base sequence number.","pos":[0,29]},{"content":"The specified sequence number must be greater than or equal to the current base sequence number.","pos":[30,126]}]}]},{"pos":[144298,144429],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.IO.Log.ReservationCollection\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that contains the reservation that should be used for this restart area.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area."},{"pos":[144502,144550],"content":"The sequence number of the written restart area.","needQuote":true,"needEscape":true,"nodes":[{"content":"The sequence number of the written restart area.","pos":[0,48]}]},{"pos":[144730,144824],"content":"One or more of the arguments are <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[144940,145124],"content":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.       -or-       A new or existing archive tail or base of the active log is invalid.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not between the base and last sequence numbers of this sequence.","pos":[0,94],"source":"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence."},{"content":"-or-       A new or existing archive tail or base of the active log is invalid.","pos":[101,180]}]},{"pos":[145221,145367],"content":"<code>reservations</code> was not created by this record sequence.       -or-       <code>newBaseSeqNum</code> is not valid for this sequence.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;reservations&lt;/code&gt;</ph> was not created by this record sequence.","pos":[0,66],"source":"<code>reservations</code> was not created by this record sequence."},{"content":"-or-       <ph id=\"ph1\">&lt;code&gt;newBaseSeqNum&lt;/code&gt;</ph> is not valid for this sequence.","pos":[73,142],"source":"       -or-       <code>newBaseSeqNum</code> is not valid for this sequence."}]},{"pos":[145471,145566],"content":"The operation cannot be performed because the record sequence was opened with read-only access.","needQuote":true,"needEscape":true,"nodes":[{"content":"The operation cannot be performed because the record sequence was opened with read-only access.","pos":[0,95]}]},{"pos":[145655,145726],"content":"The request cannot be performed because of an unexpected I/O exception.","needQuote":true,"needEscape":true,"nodes":[{"content":"The request cannot be performed because of an unexpected I/O exception.","pos":[0,71]}]},{"pos":[145833,145895],"content":"The method was called after the sequence has been disposed of.","needQuote":true,"needEscape":true,"nodes":[{"content":"The method was called after the sequence has been disposed of.","pos":[0,62]}]},{"pos":[145996,146064],"content":"There is not enough memory to continue the execution of the program.","needQuote":true,"needEscape":true,"nodes":[{"content":"There is not enough memory to continue the execution of the program.","pos":[0,68]}]},{"pos":[146181,146209],"content":"The record sequence is full.","needQuote":true,"needEscape":true,"nodes":[{"content":"The record sequence is full.","pos":[0,28]}]},{"pos":[146340,146435],"content":"No reservation large enough to fit <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">data</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be found in <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">reservations</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","needQuote":true,"needEscape":true,"source":"No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>."}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.IO.Log.FileRecordSequence\n  id: FileRecordSequence\n  children:\n  - System.IO.Log.FileRecordSequence.#ctor(System.String)\n  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)\n  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)\n  - System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  - System.IO.Log.FileRecordSequence.BaseSequenceNumber\n  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  - System.IO.Log.FileRecordSequence.CreateReservationCollection\n  - System.IO.Log.FileRecordSequence.Dispose\n  - System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)\n  - System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)\n  - System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  - System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  - System.IO.Log.FileRecordSequence.Flush\n  - System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  - System.IO.Log.FileRecordSequence.LastSequenceNumber\n  - System.IO.Log.FileRecordSequence.MaximumRecordLength\n  - System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  - System.IO.Log.FileRecordSequence.ReadRestartAreas\n  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  - System.IO.Log.FileRecordSequence.ReservedBytes\n  - System.IO.Log.FileRecordSequence.RestartSequenceNumber\n  - System.IO.Log.FileRecordSequence.RetryAppend\n  - System.IO.Log.FileRecordSequence.TailPinned\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  langs:\n  - csharp\n  name: FileRecordSequence\n  nameWithType: FileRecordSequence\n  fullName: System.IO.Log.FileRecordSequence\n  type: Class\n  summary: Implements an <xref href=\"System.IO.Log.IRecordSequence\"></xref> on top of a file. This class cannot be inherited.\n  remarks: \"The FileRecordSequence is a record sequence based on a single log file in the file system. It is a simple implementation of the <xref:System.IO.Log.IRecordSequence> interface, on top of a simple file-based log.  \\n  \\n To manipulate a file-based log, the account that your application is running in must have sufficient privileges, as dictated by the file system security at the time the FileRecordSequence is constructed. In addition, a demand for FullTrust is made at construction time. The permission verification results are cached thereafter in keeping with the Windows security model. You should ensure that you do not accidentally expose the contents of the record sequence to an unauthorized user.\"\n  example:\n  - \"The following example creates a record sequence, appends record to it, and finally reads the records.  \\n  \\n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/t-system.io.log.filereco_1.vb)]\\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/t-system.io.log.filereco_1.cs)]\"\n  syntax:\n    content: 'public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence'\n  inheritance:\n  - System.Object\n  implements:\n  - System.IDisposable\n  - System.IO.Log.IRecordSequence\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)\n  id: '#ctor(System.String)'\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: FileRecordSequence(String)\n  nameWithType: FileRecordSequence.FileRecordSequence(String)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)\n  type: Constructor\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file.\n  remarks: This constructor creates read/write access to the file, and opens the file with share Read access. This means that requests to open the file for writing by this or another process fails until this <xref:System.IO.Log.FileRecordSequence> instance has been disposed of, but read attempts will succeed. If `path` is not found, a new file is created with a size of 0 bytes.\n  example:\n  - \"The following example creates a record sequence, appends record to it, reads the records, and finally diposes the sequence.  \\n  \\n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/m-system.io.log.filereco_1.vb)]\\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/m-system.io.log.filereco_1.cs)]\"\n  syntax:\n    content: public FileRecordSequence (string path);\n    parameters:\n    - id: path\n      type: System.String\n      description: A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate.\n  overload: System.IO.Log.FileRecordSequence.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The file specified by <code>path</code> is not valid.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file specified by <code>path</code> cannot be found.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: Access for the specified log store is denied by the operating system.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)\n  id: '#ctor(System.String,System.IO.FileAccess)'\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: FileRecordSequence(String,FileAccess)\n  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)\n  type: Constructor\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file and an access mode.\n  syntax:\n    content: public FileRecordSequence (string path, System.IO.FileAccess access);\n    parameters:\n    - id: path\n      type: System.String\n      description: A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate.\n    - id: access\n      type: System.IO.FileAccess\n      description: A valid <xref href=\"System.IO.FileAccess\"></xref> value that controls the kind of access users have to a log file.\n  overload: System.IO.Log.FileRecordSequence.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The file specified by <code>path</code> is not valid.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file specified by <code>path</code> cannot be found.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: Access for the specified log store is denied by the operating system.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)\n  id: '#ctor(System.String,System.IO.FileAccess,System.Int32)'\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: FileRecordSequence(String,FileAccess,Int32)\n  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)\n  type: Constructor\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Initializes a new instance of the <xref href=\"System.IO.Log.FileRecordSequence\"></xref> class with a specified file, an access mode, and a file size.\n  syntax:\n    content: public FileRecordSequence (string path, System.IO.FileAccess access, int size);\n    parameters:\n    - id: path\n      type: System.String\n      description: A relative or absolute path for the file that this <xref href=\"System.IO.Log.FileRecordSequence\"></xref> instance will encapsulate.\n    - id: access\n      type: System.IO.FileAccess\n      description: A valid <xref href=\"System.IO.FileAccess\"></xref> value that controls the kind of access users have to a log file.\n    - id: size\n      type: System.Int32\n      description: The size of the log file to be opened.\n  overload: System.IO.Log.FileRecordSequence.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the parameters are out of the valid range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The file specified by <code>path</code> is not valid.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file specified by <code>path</code> cannot be found.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: Access for the specified log store is denied by the operating system.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: AdvanceBaseSequenceNumber(SequenceNumber)\n  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Moves the base sequence number of the log forward. This method cannot be inherited.\n  syntax:\n    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);\n    parameters:\n    - id: newBaseSequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number of the record sequence.\n  overload: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>newBaseSequenceNumber</code> is invalid.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>newBaseSequenceNumber</code> is not between the base and last sequence numbers of this sequence.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while modifying the sequence.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  example:\n  - \"The following example creates a record sequence, appends record to it, and finally reads the records.  \\n  \\n [!code-cs[FileRecordSequence#0](~/add/codesnippet/csharp/10554b85-231e-4dbf-ad02-_1.cs)]\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  example:\n  - \"The following example shows how you can create a record sequence with this method.  \\n  \\n [!code-vb[IRecordSequence#3](~/add/codesnippet/visualbasic/5cdfd57c-5dff-4f9a-a7e0-_1.vb)]\\n [!code-cs[IRecordSequence#3](~/add/codesnippet/csharp/5cdfd57c-5dff-4f9a-a7e0-_1.cs)]\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence..\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a log record to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>, using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.Append*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence..\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber\n  id: BaseSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BaseSequenceNumber\n  nameWithType: FileRecordSequence.BaseSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets the sequence number of the first valid record in the current <xref href=\"System.IO.Log.FileRecordSequence\"></xref>.\n  remarks: \"Valid sequence numbers are greater than or equal to BaseSequenceNumber and less than <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>. All other sequence numbers are invalid.  \\n  \\n The value of this property can be changed by calling the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> or <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> method.\"\n  example:\n  - \"The following example shows using BaseSequenceNumber in a loop:  \\n  \\n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/p-system.io.log.filereco_1.vb)]\\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/p-system.io.log.filereco_1.cs)]\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The lowest sequence number that corresponds to a valid record in the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>.\n  overload: System.IO.Log.FileRecordSequence.BaseSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous append operation. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous append operation. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous append operation using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  \\n  \\n Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this record.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous append, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginFlush(SequenceNumber,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous flush operation, using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately. If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> are durably written.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);\n    parameters:\n    - id: sequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the latest record that must be written. If <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the flush is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous flush request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous flush operation, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginFlush*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"One or more of the arguments is invalid.  \\n  \\n <code>sequenceNumber</code> is not valid for this sequence.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous reserve and append operation. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous reserve and append operation. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the append is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous append request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents this asynchronous operation, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the restart area write is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>reservations</code> was not created by this record sequence.  \\n  \\n -or-  \\n  \\n <code>newBaseSeqNum</code> is not valid for this sequence.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Begins an asynchronous restart area write operation, using space previously reserved in the sequence. This method cannot be inherited.\n  remarks: \"You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  \\n  \\n Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n When the operation successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> method is called.\"\n  syntax:\n    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservation\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    - id: callback\n      type: System.AsyncCallback\n      description: An optional asynchronous callback, to be called when the restart area write is complete.\n    - id: state\n      type: System.Object\n      description: A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.\n    return:\n      type: System.IAsyncResult\n      description: An <xref:System.IAsyncResult> that represents the asynchronous restart area write operation, which could still be pending.\n  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>reservations</code> was not created by this record sequence.  \\n  \\n -or-  \\n  \\n <code>newBaseSeqNum</code> is not valid for this sequence.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection\n  id: CreateReservationCollection\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: CreateReservationCollection()\n  nameWithType: FileRecordSequence.CreateReservationCollection()\n  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Creates a new <xref href=\"System.IO.Log.ReservationCollection\"></xref>. This method cannot be inherited.\n  syntax:\n    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();\n    parameters: []\n    return:\n      type: System.IO.Log.ReservationCollection\n      description: The newly created <xref href=\"System.IO.Log.ReservationCollection\"></xref>.\n  overload: System.IO.Log.FileRecordSequence.CreateReservationCollection*\n  exceptions:\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Dispose\n  id: Dispose\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: FileRecordSequence.Dispose()\n  fullName: System.IO.Log.FileRecordSequence.Dispose()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Immediately releases the unmanaged resources used by an object.\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.IO.Log.FileRecordSequence.Dispose*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)\n  id: EndAppend(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: EndAppend(IAsyncResult)\n  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ends an asynchronous append operation. This method cannot be inherited.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndAppend is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.EndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> is invalid.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)\n  id: EndFlush(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: EndFlush(IAsyncResult)\n  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ends an asynchronous flush operation. This method cannot be inherited.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when EndFlush is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.FileRecordSequence.EndFlush*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> is invalid.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  id: EndReserveAndAppend(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: EndReserveAndAppend(IAsyncResult)\n  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ends an asynchronous reserve and append operation. This method cannot be inherited.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndReserveAndAppend is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.EndReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> is invalid.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  id: EndWriteRestartArea(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: EndWriteRestartArea(IAsyncResult)\n  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ends an asynchronous restart area write operation. This method cannot be inherited.\n  remarks: \"This method blocks until the I/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when EndWriteRestartArea is called.  \\n  \\n This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: A reference to the outstanding asynchronous I/O request.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written log record.\n  overload: System.IO.Log.FileRecordSequence.EndWriteRestartArea*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> is invalid.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref uid=\"langword_csharp_End\" name=\"End\" href=\"\"></xref> has already been called for this asynchronous operation.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Flush\n  id: Flush\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Flush()\n  nameWithType: FileRecordSequence.Flush()\n  fullName: System.IO.Log.FileRecordSequence.Flush()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ensures that all appended records have been written. This method cannot be inherited.\n  remarks: Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.FileRecordSequence> have been durably written.\n  syntax:\n    content: public System.IO.Log.SequenceNumber Flush ();\n    parameters: []\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.FileRecordSequence.Flush*\n  exceptions:\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  id: Flush(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: Flush(SequenceNumber)\n  nameWithType: FileRecordSequence.Flush(SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Ensures that all appended records have been written. This method cannot be inherited.\n  remarks: Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.\n  syntax:\n    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);\n    parameters:\n    - id: sequenceNumber\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the latest record that must be written. If this <xref href=\"System.IO.Log.SequenceNumber\"></xref> is invalid, then all records must be written.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the last record written.\n  overload: System.IO.Log.FileRecordSequence.Flush*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>sequenceNumber</code> is not between the base and last sequence numbers of this sequence.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>sequenceNumber</code> is not valid for this sequence.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: An I/O error occurred while flushing the data.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber\n  id: LastSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: LastSequenceNumber\n  nameWithType: FileRecordSequence.LastSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets the sequence number which is greater than the last record appended.\n  remarks: This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record. Valid sequence numbers are greater than or equal to <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> and less than LastSequenceNumber. All other sequence numbers are invalid.\n  syntax:\n    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: A sequence number which is greater than the last record appended.\n  overload: System.IO.Log.FileRecordSequence.LastSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength\n  id: MaximumRecordLength\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: MaximumRecordLength\n  nameWithType: FileRecordSequence.MaximumRecordLength\n  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets the size of the largest record that can be appended to or read from this sequence, in bytes.\n  syntax:\n    content: public long MaximumRecordLength { get; }\n    return:\n      type: System.Int64\n      description: The size of the largest record that can be appended to or read from this sequence, in bytes.\n  overload: System.IO.Log.FileRecordSequence.MaximumRecordLength*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Returns an enumerable collection of records in the sequence. This method cannot be inherited.\n  remarks: This method returns an enumerable collection of records in the sequence. The order of the enumerated records depends on the value of the `logRecordEnum` parameter.\n  example:\n  - \"The following example shows how you can use this method to read the records in a log sequence.  \\n  \\n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/5d31b2a4-d7cf-41cf-80bb-_1.vb)]\\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/5d31b2a4-d7cf-41cf-80bb-_1.cs)]\"\n  syntax:\n    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);\n    parameters:\n    - id: start\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the first record where the reading starts.\n    - id: logRecordEnum\n      type: System.IO.Log.LogRecordEnumeratorType\n      description: A valid <xref href=\"System.IO.Log.LogRecordEnumeratorType\"></xref> value that specifies the manner (that is, forward or backward) in which records should be read from a <xref href=\"System.IO.Log.LogRecordSequence\"></xref>.\n    return:\n      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n      description: An enumerable collection of records in the sequence.\n  overload: System.IO.Log.FileRecordSequence.ReadLogRecords*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with write-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: \"The record sequence is corrupted.  \\n  \\n -or-  \\n  \\n The record was written with an incompatible version of the record sequence.\"\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The enumeration has ended.  \\n  \\n -or-  \\n  \\n The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas\n  id: ReadRestartAreas\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: ReadRestartAreas()\n  nameWithType: FileRecordSequence.ReadRestartAreas()\n  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Returns an enumerable collection of the restart areas in the sequence. This method cannot be inherited.\n  remarks: The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number. Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.\n  syntax:\n    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();\n    parameters: []\n    return:\n      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n      description: An enumerable collection of the restart areas in the sequence.\n  overload: System.IO.Log.FileRecordSequence.ReadRestartAreas*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with write-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: \"The record sequence is corrupted.  \\n  \\n -or-  \\n  \\n The record was written with an incompatible version of the record sequence.\"\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The enumeration has ended.  \\n  \\n -or-  \\n  \\n The enumeration has not been started. A call to <xref:System.Collections.IEnumerator.MoveNext*> must be made.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence..\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Automatically makes a single reservation and appends a record to the sequence. This method cannot be inherited.\n  remarks: \"Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  \\n  \\n The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation. If the append fails, no space is reserved.  \\n  \\n Normally, this method may complete before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: nextUndoRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in the user-specified order.\n    - id: previousRecord\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the next record in Previous order.\n    - id: recordAppendOptions\n      type: System.IO.Log.RecordAppendOptions\n      description: A valid value of <xref href=\"System.IO.Log.RecordAppendOptions\"></xref> that specifies how the data should be written.\n    - id: reservationCollection\n      type: System.IO.Log.ReservationCollection\n      description: The reservation collection to make reservations in.\n    - id: reservations\n      type: System.Int64[]\n      description: The reservations to make, in bytes.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the appended log record.\n  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: One or more of the arguments are out of range.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>reservations</code> was not created by this record sequence..\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request could not be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.ReservedBytes\n  id: ReservedBytes\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: ReservedBytes\n  nameWithType: FileRecordSequence.ReservedBytes\n  fullName: System.IO.Log.FileRecordSequence.ReservedBytes\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets the total number of bytes that have been reserved.\n  syntax:\n    content: public long ReservedBytes { get; }\n    return:\n      type: System.Int64\n      description: The total size of all reservations made in this record sequence.\n  overload: System.IO.Log.FileRecordSequence.ReservedBytes*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber\n  id: RestartSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: RestartSequenceNumber\n  nameWithType: FileRecordSequence.RestartSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets the sequence number of the most recently written restart area.\n  remarks: A restart area is used to temporarily store information containing a client's last checkpoint operation. The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available. When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.\n  syntax:\n    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the most recently written restart area.\n  overload: System.IO.Log.FileRecordSequence.RestartSequenceNumber*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.RetryAppend\n  id: RetryAppend\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: RetryAppend\n  nameWithType: FileRecordSequence.RetryAppend\n  fullName: System.IO.Log.FileRecordSequence.RetryAppend\n  type: Property\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Gets or sets a value indicating whether or not appends are automatically retried if the log is full.\n  remarks: If the value of this property is `true`, and an <xref:System.IO.Log.FileRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.\n  syntax:\n    content: public bool RetryAppend { get; set; }\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if appends are automatically retried if the log is full; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>. The default is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>.\n  overload: System.IO.Log.FileRecordSequence.RetryAppend*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The property was accessed after the sequence has been disposed of.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.TailPinned\n  id: TailPinned\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: TailPinned\n  nameWithType: FileRecordSequence.TailPinned\n  fullName: System.IO.Log.FileRecordSequence.TailPinned\n  type: Event\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Occurs when the record sequence determines that the tail must be moved forward. This method cannot be inherited.\n  remarks: You can fire this event when the record sequence has run out of space. When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.\n  syntax:\n    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;\n    return:\n      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  id: WriteRestartArea(System.ArraySegment{System.Byte})\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n The data in the byte array segments will be concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>newBaseSeqNum</code> is not valid for this sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>newBaseSeqNum</code> is not valid for this sequence.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.ArraySegment{System.Byte}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>reservations</code> was not created by this record sequence.  \\n  \\n -or-  \\n  \\n <code>newBaseSeqNum</code> is not valid for this sequence.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  langs:\n  - csharp\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  type: Method\n  assemblies:\n  - System.IO.Log\n  namespace: System.IO.Log\n  summary: Writes a restart area to the <xref href=\"System.IO.Log.FileRecordSequence\"></xref>. This method cannot be inherited.\n  remarks: \"A restart area can be used to temporarily store information containing a client's last checkpoint operation. When a recovery is necessary, you can read a restart area and retrieve all the data from the last checkpoint operation. This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.  \\n  \\n A restart area can be read using the <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> method.  \\n  \\n When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record. No provision is made for splitting data back into array segments when the restart area is read.  \\n  \\n If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection. If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.  \\n  \\n When this method successfully completes, the base sequence number has been updated. All log records with sequence numbers less than the new base sequence number are inaccessible.  \\n  \\n If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation. Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> method is called.\"\n  syntax:\n    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);\n    parameters:\n    - id: data\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of byte array segments that will be concatenated and appended as the record.\n    - id: newBaseSeqNum\n      type: System.IO.Log.SequenceNumber\n      description: The new base sequence number. The specified sequence number must be greater than or equal to the current base sequence number.\n    - id: reservations\n      type: System.IO.Log.ReservationCollection\n      description: A <xref href=\"System.IO.Log.ReservationCollection\"></xref> that contains the reservation that should be used for this restart area.\n    return:\n      type: System.IO.Log.SequenceNumber\n      description: The sequence number of the written restart area.\n  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: One or more of the arguments are <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>newBaseSeqNum</code> is not between the base and last sequence numbers of this sequence.  \\n  \\n -or-  \\n  \\n A new or existing archive tail or base of the active log is invalid.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>reservations</code> was not created by this record sequence.  \\n  \\n -or-  \\n  \\n <code>newBaseSeqNum</code> is not valid for this sequence.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operation cannot be performed because the record sequence was opened with read-only access.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: The request cannot be performed because of an unexpected I/O exception.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The method was called after the sequence has been disposed of.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: There is not enough memory to continue the execution of the program.\n  - type: System.IO.Log.SequenceFullException\n    commentId: T:System.IO.Log.SequenceFullException\n    description: The record sequence is full.\n  - type: System.IO.Log.ReservationNotFoundException\n    commentId: T:System.IO.Log.ReservationNotFoundException\n    description: No reservation large enough to fit <code>data</code> can be found in <code>reservations</code>.\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.IO.FileNotFoundException\n  isExternal: true\n  name: System.IO.FileNotFoundException\n- uid: System.IO.IOException\n  isExternal: true\n  name: System.IO.IOException\n- uid: System.OutOfMemoryException\n  isExternal: true\n  name: System.OutOfMemoryException\n- uid: System.UnauthorizedAccessException\n  isExternal: true\n  name: System.UnauthorizedAccessException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.ObjectDisposedException\n  isExternal: true\n  name: System.ObjectDisposedException\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.NotSupportedException\n  isExternal: true\n  name: System.NotSupportedException\n- uid: System.IO.Log.SequenceFullException\n  parent: System.IO.Log\n  isExternal: false\n  name: SequenceFullException\n  nameWithType: SequenceFullException\n  fullName: System.IO.Log.SequenceFullException\n- uid: System.IO.Log.ReservationNotFoundException\n  parent: System.IO.Log\n  isExternal: false\n  name: ReservationNotFoundException\n  nameWithType: ReservationNotFoundException\n  fullName: System.IO.Log.ReservationNotFoundException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: FileRecordSequence(String)\n  nameWithType: FileRecordSequence.FileRecordSequence(String)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: FileRecordSequence(String,FileAccess)\n  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)\n- uid: System.IO.FileAccess\n  parent: System.IO\n  isExternal: false\n  name: FileAccess\n  nameWithType: FileAccess\n  fullName: System.IO.FileAccess\n- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: FileRecordSequence(String,FileAccess,Int32)\n  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)\n  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: AdvanceBaseSequenceNumber(SequenceNumber)\n  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)\n- uid: System.IO.Log.SequenceNumber\n  parent: System.IO.Log\n  isExternal: false\n  name: SequenceNumber\n  nameWithType: SequenceNumber\n  fullName: System.IO.Log.SequenceNumber\n- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n- uid: System.ArraySegment{System.Byte}\n  parent: System\n  isExternal: true\n  name: ArraySegment<Byte>\n  nameWithType: ArraySegment<Byte>\n  fullName: System.ArraySegment<System.Byte>\n  spec.csharp:\n  - uid: System.ArraySegment`1\n    name: ArraySegment\n    nameWithType: ArraySegment\n    fullName: ArraySegment<System.Byte>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.RecordAppendOptions\n  parent: System.IO.Log\n  isExternal: false\n  name: RecordAppendOptions\n  nameWithType: RecordAppendOptions\n  fullName: System.IO.Log.RecordAppendOptions\n- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)\n- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n  parent: System.Collections.Generic\n  isExternal: true\n  name: IList<ArraySegment<Byte>>\n  nameWithType: IList<ArraySegment<Byte>>\n  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    nameWithType: IList\n    fullName: IList<System.ArraySegment<System.Byte>>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.ArraySegment`1\n    name: ArraySegment\n    nameWithType: ArraySegment\n    fullName: ArraySegment<System.Byte>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n- uid: System.IO.Log.ReservationCollection\n  parent: System.IO.Log\n  isExternal: false\n  name: ReservationCollection\n  nameWithType: ReservationCollection\n  fullName: System.IO.Log.ReservationCollection\n- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)\n- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BaseSequenceNumber\n  nameWithType: FileRecordSequence.BaseSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: true\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: true\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginFlush(SequenceNumber,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n- uid: System.Int64[]\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64[]\n  spec.csharp:\n  - uid: System.Int64\n    name: Int64\n    nameWithType: Int64\n    fullName: Int64[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)\n- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: CreateReservationCollection()\n  nameWithType: FileRecordSequence.CreateReservationCollection()\n  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()\n- uid: System.IO.Log.FileRecordSequence.Dispose\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Dispose()\n  nameWithType: FileRecordSequence.Dispose()\n  fullName: System.IO.Log.FileRecordSequence.Dispose()\n- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndAppend(IAsyncResult)\n  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)\n- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndFlush(IAsyncResult)\n  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)\n- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndReserveAndAppend(IAsyncResult)\n  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)\n- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndWriteRestartArea(IAsyncResult)\n  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)\n  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)\n- uid: System.IO.Log.FileRecordSequence.Flush\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Flush()\n  nameWithType: FileRecordSequence.Flush()\n  fullName: System.IO.Log.FileRecordSequence.Flush()\n- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Flush(SequenceNumber)\n  nameWithType: FileRecordSequence.Flush(SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)\n- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: LastSequenceNumber\n  nameWithType: FileRecordSequence.LastSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: MaximumRecordLength\n  nameWithType: FileRecordSequence.MaximumRecordLength\n  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength\n- uid: System.Int64\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)\n- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}\n  parent: System.Collections.Generic\n  isExternal: true\n  name: IEnumerable<LogRecord>\n  nameWithType: IEnumerable<LogRecord>\n  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    nameWithType: IEnumerable\n    fullName: IEnumerable<System.IO.Log.LogRecord>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.IO.Log.LogRecord\n    name: LogRecord\n    nameWithType: LogRecord\n    fullName: LogRecord\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.LogRecordEnumeratorType\n  parent: System.IO.Log\n  isExternal: false\n  name: LogRecordEnumeratorType\n  nameWithType: LogRecordEnumeratorType\n  fullName: System.IO.Log.LogRecordEnumeratorType\n- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReadRestartAreas()\n  nameWithType: FileRecordSequence.ReadRestartAreas()\n  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()\n- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])\n- uid: System.IO.Log.FileRecordSequence.ReservedBytes\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReservedBytes\n  nameWithType: FileRecordSequence.ReservedBytes\n  fullName: System.IO.Log.FileRecordSequence.ReservedBytes\n- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: RestartSequenceNumber\n  nameWithType: FileRecordSequence.RestartSequenceNumber\n  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.RetryAppend\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: RetryAppend\n  nameWithType: FileRecordSequence.RetryAppend\n  fullName: System.IO.Log.FileRecordSequence.RetryAppend\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.IO.Log.FileRecordSequence.TailPinned\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: TailPinned\n  nameWithType: FileRecordSequence.TailPinned\n  fullName: System.IO.Log.FileRecordSequence.TailPinned\n- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}\n  parent: System\n  isExternal: true\n  name: EventHandler<TailPinnedEventArgs>\n  nameWithType: EventHandler<TailPinnedEventArgs>\n  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>\n  spec.csharp:\n  - uid: System.EventHandler`1\n    name: EventHandler\n    nameWithType: EventHandler\n    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.IO.Log.TailPinnedEventArgs\n    name: TailPinnedEventArgs\n    nameWithType: TailPinnedEventArgs\n    fullName: TailPinnedEventArgs\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)\n- uid: System.IO.Log.FileRecordSequence.#ctor*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: FileRecordSequence\n  nameWithType: FileRecordSequence.FileRecordSequence\n- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: AdvanceBaseSequenceNumber\n  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.Append*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Append\n  nameWithType: FileRecordSequence.Append\n- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BaseSequenceNumber\n  nameWithType: FileRecordSequence.BaseSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.BeginAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginAppend\n  nameWithType: FileRecordSequence.BeginAppend\n- uid: System.IO.Log.FileRecordSequence.BeginFlush*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginFlush\n  nameWithType: FileRecordSequence.BeginFlush\n- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginReserveAndAppend\n  nameWithType: FileRecordSequence.BeginReserveAndAppend\n- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: BeginWriteRestartArea\n  nameWithType: FileRecordSequence.BeginWriteRestartArea\n- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: CreateReservationCollection\n  nameWithType: FileRecordSequence.CreateReservationCollection\n- uid: System.IO.Log.FileRecordSequence.Dispose*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Dispose\n  nameWithType: FileRecordSequence.Dispose\n- uid: System.IO.Log.FileRecordSequence.EndAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndAppend\n  nameWithType: FileRecordSequence.EndAppend\n- uid: System.IO.Log.FileRecordSequence.EndFlush*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndFlush\n  nameWithType: FileRecordSequence.EndFlush\n- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndReserveAndAppend\n  nameWithType: FileRecordSequence.EndReserveAndAppend\n- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: EndWriteRestartArea\n  nameWithType: FileRecordSequence.EndWriteRestartArea\n- uid: System.IO.Log.FileRecordSequence.Flush*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: Flush\n  nameWithType: FileRecordSequence.Flush\n- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: LastSequenceNumber\n  nameWithType: FileRecordSequence.LastSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: MaximumRecordLength\n  nameWithType: FileRecordSequence.MaximumRecordLength\n- uid: System.IO.Log.FileRecordSequence.ReadLogRecords*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReadLogRecords\n  nameWithType: FileRecordSequence.ReadLogRecords\n- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReadRestartAreas\n  nameWithType: FileRecordSequence.ReadRestartAreas\n- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReserveAndAppend\n  nameWithType: FileRecordSequence.ReserveAndAppend\n- uid: System.IO.Log.FileRecordSequence.ReservedBytes*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: ReservedBytes\n  nameWithType: FileRecordSequence.ReservedBytes\n- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: RestartSequenceNumber\n  nameWithType: FileRecordSequence.RestartSequenceNumber\n- uid: System.IO.Log.FileRecordSequence.RetryAppend*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: RetryAppend\n  nameWithType: FileRecordSequence.RetryAppend\n- uid: System.IO.Log.FileRecordSequence.WriteRestartArea*\n  parent: System.IO.Log.FileRecordSequence\n  isExternal: false\n  name: WriteRestartArea\n  nameWithType: FileRecordSequence.WriteRestartArea\n"}