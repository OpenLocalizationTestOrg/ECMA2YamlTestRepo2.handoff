{"nodes":[{"pos":[435,536],"content":"Allows managed code to call into unmanaged code without a stack walk. This class cannot be inherited.","needQuote":true,"needEscape":true,"nodes":[{"content":"Allows managed code to call into unmanaged code without a stack walk. This class cannot be inherited.","pos":[0,101],"nodes":[{"content":"Allows managed code to call into unmanaged code without a stack walk.","pos":[0,69]},{"content":"This class cannot be inherited.","pos":[70,101]}]}]},{"pos":[549,2628],"content":"> [!CAUTION] >  Use this attribute with extreme care. Incorrect use can create security weaknesses.       This attribute can be applied to methods that want to call into native code without incurring the performance loss of a run-time security check when doing so. The stack walk performed when calling unmanaged code is omitted at run time, resulting in substantial performance savings. Using this attribute in a class applies it to all contained methods.       Generally, whenever managed code calls into unmanaged code (by PInvoke or COM interop into native code), there is a demand for the `UnmanagedCode` permission to ensure all callers have the necessary permission to allow this. By applying this explicit attribute, developers can suppress the demand at run time. The developer must take responsibility for assuring that the transition into unmanaged code is sufficiently protected by other means. The demand for the `UnmanagedCode` permission will still occur at link time. For example, if function A calls function B and function B is marked with SuppressUnmanagedCodeSecurityAttribute, function A will be checked for unmanaged code permission during just-in-time compilation, but not subsequently during run time.       This attribute is only effective when applied to PInvoke methods (or classes that contain PInvoke methods) or the definition of an interface through which interop calls will be made. It will be ignored in all other contexts.       This attribute is useful for implementing a class that provides access to system resources through unmanaged code. Code that does not have permission to access unmanaged code can call a class with this attribute to access unmanaged code. This is only safe if the writer of the class with this attribute has programmed the class to be secure. If not, this attribute is dangerous and can allow the code that uses it to be misused.       This is not a declarative security attribute, but a regular attribute (it derives from <xref:System.Attribute>, not <xref:System.Security.Permissions.SecurityAttribute>).","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&gt; [!CAUTION]</ph> &gt;  Use this attribute with extreme care.","pos":[0,53],"source":"> [!CAUTION] >  Use this attribute with extreme care."},{"content":"Incorrect use can create security weaknesses.","pos":[54,99]},{"content":"This attribute can be applied to methods that want to call into native code without incurring the performance loss of a run-time security check when doing so.","pos":[106,264]},{"content":"The stack walk performed when calling unmanaged code is omitted at run time, resulting in substantial performance savings.","pos":[265,387]},{"content":"Using this attribute in a class applies it to all contained methods.","pos":[388,456]},{"content":"Generally, whenever managed code calls into unmanaged code (by PInvoke or COM interop into native code), there is a demand for the <ph id=\"ph1\">`UnmanagedCode`</ph> permission to ensure all callers have the necessary permission to allow this.","pos":[463,687],"source":"       Generally, whenever managed code calls into unmanaged code (by PInvoke or COM interop into native code), there is a demand for the `UnmanagedCode` permission to ensure all callers have the necessary permission to allow this."},{"content":"By applying this explicit attribute, developers can suppress the demand at run time.","pos":[688,772]},{"content":"The developer must take responsibility for assuring that the transition into unmanaged code is sufficiently protected by other means.","pos":[773,906]},{"content":"The demand for the <ph id=\"ph1\">`UnmanagedCode`</ph> permission will still occur at link time.","pos":[907,983],"source":" The demand for the `UnmanagedCode` permission will still occur at link time."},{"content":"For example, if function A calls function B and function B is marked with SuppressUnmanagedCodeSecurityAttribute, function A will be checked for unmanaged code permission during just-in-time compilation, but not subsequently during run time.","pos":[984,1225]},{"content":"This attribute is only effective when applied to PInvoke methods (or classes that contain PInvoke methods) or the definition of an interface through which interop calls will be made.","pos":[1232,1414]},{"content":"It will be ignored in all other contexts.","pos":[1415,1456]},{"content":"This attribute is useful for implementing a class that provides access to system resources through unmanaged code.","pos":[1463,1577]},{"content":"Code that does not have permission to access unmanaged code can call a class with this attribute to access unmanaged code.","pos":[1578,1700]},{"content":"This is only safe if the writer of the class with this attribute has programmed the class to be secure.","pos":[1701,1804]},{"content":"If not, this attribute is dangerous and can allow the code that uses it to be misused.","pos":[1805,1891]},{"content":"This is not a declarative security attribute, but a regular attribute (it derives from &lt;xref:System.Attribute&gt;, not &lt;xref:System.Security.Permissions.SecurityAttribute&gt;).","pos":[1898,2068],"source":"       This is not a declarative security attribute, but a regular attribute (it derives from <xref:System.Attribute>, not <xref:System.Security.Permissions.SecurityAttribute>)."}]},{"pos":[3599,3715],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.SuppressUnmanagedCodeSecurityAttribute\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.SuppressUnmanagedCodeSecurityAttribute\"></xref> class."},{"pos":[3727,3798],"content":"The default constructor initializes any fields to their default values.","needQuote":true,"needEscape":true,"nodes":[{"content":"The default constructor initializes any fields to their default values.","pos":[0,71]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Security.SuppressUnmanagedCodeSecurityAttribute\n  id: SuppressUnmanagedCodeSecurityAttribute\n  children:\n  - System.Security.SuppressUnmanagedCodeSecurityAttribute.#ctor\n  langs:\n  - csharp\n  name: SuppressUnmanagedCodeSecurityAttribute\n  nameWithType: SuppressUnmanagedCodeSecurityAttribute\n  fullName: System.Security.SuppressUnmanagedCodeSecurityAttribute\n  type: Class\n  summary: Allows managed code to call into unmanaged code without a stack walk. This class cannot be inherited.\n  remarks: \"> [!CAUTION]\\n>  Use this attribute with extreme care. Incorrect use can create security weaknesses.  \\n  \\n This attribute can be applied to methods that want to call into native code without incurring the performance loss of a run-time security check when doing so. The stack walk performed when calling unmanaged code is omitted at run time, resulting in substantial performance savings. Using this attribute in a class applies it to all contained methods.  \\n  \\n Generally, whenever managed code calls into unmanaged code (by PInvoke or COM interop into native code), there is a demand for the `UnmanagedCode` permission to ensure all callers have the necessary permission to allow this. By applying this explicit attribute, developers can suppress the demand at run time. The developer must take responsibility for assuring that the transition into unmanaged code is sufficiently protected by other means. The demand for the `UnmanagedCode` permission will still occur at link time. For example, if function A calls function B and function B is marked with SuppressUnmanagedCodeSecurityAttribute, function A will be checked for unmanaged code permission during just-in-time compilation, but not subsequently during run time.  \\n  \\n This attribute is only effective when applied to PInvoke methods (or classes that contain PInvoke methods) or the definition of an interface through which interop calls will be made. It will be ignored in all other contexts.  \\n  \\n This attribute is useful for implementing a class that provides access to system resources through unmanaged code. Code that does not have permission to access unmanaged code can call a class with this attribute to access unmanaged code. This is only safe if the writer of the class with this attribute has programmed the class to be secure. If not, this attribute is dangerous and can allow the code that uses it to be misused.  \\n  \\n This is not a declarative security attribute, but a regular attribute (it derives from <xref:System.Attribute>, not <xref:System.Security.Permissions.SecurityAttribute>).\"\n  syntax:\n    content: >-\n      [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Interface | System.AttributeTargets.Delegate, AllowMultiple=true, Inherited=false)]\n\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class SuppressUnmanagedCodeSecurityAttribute : Attribute\n  inheritance:\n  - System.Attribute\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Security.SuppressUnmanagedCodeSecurityAttribute.#ctor\n  id: '#ctor'\n  parent: System.Security.SuppressUnmanagedCodeSecurityAttribute\n  langs:\n  - csharp\n  name: SuppressUnmanagedCodeSecurityAttribute()\n  nameWithType: SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute()\n  fullName: System.Security.SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security\n  summary: Initializes a new instance of the <xref href=\"System.Security.SuppressUnmanagedCodeSecurityAttribute\"></xref> class.\n  remarks: The default constructor initializes any fields to their default values.\n  syntax:\n    content: public SuppressUnmanagedCodeSecurityAttribute ();\n    parameters: []\n  overload: System.Security.SuppressUnmanagedCodeSecurityAttribute.#ctor*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Attribute\n  isExternal: false\n  name: System.Attribute\n- uid: System.Security.SuppressUnmanagedCodeSecurityAttribute.#ctor\n  parent: System.Security.SuppressUnmanagedCodeSecurityAttribute\n  isExternal: false\n  name: SuppressUnmanagedCodeSecurityAttribute()\n  nameWithType: SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute()\n  fullName: System.Security.SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute()\n- uid: System.Security.SuppressUnmanagedCodeSecurityAttribute.#ctor*\n  parent: System.Security.SuppressUnmanagedCodeSecurityAttribute\n  isExternal: false\n  name: SuppressUnmanagedCodeSecurityAttribute\n  nameWithType: SuppressUnmanagedCodeSecurityAttribute.SuppressUnmanagedCodeSecurityAttribute\n"}