{"nodes":[{"pos":[566,629],"content":"Provides credential settings for a secure conversation service.","needQuote":true,"needEscape":true,"nodes":[{"content":"Provides credential settings for a secure conversation service.","pos":[0,63]}]},{"pos":[642,2061],"content":"Secure conversations involve the exchange of multiple messages and use a Security Context Token (SCT) to ensure security. The SCT is shared among the communicating parties for the lifetime of a communications session. A service can issue two different kinds of SCTs:      -   The first is a session-based SCT that contains a unique id. Messages carry only the id, and the service maintains a state-mapping cache that maps between the SCT ids and contents (such as claims, security keys, and so on). A well-behaved client must send an SCT cancellation to help the service optimize the cache resources. If you instantiate this class by calling <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%2A> with the `requireCancellation` parameter equal to `true`, the SCT is issued in this manner.      -   The second is a self-contained SCT that resides in a cookie on the client. This SCT contains the entire state information, so requires neither state management from the service nor SCT cancellation from the client. This is sometimes called a \"cookie-mode\" SCT. Because the SCT contains the entire state information, its size is larger than in the session-based case. With session-based SCTs, the service stores much of the state information. However, because it is self-contained, it can be used across service lifetime and persists across service shutdown and restart.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Secure conversations involve the exchange of multiple messages and use a Security Context Token (SCT) to ensure security.","pos":[0,121]},{"content":"The SCT is shared among the communicating parties for the lifetime of a communications session.","pos":[122,217]},{"content":"A service can issue two different kinds of SCTs:      -   The first is a session-based SCT that contains a unique id.","pos":[218,335]},{"content":"Messages carry only the id, and the service maintains a state-mapping cache that maps between the SCT ids and contents (such as claims, security keys, and so on).","pos":[336,498]},{"content":"A well-behaved client must send an SCT cancellation to help the service optimize the cache resources.","pos":[499,600]},{"content":"If you instantiate this class by calling &lt;xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%2A&gt; with the <ph id=\"ph1\">`requireCancellation`</ph> parameter equal to <ph id=\"ph2\">`true`</ph>, the SCT is issued in this manner.","pos":[601,834],"source":" If you instantiate this class by calling <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%2A> with the `requireCancellation` parameter equal to `true`, the SCT is issued in this manner."},{"content":"-   The second is a self-contained SCT that resides in a cookie on the client.","pos":[840,918]},{"content":"This SCT contains the entire state information, so requires neither state management from the service nor SCT cancellation from the client.","pos":[919,1058]},{"content":"This is sometimes called a \"cookie-mode\" SCT.","pos":[1059,1104]},{"content":"Because the SCT contains the entire state information, its size is larger than in the session-based case.","pos":[1105,1210]},{"content":"With session-based SCTs, the service stores much of the state information.","pos":[1211,1285]},{"content":"However, because it is self-contained, it can be used across service lifetime and persists across service shutdown and restart.","pos":[1286,1413]}]},{"pos":[2786,2862],"content":"Gets a collection of the <xref:System.Type> claims for cookie serialization.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets a collection of the &lt;xref:System.Type&gt; claims for cookie serialization.","pos":[0,76],"source":"Gets a collection of the <xref:System.Type> claims for cookie serialization."}]},{"pos":[2874,3391],"content":"To serialize claims into SCT cookies, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses <xref:System.Runtime.Serialization.DataContractSerializer> as the default. Because the Claim resource is extensible, [!INCLUDE[indigo2](~/add/includes/ajax-current-ext-md.md)] allows you to provide a list of known resource types. This assists the <xref:System.Runtime.Serialization.DataContractSerializer> during deserialization of the claims in the cookie so that it can return the original strongly-typed objects.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"To serialize claims into SCT cookies, <ph id=\"ph1\">[!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)]</ph> uses &lt;xref:System.Runtime.Serialization.DataContractSerializer&gt; as the default.","pos":[0,176],"source":"To serialize claims into SCT cookies, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses <xref:System.Runtime.Serialization.DataContractSerializer> as the default."},{"content":"Because the Claim resource is extensible, <ph id=\"ph1\">[!INCLUDE[indigo2](~/add/includes/ajax-current-ext-md.md)]</ph> allows you to provide a list of known resource types.","pos":[177,331],"source":" Because the Claim resource is extensible, [!INCLUDE[indigo2](~/add/includes/ajax-current-ext-md.md)] allows you to provide a list of known resource types."},{"content":"This assists the &lt;xref:System.Runtime.Serialization.DataContractSerializer&gt; during deserialization of the claims in the cookie so that it can return the original strongly-typed objects.","pos":[332,517],"source":" This assists the <xref:System.Runtime.Serialization.DataContractSerializer> during deserialization of the claims in the cookie so that it can return the original strongly-typed objects."}]},{"pos":[3790,3861],"content":"A collection of the <xref:System.Type> claims for cookie serialization.","needQuote":true,"needEscape":true,"nodes":[{"content":"A collection of the &lt;xref:System.Type&gt; claims for cookie serialization.","pos":[0,71],"source":"A collection of the <xref:System.Type> claims for cookie serialization."}]},{"pos":[4529,4673],"content":"Gets or sets a customized <bpt id=\"p1\">&lt;xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> for encoding and decoding cookie serialization.","needQuote":true,"needEscape":true,"source":"Gets or sets a customized <xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"></xref> for encoding and decoding cookie serialization."},{"pos":[4686,5734],"content":"In \"cookie mode\", a service issues the client a security context token (SCT) in the form of a cookie to the client so that it does not have to maintain any security state. The client sends the cookie back in the request message so that the service knows how to unprotect and verify the request message. Because the SCT is often transmitted over a non-secure network, it must be protected.       By default, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses the <xref:System.ServiceModel.Security.DataProtectionSecurityStateEncoder> class to protect the cookie using the Data Protection API (DPAPI). For DPAPI to work in a Web farm environment, all the backend services must run as the same domain user account. In other words, if the service is Web hosted, then the Internet Information Services (IIS) worker process must be configured to run as a domain user.       This property enables you to use a customized <xref:System.ServiceModel.Security.SecurityStateEncoder> to encrypt and decrypt the cookie and not depend on DPAPI.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"In \"cookie mode\", a service issues the client a security context token (SCT) in the form of a cookie to the client so that it does not have to maintain any security state.","pos":[0,171]},{"content":"The client sends the cookie back in the request message so that the service knows how to unprotect and verify the request message.","pos":[172,302]},{"content":"Because the SCT is often transmitted over a non-secure network, it must be protected.","pos":[303,388]},{"content":"By default, <ph id=\"ph1\">[!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)]</ph> uses the &lt;xref:System.ServiceModel.Security.DataProtectionSecurityStateEncoder&gt; class to protect the cookie using the Data Protection API (DPAPI).","pos":[395,612],"source":"       By default, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses the <xref:System.ServiceModel.Security.DataProtectionSecurityStateEncoder> class to protect the cookie using the Data Protection API (DPAPI)."},{"content":"For DPAPI to work in a Web farm environment, all the backend services must run as the same domain user account.","pos":[613,724]},{"content":"In other words, if the service is Web hosted, then the Internet Information Services (IIS) worker process must be configured to run as a domain user.","pos":[725,874]},{"content":"This property enables you to use a customized &lt;xref:System.ServiceModel.Security.SecurityStateEncoder&gt; to encrypt and decrypt the cookie and not depend on DPAPI.","pos":[881,1042],"source":"       This property enables you to use a customized <xref:System.ServiceModel.Security.SecurityStateEncoder> to encrypt and decrypt the cookie and not depend on DPAPI."}]},{"pos":[6131,6325],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object, which is a customization of <bpt id=\"p2\">&lt;xref href=\"System.ServiceModel.Security.DataProtectionSecurityStateEncoder\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"></xref> object, which is a customization of <xref href=\"System.ServiceModel.Security.DataProtectionSecurityStateEncoder\"></xref>."}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential\n  id: SecureConversationServiceCredential\n  children:\n  - System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes\n  - System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder\n  langs:\n  - csharp\n  name: SecureConversationServiceCredential\n  nameWithType: SecureConversationServiceCredential\n  fullName: System.ServiceModel.Security.SecureConversationServiceCredential\n  type: Class\n  summary: Provides credential settings for a secure conversation service.\n  remarks: \"Secure conversations involve the exchange of multiple messages and use a Security Context Token (SCT) to ensure security. The SCT is shared among the communicating parties for the lifetime of a communications session. A service can issue two different kinds of SCTs:  \\n  \\n-   The first is a session-based SCT that contains a unique id. Messages carry only the id, and the service maintains a state-mapping cache that maps between the SCT ids and contents (such as claims, security keys, and so on). A well-behaved client must send an SCT cancellation to help the service optimize the cache resources. If you instantiate this class by calling <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%2A> with the `requireCancellation` parameter equal to `true`, the SCT is issued in this manner.  \\n  \\n-   The second is a self-contained SCT that resides in a cookie on the client. This SCT contains the entire state information, so requires neither state management from the service nor SCT cancellation from the client. This is sometimes called a \\\"cookie-mode\\\" SCT. Because the SCT contains the entire state information, its size is larger than in the session-based case. With session-based SCTs, the service stores much of the state information. However, because it is self-contained, it can be used across service lifetime and persists across service shutdown and restart.\"\n  syntax:\n    content: public sealed class SecureConversationServiceCredential\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes\n  id: SecurityContextClaimTypes\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  langs:\n  - csharp\n  name: SecurityContextClaimTypes\n  nameWithType: SecureConversationServiceCredential.SecurityContextClaimTypes\n  fullName: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes\n  type: Property\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Security\n  summary: Gets a collection of the <xref:System.Type> claims for cookie serialization.\n  remarks: To serialize claims into SCT cookies, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses <xref:System.Runtime.Serialization.DataContractSerializer> as the default. Because the Claim resource is extensible, [!INCLUDE[indigo2](~/add/includes/ajax-current-ext-md.md)] allows you to provide a list of known resource types. This assists the <xref:System.Runtime.Serialization.DataContractSerializer> during deserialization of the claims in the cookie so that it can return the original strongly-typed objects.\n  example:\n  - \"The following code shows how to get this property.  \\n  \\n [!code-cs[S_UE_SecureConversationServiceCredential#2](~/add/codesnippet/csharp/e8a69534-ad60-48be-9b2e-_1.cs)]\"\n  syntax:\n    content: public System.Collections.ObjectModel.Collection<Type> SecurityContextClaimTypes { get; }\n    return:\n      type: System.Collections.ObjectModel.Collection{System.Type}\n      description: A collection of the <xref:System.Type> claims for cookie serialization.\n  overload: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder\n  id: SecurityStateEncoder\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  langs:\n  - csharp\n  name: SecurityStateEncoder\n  nameWithType: SecureConversationServiceCredential.SecurityStateEncoder\n  fullName: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder\n  type: Property\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Security\n  summary: Gets or sets a customized <xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"></xref> for encoding and decoding cookie serialization.\n  remarks: \"In \\\"cookie mode\\\", a service issues the client a security context token (SCT) in the form of a cookie to the client so that it does not have to maintain any security state. The client sends the cookie back in the request message so that the service knows how to unprotect and verify the request message. Because the SCT is often transmitted over a non-secure network, it must be protected.  \\n  \\n By default, [!INCLUDE[indigo1](~/add/includes/ajax-current-ext-md.md)] uses the <xref:System.ServiceModel.Security.DataProtectionSecurityStateEncoder> class to protect the cookie using the Data Protection API (DPAPI). For DPAPI to work in a Web farm environment, all the backend services must run as the same domain user account. In other words, if the service is Web hosted, then the Internet Information Services (IIS) worker process must be configured to run as a domain user.  \\n  \\n This property enables you to use a customized <xref:System.ServiceModel.Security.SecurityStateEncoder> to encrypt and decrypt the cookie and not depend on DPAPI.\"\n  example:\n  - \"The following code shows how to set this property.  \\n  \\n [!code-cs[S_UE_SecureConversationServiceCredential#1](~/add/codesnippet/csharp/72c1f567-836b-4b6f-bbcd-_1.cs)]\"\n  syntax:\n    content: public System.ServiceModel.Security.SecurityStateEncoder SecurityStateEncoder { get; set; }\n    return:\n      type: System.ServiceModel.Security.SecurityStateEncoder\n      description: A <xref href=\"System.ServiceModel.Security.SecurityStateEncoder\"></xref> object, which is a customization of <xref href=\"System.ServiceModel.Security.DataProtectionSecurityStateEncoder\"></xref>.\n  overload: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  isExternal: false\n  name: SecurityContextClaimTypes\n  nameWithType: SecureConversationServiceCredential.SecurityContextClaimTypes\n  fullName: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes\n- uid: System.Collections.ObjectModel.Collection{System.Type}\n  parent: System.Collections.ObjectModel\n  isExternal: true\n  name: Collection<Type>\n  nameWithType: Collection<Type>\n  fullName: System.Collections.ObjectModel.Collection<System.Type>\n  spec.csharp:\n  - uid: System.Collections.ObjectModel.Collection`1\n    name: Collection\n    nameWithType: Collection\n    fullName: Collection<System.Type>\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Type\n    name: Type\n    nameWithType: Type\n    fullName: Type\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  isExternal: false\n  name: SecurityStateEncoder\n  nameWithType: SecureConversationServiceCredential.SecurityStateEncoder\n  fullName: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder\n- uid: System.ServiceModel.Security.SecurityStateEncoder\n  parent: System.ServiceModel.Security\n  isExternal: false\n  name: SecurityStateEncoder\n  nameWithType: SecurityStateEncoder\n  fullName: System.ServiceModel.Security.SecurityStateEncoder\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes*\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  isExternal: false\n  name: SecurityContextClaimTypes\n  nameWithType: SecureConversationServiceCredential.SecurityContextClaimTypes\n- uid: System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder*\n  parent: System.ServiceModel.Security.SecureConversationServiceCredential\n  isExternal: false\n  name: SecurityStateEncoder\n  nameWithType: SecureConversationServiceCredential.SecurityStateEncoder\n"}