{"nodes":[{"pos":[1115,1232],"content":"Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.","pos":[0,117]}]},{"pos":[1245,10100],"content":"The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the XamlReader class to use.       The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph. Object graphs that are created by XamlReader are typically added to the existing object tree of a WPF application at run time. Otherwise the new object graph is considered disconnected for purposes of the WPF application model. This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). For more information on object tree concepts, see [Trees in WPF](~/add/includes/ajax-current-ext-md.md).       XamlReader supports the following primary scenarios:      -   **Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree. (Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName>. You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.      -   **Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects. For example you could use the same value to set more than one property, or use data binding. But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.      -   **Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations. You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.      -   **Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.      > [!NOTE] >  This documentation sometimes describes an object graph, as opposed to an object tree. A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology. However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF. From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.      ## Code Access Security, Loose XAML, and XamlReader    XAML is a markup language that directly represents object instantiation and execution. Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.       [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] supports the [!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]. This means that [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions. \"Loose XAML\" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.  However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does. For more information, see [WPF Partial Trust Security](~/add/includes/ajax-current-ext-md.md).       The implications of these statements for XamlReader is that your application design must make trust decisions about the XAML you decide to load. If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.       XamlReader can also be called by partial trust code. In this case, Internet security zone is applied for code access security. If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown. Under XBAP and other cases that are partial trust at the platform level, where XamlReader is part of the execution, you get the same exception behavior as with explicit partial trust calls.      ## WPF XAML, XAML Readers/Writers, and XAML Language Versioning    [!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)] includes language features such as  and . You can use signatures of `Load` or `Parse` to load XAML that uses these features. However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).       WPF types and the WPF technology in general support concepts that rely on access to WPF internals. For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup. Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and XamlReader from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly. However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=fullName>, <xref:System.Xaml.XamlWriter?displayProperty=fullName>) do not have access to the WPF internals. There is no dependency from System.Xaml to any WPF-specific assembly. Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types. In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates. Therefore you have a choice to make:      -   If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.      -   If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.      ## System.Xaml Backing Implementation in .NET 4    XamlReader is the callable API surface for the WPF framework-level XAML parser. The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)].       If you are targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML. Targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.      <a name=\"xamlTextUsage_XamlReader\"></a>    ## XAML Text Usage","needQuote":false,"needEscape":true,"nodes":[{"content":"The synchronous &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; methods are static, but the asynchronous &lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt; methods are not static and require an instance of the XamlReader class to use.","pos":[0,236],"source":"The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the XamlReader class to use."},{"content":"The output of the <ph id=\"ph1\">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.","pos":[243,370],"source":"       The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph."},{"content":"Object graphs that are created by XamlReader are typically added to the existing object tree of a WPF application at run time.","pos":[371,497]},{"content":"Otherwise the new object graph is considered disconnected for purposes of the WPF application model.","pos":[498,598]},{"content":"This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs &lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;, &lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;).","pos":[599,913],"source":" This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>)."},{"content":"For more information on object tree concepts, see <bpt id=\"p1\">[</bpt>Trees in WPF<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>.","pos":[914,1018],"source":" For more information on object tree concepts, see [Trees in WPF](~/add/includes/ajax-current-ext-md.md)."},{"content":"XamlReader supports the following primary scenarios:      -   <bpt id=\"p1\">**</bpt>Cloning/object factory<ept id=\"p1\">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.","pos":[1025,1239],"source":"       XamlReader supports the following primary scenarios:      -   **Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree."},{"content":"(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on &lt;xref:System.Windows.Freezable&gt;, or support for commonly shareable objects such as &lt;xref:System.Windows.Media.Brush&gt; that are referenced as an item from a &lt;xref:System.Windows.ResourceDictionary&gt;.) One way to clone an object that is already in the object tree is to serialize the object using &lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName&gt;.","pos":[1240,1723],"source":" (Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName>."},{"content":"You then use the serialized string as input for a call to &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;, with a stream or &lt;xref:System.Xml.XmlReader&gt; as an intermediary.","pos":[1724,1895],"source":" You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary."},{"content":"-   <bpt id=\"p1\">**</bpt>Constructing objects based on just-in-time information<ept id=\"p1\">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.","pos":[1901,2073],"source":"      -   **Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects."},{"content":"For example you could use the same value to set more than one property, or use data binding.","pos":[2074,2166]},{"content":"But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; input is often a useful technique.","pos":[2167,2432],"source":" But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique."},{"content":"-   <bpt id=\"p1\">**</bpt>Using existing resource techniques<ept id=\"p1\">**</ept>: The &lt;xref:System.IO.Stream&gt; type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.","pos":[2438,2659],"source":"      -   **Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations."},{"content":"You can then use the &lt;xref:System.IO.Stream&gt; techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.","pos":[2660,2827],"source":" You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application."},{"content":"-   <bpt id=\"p1\">**</bpt>Fixed documents:<ept id=\"p1\">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.","pos":[2833,2974],"source":"      -   **Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  This documentation sometimes describes an object graph, as opposed to an object tree.","pos":[2980,3078],"source":"      > [!NOTE] >  This documentation sometimes describes an object graph, as opposed to an object tree."},{"content":"A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.","pos":[3079,3263]},{"content":"However, because WPF also includes two different tree conceptualization APIs (&lt;xref:System.Windows.LogicalTreeHelper&gt;, &lt;xref:System.Windows.Media.VisualTreeHelper&gt;) the tree metaphor still applies adequately to most real-world cases in WPF.","pos":[3264,3504],"source":" However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF."},{"content":"From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.","pos":[3505,3791]},{"content":"Code Access Security, Loose XAML, and XamlReader    XAML is a markup language that directly represents object instantiation and execution.","pos":[3800,3938]},{"content":"Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.","pos":[3939,4115]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id=\"ph3\">[!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]</ph>.","pos":[4122,4356],"source":"[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] supports the [!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]."},{"content":"This means that <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.","pos":[4357,4520],"source":" This means that [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions."},{"content":"\"Loose XAML\" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id=\"ph1\">[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.","pos":[4521,4742],"source":" \"Loose XAML\" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set."},{"content":"However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.","pos":[4744,4875]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>WPF Partial Trust Security<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>.","pos":[4876,4970],"source":" For more information, see [WPF Partial Trust Security](~/add/includes/ajax-current-ext-md.md)."},{"content":"The implications of these statements for XamlReader is that your application design must make trust decisions about the XAML you decide to load.","pos":[4977,5121]},{"content":"If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.","pos":[5122,5263]},{"content":"XamlReader can also be called by partial trust code.","pos":[5270,5322]},{"content":"In this case, Internet security zone is applied for code access security.","pos":[5323,5396]},{"content":"If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.","pos":[5397,5502]},{"content":"Under XBAP and other cases that are partial trust at the platform level, where XamlReader is part of the execution, you get the same exception behavior as with explicit partial trust calls.","pos":[5503,5692]},{"content":"WPF XAML, XAML Readers/Writers, and XAML Language Versioning    <ph id=\"ph1\">[!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)]</ph> includes language features such as  and .","pos":[5701,5858],"source":"      ## WPF XAML, XAML Readers/Writers, and XAML Language Versioning    [!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)] includes language features such as  and ."},{"content":"You can use signatures of <ph id=\"ph1\">`Load`</ph> or <ph id=\"ph2\">`Parse`</ph> to load XAML that uses these features.","pos":[5859,5941],"source":" You can use signatures of `Load` or `Parse` to load XAML that uses these features."},{"content":"However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id=\"p1\">**</bpt>Page<ept id=\"p1\">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).","pos":[5942,6173],"source":" However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions)."},{"content":"WPF types and the WPF technology in general support concepts that rely on access to WPF internals.","pos":[6180,6278]},{"content":"For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.","pos":[6279,6397]},{"content":"Access to these internals is enabled by the XAML reading and writing APIs provided in &lt;xref:System.Windows.Markup.XamlWriter&gt; and XamlReader from the &lt;xref:System.Windows.Markup&gt; namespace and PresentationFramework assembly.","pos":[6398,6622],"source":" Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and XamlReader from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly."},{"content":"However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on &lt;xref:System.Xaml.XamlReader?displayProperty=fullName&gt;, &lt;xref:System.Xaml.XamlWriter?displayProperty=fullName&gt;) do not have access to the WPF internals.","pos":[6623,6878],"source":" However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=fullName>, <xref:System.Xaml.XamlWriter?displayProperty=fullName>) do not have access to the WPF internals."},{"content":"There is no dependency from System.Xaml to any WPF-specific assembly.","pos":[6879,6948]},{"content":"Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.","pos":[6949,7091]},{"content":"In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.","pos":[7092,7311]},{"content":"Therefore you have a choice to make:      -   If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.","pos":[7312,7499]},{"content":"-   If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.","pos":[7505,7764]},{"content":"System.Xaml Backing Implementation in .NET 4    XamlReader is the callable API surface for the WPF framework-level XAML parser.","pos":[7773,7900]},{"content":"The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id=\"ph1\">[!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]</ph>.","pos":[7901,8146],"source":" The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)]."},{"content":"If you are targeting <ph id=\"ph1\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id=\"ph2\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.","pos":[8153,8510],"source":"       If you are targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML."},{"content":"Targeting <ph id=\"ph1\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.","pos":[8511,8743],"source":" Targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types."},{"content":"<bpt id=\"p1\">&lt;a name=\"xamlTextUsage_XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept>    ## XAML Text Usage","pos":[8749,8810],"source":"<a name=\"xamlTextUsage_XamlReader\"></a>    ## XAML Text Usage"}]},{"pos":[11245,11339],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Windows.Markup.XamlReader\"></xref> class."},{"pos":[11852,11951],"content":"Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.","needQuote":true,"needEscape":true,"nodes":[{"content":"Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.","pos":[0,99]}]},{"pos":[11963,12071],"content":"CancelAsync is an asynchronous operation; therefore, some loading may occur before the operation is aborted.","needQuote":true,"needEscape":true,"nodes":[{"content":"CancelAsync is an asynchronous operation; therefore, some loading may occur before the operation is aborted.","pos":[0,108]}]},{"pos":[12636,12812],"content":"Returns a <bpt id=\"p1\">&lt;xref href=\"System.Xaml.XamlSchemaContext\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id=\"p2\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Returns a <xref href=\"System.Xaml.XamlSchemaContext\"></xref> object that represents the WPF schema context settings for a <xref href=\"System.Windows.Markup.XamlReader\"></xref>."},{"pos":[12996,13164],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Xaml.XamlSchemaContext\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that represents the WPF schema context settings for a <bpt id=\"p2\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Xaml.XamlSchemaContext\"></xref> object that represents the WPF schema context settings for a <xref href=\"System.Windows.Markup.XamlReader\"></xref>."},{"pos":[13646,13794],"content":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns an <xref:System.Object> that is the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an &lt;xref:System.Object&gt; that is the root of the corresponding object tree.","pos":[0,148],"source":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns an <xref:System.Object> that is the root of the corresponding object tree."}]},{"pos":[14666,14699],"content":"The XAML to load, in stream form.","needQuote":true,"needEscape":true,"nodes":[{"content":"The XAML to load, in stream form.","pos":[0,33]}]},{"pos":[14757,14807],"content":"The object at the root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object at the root of the created object tree.","pos":[0,50]}]},{"pos":[14975,15059],"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[15482,15638],"content":"Reads the XAML input through a provided <bpt id=\"p1\">&lt;xref href=\"System.Xaml.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and returns an object that is the root of the corresponding object tree.","needQuote":true,"needEscape":true,"source":"Reads the XAML input through a provided <xref href=\"System.Xaml.XamlReader\"></xref> and returns an object that is the root of the corresponding object tree."},{"pos":[15650,15821],"content":"The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>. This is how you can load BAML at run time, or for localization tool purposes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>. This is how you can load BAML at run time, or for localization tool purposes.","pos":[0,171],"nodes":[{"content":"The input &lt;xref:System.Xaml.XamlReader&gt; can be &lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;.","pos":[0,93],"source":"The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>."},{"content":"This is how you can load BAML at run time, or for localization tool purposes.","pos":[94,171]}]}]},{"pos":[15991,16096],"content":"A <xref href=\"System.Xaml.XamlReader\"></xref> object. This is expected to be initialized with input XAML.","needQuote":true,"needEscape":true,"nodes":[{"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Xaml.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object.","pos":[0,53],"source":"A <xref href=\"System.Xaml.XamlReader\"></xref> object."},{"content":"This is expected to be initialized with input XAML.","pos":[54,105]}]},{"pos":[16154,16209],"content":"The object that is the root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is the root of the created object tree.","pos":[0,55]}]},{"pos":[16377,16461],"content":"<ph id=\"ph1\">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[16877,17015],"content":"Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns an object that is the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns an object that is the root of the corresponding object tree.","pos":[0,138],"source":"Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns an object that is the root of the corresponding object tree."}]},{"pos":[17876,17967],"content":"The <xref:System.Xml.XmlReader> that has already loaded the XAML input to load in XML form.","needQuote":true,"needEscape":true,"nodes":[{"content":"The &lt;xref:System.Xml.XmlReader&gt; that has already loaded the XAML input to load in XML form.","pos":[0,91],"source":"The <xref:System.Xml.XmlReader> that has already loaded the XAML input to load in XML form."}]},{"pos":[18025,18080],"content":"The object that is the root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is the root of the created object tree.","pos":[0,55]}]},{"pos":[18248,18332],"content":"<ph id=\"ph1\">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[18845,18979],"content":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns an object that is the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns an object that is the root of the corresponding object tree.","pos":[0,134],"source":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns an object that is the root of the corresponding object tree."}]},{"pos":[19188,19236],"content":"The stream that contains the XAML input to load.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream that contains the XAML input to load.","pos":[0,48]}]},{"pos":[19328,19367],"content":"Context information used by the parser.","needQuote":true,"needEscape":true,"nodes":[{"content":"Context information used by the parser.","pos":[0,39]}]},{"pos":[19425,19480],"content":"The object that is the root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is the root of the created object tree.","pos":[0,55]}]},{"pos":[19649,19858],"content":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.       -or-       <code>parserContext</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[0,84],"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"content":"-or-       <ph id=\"ph1\">&lt;code&gt;parserContext&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","pos":[91,193],"source":"       -or-       <code>parserContext</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."}]},{"pos":[20283,20399],"content":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.","pos":[0,116],"source":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree."}]},{"pos":[20412,22281],"content":"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.       You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.       In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode=\"Async\"`. The value is treated as case sensitive. If the XAML input root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.","needQuote":false,"needEscape":true,"nodes":[{"content":"An asynchronous XAML load operation will initially return an object that is purely the root object.","pos":[0,99]},{"content":"Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.","pos":[100,196]},{"content":"This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.","pos":[197,318]},{"content":"In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.","pos":[319,485]},{"content":"That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.","pos":[486,618]},{"content":"You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.","pos":[625,880]},{"content":"For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.","pos":[881,1120],"source":" For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled."},{"content":"In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>.","pos":[1127,1285],"source":"       In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode=\"Async\"`."},{"content":"The value is treated as case sensitive.","pos":[1286,1325]},{"content":"If the XAML input root does not contain <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;).","pos":[1326,1540],"source":" If the XAML input root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>)."},{"content":"Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.","pos":[1547,1677],"source":"       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time."},{"content":"If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.","pos":[1679,1859],"source":"  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown."}]},{"pos":[22438,22483],"content":"The stream containing the XAML input to load.","needQuote":true,"needEscape":true,"nodes":[{"content":"The stream containing the XAML input to load.","pos":[0,45]}]},{"pos":[22541,22596],"content":"The object that is the root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is the root of the created object tree.","pos":[0,55]}]},{"pos":[22769,22853],"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[22964,23082],"content":"Multiple load operations are pending concurrently with the same <bpt id=\"p1\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Multiple load operations are pending concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>."},{"pos":[23523,23643],"content":"Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.Xml.XmlReader&gt; and returns the root of the corresponding object tree.","pos":[0,120],"source":"Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns the root of the corresponding object tree."}]},{"pos":[23656,25550],"content":"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.       You typically would assign the returned object from LoadAsync to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.       In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\"Async\"`. The value is treated as case sensitive. If the XAML markup root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.","needQuote":false,"needEscape":true,"nodes":[{"content":"An asynchronous XAML load operation will initially return an object that is purely the root object.","pos":[0,99]},{"content":"Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.","pos":[100,196]},{"content":"This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.","pos":[197,318]},{"content":"In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.","pos":[319,485]},{"content":"That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.","pos":[486,618]},{"content":"You typically would assign the returned object from LoadAsync to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.","pos":[625,891]},{"content":"For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.","pos":[892,1131],"source":" For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled."},{"content":"In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>.","pos":[1138,1297],"source":"       In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\"Async\"`."},{"content":"The value is treated as case sensitive.","pos":[1298,1337]},{"content":"If the XAML markup root does not contain <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;).","pos":[1338,1565],"source":" If the XAML markup root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>)."},{"content":"Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.","pos":[1572,1702],"source":"       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time."},{"content":"If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.","pos":[1704,1884],"source":"  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown."}]},{"pos":[25715,25800],"content":"An existing  <xref:System.Xml.XmlReader> that has already loaded/read the XAML input.","needQuote":true,"needEscape":true,"nodes":[{"content":"An existing  &lt;xref:System.Xml.XmlReader&gt; that has already loaded/read the XAML input.","pos":[0,85],"source":"An existing  <xref:System.Xml.XmlReader> that has already loaded/read the XAML input."}]},{"pos":[25858,25894],"content":"The root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The root of the created object tree.","pos":[0,36]}]},{"pos":[26067,26151],"content":"<ph id=\"ph1\">&lt;code&gt;reader&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[26262,26382],"content":"Multiple load operations are performed concurrently with the same <bpt id=\"p1\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Multiple load operations are performed concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>."},{"pos":[26920,27036],"content":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified &lt;xref:System.IO.Stream&gt; and returns the root of the corresponding object tree.","pos":[0,116],"source":"Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree."}]},{"pos":[27049,28950],"content":"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.       You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.       In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\"Async\"`. The value is treated as case sensitive. If the XAML markup root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.","needQuote":false,"needEscape":true,"nodes":[{"content":"An asynchronous XAML load operation will initially return an object that is purely the root object.","pos":[0,99]},{"content":"Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.","pos":[100,196]},{"content":"This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.","pos":[197,318]},{"content":"In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.","pos":[319,485]},{"content":"That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.","pos":[486,618]},{"content":"You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.","pos":[625,876]},{"content":"For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when &lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt; is handled.","pos":[877,1116],"source":" For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled."},{"content":"In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>.","pos":[1123,1278],"source":"       In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\"Async\"`."},{"content":"The value is treated as case sensitive.","pos":[1279,1318]},{"content":"If the XAML markup root does not contain <ph id=\"ph1\">`x:SynchronousMode=\"Async\"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see &lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;).","pos":[1319,1572],"source":" If the XAML markup root does not contain `x:SynchronousMode=\"Async\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>)."},{"content":"Only one asynchronous load operation per instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class can be performed at a time.","pos":[1579,1709],"source":"       Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time."},{"content":"If more than one asynchronous operation is attempted on the same instance of the &lt;xref:System.Windows.Markup.XamlReader&gt; class an &lt;xref:System.InvalidOperationException&gt; is thrown.","pos":[1711,1891],"source":"  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown."}]},{"pos":[29158,29201],"content":"A stream containing the XAML input to load.","needQuote":true,"needEscape":true,"nodes":[{"content":"A stream containing the XAML input to load.","pos":[0,43]}]},{"pos":[29293,29332],"content":"Context information used by the parser.","needQuote":true,"needEscape":true,"nodes":[{"content":"Context information used by the parser.","pos":[0,39]}]},{"pos":[29390,29426],"content":"The root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The root of the created object tree.","pos":[0,36]}]},{"pos":[29599,29683],"content":"<ph id=\"ph1\">&lt;code&gt;stream&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[29794,29914],"content":"Multiple load operations are performed concurrently with the same <bpt id=\"p1\">&lt;xref href=\"System.Windows.Markup.XamlReader\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Multiple load operations are performed concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>."},{"pos":[30297,30350],"content":"Occurs when an asynchronous load operation completes.","needQuote":true,"needEscape":true,"nodes":[{"content":"Occurs when an asynchronous load operation completes.","pos":[0,53]}]},{"pos":[30362,30434],"content":"LoadCompleted is also raised when an asynchronous load operation aborts.","needQuote":true,"needEscape":true,"nodes":[{"content":"LoadCompleted is also raised when an asynchronous load operation aborts.","pos":[0,72]}]},{"pos":[30627,30639],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[31054,31179],"content":"Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.","needQuote":true,"needEscape":true,"nodes":[{"content":"Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.","pos":[0,125]}]},{"pos":[31191,31423],"content":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.","needQuote":true,"needEscape":true,"nodes":[{"content":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.","pos":[0,232],"nodes":[{"content":"The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.","pos":[0,124],"source":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string."},{"content":"See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.","pos":[125,232],"source":" See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions."}]}]},{"pos":[31573,31613],"content":"The input XAML, as a single text string.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input XAML, as a single text string.","pos":[0,40]}]},{"pos":[31671,31707],"content":"The root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The root of the created object tree.","pos":[0,36]}]},{"pos":[32288,32491],"content":"Reads the XAML markup in the specified text string (using a specified <bpt id=\"p1\">&lt;xref href=\"System.Windows.Markup.ParserContext\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>) and returns an object that corresponds to the root of the specified markup.","needQuote":true,"needEscape":true,"source":"Reads the XAML markup in the specified text string (using a specified <xref href=\"System.Windows.Markup.ParserContext\"></xref>) and returns an object that corresponds to the root of the specified markup."},{"pos":[32503,32735],"content":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.","needQuote":true,"needEscape":true,"nodes":[{"content":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.","pos":[0,232],"nodes":[{"content":"The implementation calls &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; internally after creating a stream from the string.","pos":[0,124],"source":"The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string."},{"content":"See &lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt; for additional information such as possible exceptions.","pos":[125,232],"source":" See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions."}]}]},{"pos":[32936,32976],"content":"The input XAML, as a single text string.","needQuote":true,"needEscape":true,"nodes":[{"content":"The input XAML, as a single text string.","pos":[0,40]}]},{"pos":[33068,33107],"content":"Context information used by the parser.","needQuote":true,"needEscape":true,"nodes":[{"content":"Context information used by the parser.","pos":[0,39]}]},{"pos":[33165,33201],"content":"The root of the created object tree.","needQuote":true,"needEscape":true,"nodes":[{"content":"The root of the created object tree.","pos":[0,36]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Windows.Markup.XamlReader\n  id: XamlReader\n  children:\n  - System.Windows.Markup.XamlReader.#ctor\n  - System.Windows.Markup.XamlReader.CancelAsync\n  - System.Windows.Markup.XamlReader.GetWpfSchemaContext\n  - System.Windows.Markup.XamlReader.Load(System.IO.Stream)\n  - System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)\n  - System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)\n  - System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)\n  - System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)\n  - System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)\n  - System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)\n  - System.Windows.Markup.XamlReader.LoadCompleted\n  - System.Windows.Markup.XamlReader.Parse(System.String)\n  - System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)\n  langs:\n  - csharp\n  name: XamlReader\n  nameWithType: XamlReader\n  fullName: System.Windows.Markup.XamlReader\n  type: Class\n  summary: Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.\n  remarks: \"The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the XamlReader class to use.  \\n  \\n The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph. Object graphs that are created by XamlReader are typically added to the existing object tree of a WPF application at run time. Otherwise the new object graph is considered disconnected for purposes of the WPF application model. This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). For more information on object tree concepts, see [Trees in WPF](~/add/includes/ajax-current-ext-md.md).  \\n  \\n XamlReader supports the following primary scenarios:  \\n  \\n-   **Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree. (Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=fullName>. You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.  \\n  \\n-   **Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects. For example you could use the same value to set more than one property, or use data binding. But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.  \\n  \\n-   **Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations. You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.  \\n  \\n-   **Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.  \\n  \\n> [!NOTE]\\n>  This documentation sometimes describes an object graph, as opposed to an object tree. A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology. However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF. From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.  \\n  \\n## Code Access Security, Loose XAML, and XamlReader  \\n XAML is a markup language that directly represents object instantiation and execution. Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.  \\n  \\n [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] supports the [!INCLUDE[TLA2#tla_net](~/add/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/add/includes/tlasharptla-cas-md.md)]. This means that [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions. \\\"Loose XAML\\\" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.  However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does. For more information, see [WPF Partial Trust Security](~/add/includes/ajax-current-ext-md.md).  \\n  \\n The implications of these statements for XamlReader is that your application design must make trust decisions about the XAML you decide to load. If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.  \\n  \\n XamlReader can also be called by partial trust code. In this case, Internet security zone is applied for code access security. If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown. Under XBAP and other cases that are partial trust at the platform level, where XamlReader is part of the execution, you get the same exception behavior as with explicit partial trust calls.  \\n  \\n## WPF XAML, XAML Readers/Writers, and XAML Language Versioning  \\n [!INCLUDE[xaml2009](~/add/includes/xaml2009-md.md)] includes language features such as  and . You can use signatures of `Load` or `Parse` to load XAML that uses these features. However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).  \\n  \\n WPF types and the WPF technology in general support concepts that rely on access to WPF internals. For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup. Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and XamlReader from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly. However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=fullName>, <xref:System.Xaml.XamlWriter?displayProperty=fullName>) do not have access to the WPF internals. There is no dependency from System.Xaml to any WPF-specific assembly. Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types. In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates. Therefore you have a choice to make:  \\n  \\n-   If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.  \\n  \\n-   If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.  \\n  \\n## System.Xaml Backing Implementation in .NET 4  \\n XamlReader is the callable API surface for the WPF framework-level XAML parser. The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/add/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)].  \\n  \\n If you are targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML. Targeting [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.  \\n  \\n<a name=\\\"xamlTextUsage_XamlReader\\\"></a>   \\n## XAML Text Usage\"\n  example:\n  - \"The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.  The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the XamlReader class.  \\n  \\n [!code-cs[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/add/codesnippet/csharp/XamlReaderWriterSnippets/Window1.xaml.cs#xamlreaderloadxmlreader)]\\n [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/add/codesnippet/visualbasic/xamlreaderwritersnippets/window1.xaml.vb#xamlreaderloadxmlreader)]\"\n  syntax:\n    content: public class XamlReader\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.#ctor\n  id: '#ctor'\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: XamlReader()\n  nameWithType: XamlReader.XamlReader()\n  fullName: System.Windows.Markup.XamlReader.XamlReader()\n  type: Constructor\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Markup.XamlReader\"></xref> class.\n  syntax:\n    content: public XamlReader ();\n    parameters: []\n  overload: System.Windows.Markup.XamlReader.#ctor*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.CancelAsync\n  id: CancelAsync\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: CancelAsync()\n  nameWithType: XamlReader.CancelAsync()\n  fullName: System.Windows.Markup.XamlReader.CancelAsync()\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.\n  remarks: CancelAsync is an asynchronous operation; therefore, some loading may occur before the operation is aborted.\n  syntax:\n    content: public void CancelAsync ();\n    parameters: []\n  overload: System.Windows.Markup.XamlReader.CancelAsync*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.GetWpfSchemaContext\n  id: GetWpfSchemaContext\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: GetWpfSchemaContext()\n  nameWithType: XamlReader.GetWpfSchemaContext()\n  fullName: System.Windows.Markup.XamlReader.GetWpfSchemaContext()\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Returns a <xref href=\"System.Xaml.XamlSchemaContext\"></xref> object that represents the WPF schema context settings for a <xref href=\"System.Windows.Markup.XamlReader\"></xref>.\n  syntax:\n    content: public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();\n    parameters: []\n    return:\n      type: System.Xaml.XamlSchemaContext\n      description: A <xref href=\"System.Xaml.XamlSchemaContext\"></xref> object that represents the WPF schema context settings for a <xref href=\"System.Windows.Markup.XamlReader\"></xref>.\n  overload: System.Windows.Markup.XamlReader.GetWpfSchemaContext*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Load(System.IO.Stream)\n  id: Load(System.IO.Stream)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Load(Stream)\n  nameWithType: XamlReader.Load(Stream)\n  fullName: System.Windows.Markup.XamlReader.Load(Stream)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.IO.Stream> and returns an <xref:System.Object> that is the root of the corresponding object tree.\n  remarks: ''\n  example:\n  - \"The following example saves a <xref:System.Windows.Controls.Button> into a <xref:System.IO.MemoryStream> using the <xref:System.Windows.Markup.XamlWriter> class. The stream is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.  \\n  \\n [!code-cs[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/add/codesnippet/csharp/XamlReaderWriterSnippets/Window1.xaml.cs#xamlreaderloadxmlreader)]\\n [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/add/codesnippet/visualbasic/xamlreaderwritersnippets/window1.xaml.vb#xamlreaderloadxmlreader)]\"\n  syntax:\n    content: public static object Load (System.IO.Stream stream);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: The XAML to load, in stream form.\n    return:\n      type: System.Object\n      description: The object at the root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Load*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)\n  id: Load(System.Xaml.XamlReader)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Load(XamlReader)\n  nameWithType: XamlReader.Load(XamlReader)\n  fullName: System.Windows.Markup.XamlReader.Load(XamlReader)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input through a provided <xref href=\"System.Xaml.XamlReader\"></xref> and returns an object that is the root of the corresponding object tree.\n  remarks: The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>. This is how you can load BAML at run time, or for localization tool purposes.\n  syntax:\n    content: public static object Load (System.Xaml.XamlReader reader);\n    parameters:\n    - id: reader\n      type: System.Xaml.XamlReader\n      description: A <xref href=\"System.Xaml.XamlReader\"></xref> object. This is expected to be initialized with input XAML.\n    return:\n      type: System.Object\n      description: The object that is the root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Load*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)\n  id: Load(System.Xml.XmlReader)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Load(XmlReader)\n  nameWithType: XamlReader.Load(XmlReader)\n  fullName: System.Windows.Markup.XamlReader.Load(XmlReader)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns an object that is the root of the corresponding object tree.\n  remarks: ''\n  example:\n  - \"The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.  The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.  \\n  \\n [!code-cs[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/add/codesnippet/csharp/XamlReaderWriterSnippets/Window1.xaml.cs#xamlreaderloadxmlreader)]\\n [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/add/codesnippet/visualbasic/xamlreaderwritersnippets/window1.xaml.vb#xamlreaderloadxmlreader)]\"\n  syntax:\n    content: public static object Load (System.Xml.XmlReader reader);\n    parameters:\n    - id: reader\n      type: System.Xml.XmlReader\n      description: The <xref:System.Xml.XmlReader> that has already loaded the XAML input to load in XML form.\n    return:\n      type: System.Object\n      description: The object that is the root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Load*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)\n  id: Load(System.IO.Stream,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Load(Stream,ParserContext)\n  nameWithType: XamlReader.Load(Stream,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.Load(Stream,ParserContext)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.IO.Stream> and returns an object that is the root of the corresponding object tree.\n  syntax:\n    content: public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: The stream that contains the XAML input to load.\n    - id: parserContext\n      type: System.Windows.Markup.ParserContext\n      description: Context information used by the parser.\n    return:\n      type: System.Object\n      description: The object that is the root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Load*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>stream</code> is <xref uid=\\\"langword_csharp_null\\\" name=\\\"null\\\" href=\\\"\\\"></xref>.  \\n  \\n -or-  \\n  \\n <code>parserContext</code> is <xref uid=\\\"langword_csharp_null\\\" name=\\\"null\\\" href=\\\"\\\"></xref>.\"\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)\n  id: LoadAsync(System.IO.Stream)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: LoadAsync(Stream)\n  nameWithType: XamlReader.LoadAsync(Stream)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(Stream)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree.\n  remarks: \"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.  \\n  \\n You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.  \\n  \\n In order for LoadAsync to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode=\\\"Async\\\"`. The value is treated as case sensitive. If the XAML input root does not contain `x:SynchronousMode=\\\"Async\\\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  \\n  \\n Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.\"\n  syntax:\n    content: public object LoadAsync (System.IO.Stream stream);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: The stream containing the XAML input to load.\n    return:\n      type: System.Object\n      description: The object that is the root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.LoadAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: Multiple load operations are pending concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)\n  id: LoadAsync(System.Xml.XmlReader)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: LoadAsync(XmlReader)\n  nameWithType: XamlReader.LoadAsync(XmlReader)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(XmlReader)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.Xml.XmlReader> and returns the root of the corresponding object tree.\n  remarks: \"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.  \\n  \\n You typically would assign the returned object from LoadAsync to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.  \\n  \\n In order for LoadAsync to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\\\"Async\\\"`. The value is treated as case sensitive. If the XAML markup root does not contain `x:SynchronousMode=\\\"Async\\\"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  \\n  \\n Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.\"\n  syntax:\n    content: public object LoadAsync (System.Xml.XmlReader reader);\n    parameters:\n    - id: reader\n      type: System.Xml.XmlReader\n      description: An existing  <xref:System.Xml.XmlReader> that has already loaded/read the XAML input.\n    return:\n      type: System.Object\n      description: The root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.LoadAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>reader</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: Multiple load operations are performed concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)\n  id: LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: LoadAsync(Stream,ParserContext)\n  nameWithType: XamlReader.LoadAsync(Stream,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(Stream,ParserContext)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified <xref:System.IO.Stream> and returns the root of the corresponding object tree.\n  remarks: \"An asynchronous XAML load operation will initially return an object that is purely the root object. Asynchronously, XAML parsing then continues, and any child objects are filled in under the root. This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime. In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded. That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.  \\n  \\n You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI. For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.  \\n  \\n In order for LoadAsync to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode=\\\"Async\\\"`. The value is treated as case sensitive. If the XAML markup root does not contain `x:SynchronousMode=\\\"Async\\\"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  \\n  \\n Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.  If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.\"\n  syntax:\n    content: public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);\n    parameters:\n    - id: stream\n      type: System.IO.Stream\n      description: A stream containing the XAML input to load.\n    - id: parserContext\n      type: System.Windows.Markup.ParserContext\n      description: Context information used by the parser.\n    return:\n      type: System.Object\n      description: The root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.LoadAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>stream</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: Multiple load operations are performed concurrently with the same <xref href=\"System.Windows.Markup.XamlReader\"></xref>.\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.LoadCompleted\n  id: LoadCompleted\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: LoadCompleted\n  nameWithType: XamlReader.LoadCompleted\n  fullName: System.Windows.Markup.XamlReader.LoadCompleted\n  type: Event\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Occurs when an asynchronous load operation completes.\n  remarks: LoadCompleted is also raised when an asynchronous load operation aborts.\n  syntax:\n    content: public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;\n    return:\n      type: System.ComponentModel.AsyncCompletedEventHandler\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Parse(System.String)\n  id: Parse(System.String)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Parse(String)\n  nameWithType: XamlReader.Parse(String)\n  fullName: System.Windows.Markup.XamlReader.Parse(String)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.\n  remarks: The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.\n  syntax:\n    content: public static object Parse (string xamlText);\n    parameters:\n    - id: xamlText\n      type: System.String\n      description: The input XAML, as a single text string.\n    return:\n      type: System.Object\n      description: The root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Parse*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)\n  id: Parse(System.String,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  langs:\n  - csharp\n  name: Parse(String,ParserContext)\n  nameWithType: XamlReader.Parse(String,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.Parse(String,ParserContext)\n  type: Method\n  assemblies:\n  - PresentationFramework\n  namespace: System.Windows.Markup\n  summary: Reads the XAML markup in the specified text string (using a specified <xref href=\"System.Windows.Markup.ParserContext\"></xref>) and returns an object that corresponds to the root of the specified markup.\n  remarks: The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string. See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.\n  syntax:\n    content: public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);\n    parameters:\n    - id: xamlText\n      type: System.String\n      description: The input XAML, as a single text string.\n    - id: parserContext\n      type: System.Windows.Markup.ParserContext\n      description: Context information used by the parser.\n    return:\n      type: System.Object\n      description: The root of the created object tree.\n  overload: System.Windows.Markup.XamlReader.Parse*\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.InvalidOperationException\n  isExternal: true\n  name: System.InvalidOperationException\n- uid: System.Windows.Markup.XamlReader.#ctor\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: XamlReader()\n  nameWithType: XamlReader.XamlReader()\n  fullName: System.Windows.Markup.XamlReader.XamlReader()\n- uid: System.Windows.Markup.XamlReader.CancelAsync\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: CancelAsync()\n  nameWithType: XamlReader.CancelAsync()\n  fullName: System.Windows.Markup.XamlReader.CancelAsync()\n- uid: System.Windows.Markup.XamlReader.GetWpfSchemaContext\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: GetWpfSchemaContext()\n  nameWithType: XamlReader.GetWpfSchemaContext()\n  fullName: System.Windows.Markup.XamlReader.GetWpfSchemaContext()\n- uid: System.Xaml.XamlSchemaContext\n  parent: System.Xaml\n  isExternal: false\n  name: XamlSchemaContext\n  nameWithType: XamlSchemaContext\n  fullName: System.Xaml.XamlSchemaContext\n- uid: System.Windows.Markup.XamlReader.Load(System.IO.Stream)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Load(Stream)\n  nameWithType: XamlReader.Load(Stream)\n  fullName: System.Windows.Markup.XamlReader.Load(Stream)\n- uid: System.IO.Stream\n  parent: System.IO\n  isExternal: true\n  name: Stream\n  nameWithType: Stream\n  fullName: System.IO.Stream\n- uid: System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Load(XamlReader)\n  nameWithType: XamlReader.Load(XamlReader)\n  fullName: System.Windows.Markup.XamlReader.Load(XamlReader)\n- uid: System.Xaml.XamlReader\n  parent: System.Xaml\n  isExternal: false\n  name: XamlReader\n  nameWithType: XamlReader\n  fullName: System.Xaml.XamlReader\n- uid: System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Load(XmlReader)\n  nameWithType: XamlReader.Load(XmlReader)\n  fullName: System.Windows.Markup.XamlReader.Load(XmlReader)\n- uid: System.Xml.XmlReader\n  parent: System.Xml\n  isExternal: true\n  name: XmlReader\n  nameWithType: XmlReader\n  fullName: System.Xml.XmlReader\n- uid: System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Load(Stream,ParserContext)\n  nameWithType: XamlReader.Load(Stream,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.Load(Stream,ParserContext)\n- uid: System.Windows.Markup.ParserContext\n  parent: System.Windows.Markup\n  isExternal: false\n  name: ParserContext\n  nameWithType: ParserContext\n  fullName: System.Windows.Markup.ParserContext\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: LoadAsync(Stream)\n  nameWithType: XamlReader.LoadAsync(Stream)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(Stream)\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: LoadAsync(XmlReader)\n  nameWithType: XamlReader.LoadAsync(XmlReader)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(XmlReader)\n- uid: System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: LoadAsync(Stream,ParserContext)\n  nameWithType: XamlReader.LoadAsync(Stream,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.LoadAsync(Stream,ParserContext)\n- uid: System.Windows.Markup.XamlReader.LoadCompleted\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: LoadCompleted\n  nameWithType: XamlReader.LoadCompleted\n  fullName: System.Windows.Markup.XamlReader.LoadCompleted\n- uid: System.ComponentModel.AsyncCompletedEventHandler\n  parent: System.ComponentModel\n  isExternal: true\n  name: AsyncCompletedEventHandler\n  nameWithType: AsyncCompletedEventHandler\n  fullName: System.ComponentModel.AsyncCompletedEventHandler\n- uid: System.Windows.Markup.XamlReader.Parse(System.String)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Parse(String)\n  nameWithType: XamlReader.Parse(String)\n  fullName: System.Windows.Markup.XamlReader.Parse(String)\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Parse(String,ParserContext)\n  nameWithType: XamlReader.Parse(String,ParserContext)\n  fullName: System.Windows.Markup.XamlReader.Parse(String,ParserContext)\n- uid: System.Windows.Markup.XamlReader.#ctor*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: XamlReader\n  nameWithType: XamlReader.XamlReader\n- uid: System.Windows.Markup.XamlReader.CancelAsync*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: CancelAsync\n  nameWithType: XamlReader.CancelAsync\n- uid: System.Windows.Markup.XamlReader.GetWpfSchemaContext*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: GetWpfSchemaContext\n  nameWithType: XamlReader.GetWpfSchemaContext\n- uid: System.Windows.Markup.XamlReader.Load*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Load\n  nameWithType: XamlReader.Load\n- uid: System.Windows.Markup.XamlReader.LoadAsync*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: LoadAsync\n  nameWithType: XamlReader.LoadAsync\n- uid: System.Windows.Markup.XamlReader.Parse*\n  parent: System.Windows.Markup.XamlReader\n  isExternal: false\n  name: Parse\n  nameWithType: XamlReader.Parse\n"}