{"nodes":[{"pos":[387,467],"content":"Specifies a method's behavior when called within a constrained execution region.","needQuote":true,"needEscape":true,"nodes":[{"content":"Specifies a method's behavior when called within a constrained execution region.","pos":[0,80]}]},{"pos":[480,971],"content":"The Cer enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.       A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","needQuote":false,"needEscape":true,"nodes":[{"content":"The Cer enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.       A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","pos":[0,489],"nodes":[{"content":"The Cer enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER).","pos":[0,118]},{"content":"Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.","pos":[119,292]},{"content":"A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","pos":[299,489]}]}]},{"pos":[1949,2203],"content":"In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.","needQuote":true,"needEscape":true,"nodes":[{"content":"In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.","pos":[0,254],"nodes":[{"content":"In the face of exceptional conditions, the method might fail.","pos":[0,61]},{"content":"In this case, the method will report back to the calling method whether it succeeded or failed.","pos":[62,157]},{"content":"The method must have a CER around the method body to ensure that it can report the return value.","pos":[158,254]}]}]},{"pos":[2318,2330],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[2701,2829],"content":"The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:","needQuote":false,"needEscape":true,"nodes":[{"content":"The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:","pos":[0,128],"nodes":[{"content":"The method, type, or assembly has no concept of a CER.","pos":[0,54]},{"content":"It does not take advantage of CER guarantees.","pos":[55,100]},{"content":"This implies the following:","pos":[101,128]}]}]},{"pos":[2843,3204],"content":"-   In the face of exceptional conditions the method might fail.      -   The method might or might not report that it failed (it is non-deterministic).      -   The method is not written with CERs in mind (which is the most likely scenario).       If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`.","needQuote":false,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">-</ph>   In the face of exceptional conditions the method might fail.","pos":[0,64],"source":"-   In the face of exceptional conditions the method might fail."},{"content":"-   The method might or might not report that it failed (it is non-deterministic).","pos":[70,152]},{"content":"-   The method is not written with CERs in mind (which is the most likely scenario).","pos":[158,242]},{"content":"If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as <ph id=\"ph1\">`Cer.None`</ph>.","pos":[249,355],"source":"       If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`."}]},{"pos":[3317,3329],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[3714,4302],"content":"In the face of exceptional conditions, the method is guaranteed to succeed. You should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended. For example, marking <xref:System.Collections.ArrayList.Count*> with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state.","needQuote":true,"needEscape":true,"nodes":[{"content":"In the face of exceptional conditions, the method is guaranteed to succeed.","pos":[0,75]},{"content":"You should always construct a CER around the method that is called, even when it is called from within a non-CER region.","pos":[76,196]},{"content":"A method is successful if it accomplishes what is intended.","pos":[197,256]},{"content":"For example, marking &lt;xref:System.Collections.ArrayList.Count*&gt; with <ph id=\"ph1\">`ReliabilityContractAttribute(Cer.Success)`</ph> implies that when it is run under a CER, it always returns a count of the number of elements in the <bpt id=\"p1\">&lt;xref href=\"System.Collections.ArrayList\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> and it can never leave the internal fields in an undetermined state.","pos":[257,588],"source":" For example, marking <xref:System.Collections.ArrayList.Count*> with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state."}]},{"pos":[4417,4429],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.ConstrainedExecution.Cer\n  id: Cer\n  children:\n  - System.Runtime.ConstrainedExecution.Cer.MayFail\n  - System.Runtime.ConstrainedExecution.Cer.None\n  - System.Runtime.ConstrainedExecution.Cer.Success\n  langs:\n  - csharp\n  name: Cer\n  nameWithType: Cer\n  fullName: System.Runtime.ConstrainedExecution.Cer\n  type: Enum\n  summary: Specifies a method's behavior when called within a constrained execution region.\n  remarks: \"The Cer enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.  \\n  \\n A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.\"\n  example:\n  - \"The following code example demonstrates the use of the Cer enumeration when specifying a constrained execution region for a method. This code example is part of a larger example provided for the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute.%23ctor%2A> constructor.  \\n  \\n [!code-vb[System.Runtime.ConstrainedExecution#3](~/add/codesnippet/visualbasic/t-system.runtime.constra_2_1.vb)]\\n [!code-cs[System.Runtime.ConstrainedExecution#3](~/add/codesnippet/csharp/t-system.runtime.constra_2_1.cs)]\"\n  syntax:\n    content: public enum Cer\n  inheritance:\n  - System.Enum\n  platform:\n  - net462\n- uid: System.Runtime.ConstrainedExecution.Cer.MayFail\n  id: MayFail\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: MayFail\n  nameWithType: Cer.MayFail\n  fullName: System.Runtime.ConstrainedExecution.Cer.MayFail\n  type: Field\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.ConstrainedExecution\n  summary: In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.\n  syntax:\n    content: MayFail\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Runtime.ConstrainedExecution.Cer.None\n  id: None\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: None\n  nameWithType: Cer.None\n  fullName: System.Runtime.ConstrainedExecution.Cer.None\n  type: Field\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.ConstrainedExecution\n  summary: 'The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:'\n  remarks: \"-   In the face of exceptional conditions the method might fail.  \\n  \\n-   The method might or might not report that it failed (it is non-deterministic).  \\n  \\n-   The method is not written with CERs in mind (which is the most likely scenario).  \\n  \\n If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`.\"\n  syntax:\n    content: None\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Runtime.ConstrainedExecution.Cer.Success\n  id: Success\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: Success\n  nameWithType: Cer.Success\n  fullName: System.Runtime.ConstrainedExecution.Cer.Success\n  type: Field\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.ConstrainedExecution\n  summary: In the face of exceptional conditions, the method is guaranteed to succeed. You should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended. For example, marking <xref:System.Collections.ArrayList.Count*> with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state.\n  syntax:\n    content: Success\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Enum\n  isExternal: false\n  name: System.Enum\n- uid: System.Runtime.ConstrainedExecution.Cer.MayFail\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: MayFail\n  nameWithType: Cer.MayFail\n  fullName: System.Runtime.ConstrainedExecution.Cer.MayFail\n- uid: System.Runtime.ConstrainedExecution.Cer\n  parent: System.Runtime.ConstrainedExecution\n  isExternal: false\n  name: Cer\n  nameWithType: Cer\n  fullName: System.Runtime.ConstrainedExecution.Cer\n- uid: System.Runtime.ConstrainedExecution.Cer.None\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: None\n  nameWithType: Cer.None\n  fullName: System.Runtime.ConstrainedExecution.Cer.None\n- uid: System.Runtime.ConstrainedExecution.Cer.Success\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: Success\n  nameWithType: Cer.Success\n  fullName: System.Runtime.ConstrainedExecution.Cer.Success\n"}