{"nodes":[{"pos":[625,707],"content":"The TransmitFileOptions enumeration defines values used in file transfer requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"The TransmitFileOptions enumeration defines values used in file transfer requests.","pos":[0,82]}]},{"pos":[720,1262],"content":"**Note** The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted. These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QOS-enabled socket is to call <xref:System.Net.Sockets.Socket.Close%2A> when the file transfer has completed, rather than relying on these flags.","needQuote":false,"needEscape":true,"nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted.","pos":[0,134],"source":"**Note** The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted."},{"content":"These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed.","pos":[135,372]},{"content":"The best approach for a QOS-enabled socket is to call &lt;xref:System.Net.Sockets.Socket.Close%2A&gt; when the file transfer has completed, rather than relying on these flags.","pos":[373,542],"source":" The best approach for a QOS-enabled socket is to call <xref:System.Net.Sockets.Socket.Close%2A> when the file transfer has completed, rather than relying on these flags."}]},{"pos":[2349,2570],"content":"Start a transport-level disconnect after all the file data has been queued for transmission. When used with ReuseSocket, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","needQuote":true,"needEscape":true,"nodes":[{"content":"Start a transport-level disconnect after all the file data has been queued for transmission. When used with ReuseSocket, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","pos":[0,221],"nodes":[{"content":"Start a transport-level disconnect after all the file data has been queued for transmission.","pos":[0,92]},{"content":"When used with ReuseSocket, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","pos":[93,221]}]}]},{"pos":[2687,2699],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[3098,3342],"content":"The socket handle may be reused when the request completes. This flag is valid only if Disconnect is also specified. When used with Disconnect, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","needQuote":true,"needEscape":true,"nodes":[{"content":"The socket handle may be reused when the request completes. This flag is valid only if Disconnect is also specified. When used with Disconnect, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","pos":[0,244],"nodes":[{"content":"The socket handle may be reused when the request completes.","pos":[0,59]},{"content":"This flag is valid only if Disconnect is also specified.","pos":[60,116]},{"content":"When used with Disconnect, these flags return the socket to a disconnected, reusable state after the file has been transmitted.","pos":[117,244]}]}]},{"pos":[3460,3472],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[3926,3988],"content":"Use the default thread to process long file transfer requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"Use the default thread to process long file transfer requests.","pos":[0,62]}]},{"pos":[4117,4129],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[4533,4845],"content":"Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests. Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.","needQuote":true,"needEscape":true,"nodes":[{"content":"Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests. Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.","pos":[0,312],"nodes":[{"content":"Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests.","pos":[0,112]},{"content":"Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.","pos":[113,312]}]}]},{"pos":[4964,4976],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[5395,5453],"content":"Use system threads to process long file transfer requests.","needQuote":true,"needEscape":true,"nodes":[{"content":"Use system threads to process long file transfer requests.","pos":[0,58]}]},{"pos":[5575,5587],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]},{"pos":[5986,6265],"content":"Complete the file transfer request immediately, without pending. If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this flag with the Disconnect and ReuseSocket flags.","needQuote":true,"needEscape":true,"nodes":[{"content":"Complete the file transfer request immediately, without pending. If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this flag with the Disconnect and ReuseSocket flags.","pos":[0,279],"nodes":[{"content":"Complete the file transfer request immediately, without pending.","pos":[0,64]},{"content":"If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end.","pos":[65,215]},{"content":"Do not use this flag with the Disconnect and ReuseSocket flags.","pos":[216,279]}]}]},{"pos":[6383,6395],"content":"To be added.","needQuote":true,"needEscape":true,"nodes":[{"content":"To be added.","pos":[0,12]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Net.Sockets.TransmitFileOptions\n  id: TransmitFileOptions\n  children:\n  - System.Net.Sockets.TransmitFileOptions.Disconnect\n  - System.Net.Sockets.TransmitFileOptions.ReuseSocket\n  - System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\n  - System.Net.Sockets.TransmitFileOptions.UseKernelApc\n  - System.Net.Sockets.TransmitFileOptions.UseSystemThread\n  - System.Net.Sockets.TransmitFileOptions.WriteBehind\n  langs:\n  - csharp\n  name: TransmitFileOptions\n  nameWithType: TransmitFileOptions\n  fullName: System.Net.Sockets.TransmitFileOptions\n  type: Enum\n  summary: The TransmitFileOptions enumeration defines values used in file transfer requests.\n  remarks: '**Note** The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted. These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QOS-enabled socket is to call <xref:System.Net.Sockets.Socket.Close%2A> when the file transfer has completed, rather than relying on these flags.'\n  example:\n  - \"The following example demonstrates the use of TransmitFileOptions in a call to <xref:System.Net.Sockets.Socket.SendFile%2A>. The file \\\"test.txt\\\" is located in the root directory of the local machine. In this example, a prebuffer and postbuffer of data are created and sent to the remote host with the file. To use the system's default thread, UseDefaultWorkerThread is specified.  \\n  \\n [!code-cs[NCLSocketEnhancements#4](~/add/codesnippet/csharp/t-system.net.sockets.tra_1.cs)]\\n [!code-cpp[NCLSocketEnhancements#4](~/add/codesnippet/cpp/t-system.net.sockets.tra_1.cpp)]\"\n  syntax:\n    content: >-\n      [System.Flags]\n\n      public enum TransmitFileOptions\n  inheritance:\n  - System.Enum\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.Disconnect\n  id: Disconnect\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: Disconnect\n  nameWithType: TransmitFileOptions.Disconnect\n  fullName: System.Net.Sockets.TransmitFileOptions.Disconnect\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: Start a transport-level disconnect after all the file data has been queued for transmission. When used with ReuseSocket, these flags return the socket to a disconnected, reusable state after the file has been transmitted.\n  syntax:\n    content: Disconnect\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.ReuseSocket\n  id: ReuseSocket\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: ReuseSocket\n  nameWithType: TransmitFileOptions.ReuseSocket\n  fullName: System.Net.Sockets.TransmitFileOptions.ReuseSocket\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: The socket handle may be reused when the request completes. This flag is valid only if Disconnect is also specified. When used with Disconnect, these flags return the socket to a disconnected, reusable state after the file has been transmitted.\n  syntax:\n    content: ReuseSocket\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\n  id: UseDefaultWorkerThread\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: UseDefaultWorkerThread\n  nameWithType: TransmitFileOptions.UseDefaultWorkerThread\n  fullName: System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: Use the default thread to process long file transfer requests.\n  syntax:\n    content: UseDefaultWorkerThread\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.UseKernelApc\n  id: UseKernelApc\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: UseKernelApc\n  nameWithType: TransmitFileOptions.UseKernelApc\n  fullName: System.Net.Sockets.TransmitFileOptions.UseKernelApc\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests. Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.\n  syntax:\n    content: UseKernelApc\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.UseSystemThread\n  id: UseSystemThread\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: UseSystemThread\n  nameWithType: TransmitFileOptions.UseSystemThread\n  fullName: System.Net.Sockets.TransmitFileOptions.UseSystemThread\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: Use system threads to process long file transfer requests.\n  syntax:\n    content: UseSystemThread\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Net.Sockets.TransmitFileOptions.WriteBehind\n  id: WriteBehind\n  parent: System.Net.Sockets.TransmitFileOptions\n  langs:\n  - csharp\n  name: WriteBehind\n  nameWithType: TransmitFileOptions.WriteBehind\n  fullName: System.Net.Sockets.TransmitFileOptions.WriteBehind\n  type: Field\n  assemblies:\n  - System\n  namespace: System.Net.Sockets\n  summary: Complete the file transfer request immediately, without pending. If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this flag with the Disconnect and ReuseSocket flags.\n  syntax:\n    content: WriteBehind\n    return:\n      type: System.Net.Sockets.TransmitFileOptions\n      description: To be added.\n  exceptions: []\n  platform:\n  - net462\nreferences:\n- uid: System.Enum\n  isExternal: false\n  name: System.Enum\n- uid: System.Net.Sockets.TransmitFileOptions.Disconnect\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: Disconnect\n  nameWithType: TransmitFileOptions.Disconnect\n  fullName: System.Net.Sockets.TransmitFileOptions.Disconnect\n- uid: System.Net.Sockets.TransmitFileOptions\n  parent: System.Net.Sockets\n  isExternal: false\n  name: TransmitFileOptions\n  nameWithType: TransmitFileOptions\n  fullName: System.Net.Sockets.TransmitFileOptions\n- uid: System.Net.Sockets.TransmitFileOptions.ReuseSocket\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: ReuseSocket\n  nameWithType: TransmitFileOptions.ReuseSocket\n  fullName: System.Net.Sockets.TransmitFileOptions.ReuseSocket\n- uid: System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: UseDefaultWorkerThread\n  nameWithType: TransmitFileOptions.UseDefaultWorkerThread\n  fullName: System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\n- uid: System.Net.Sockets.TransmitFileOptions.UseKernelApc\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: UseKernelApc\n  nameWithType: TransmitFileOptions.UseKernelApc\n  fullName: System.Net.Sockets.TransmitFileOptions.UseKernelApc\n- uid: System.Net.Sockets.TransmitFileOptions.UseSystemThread\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: UseSystemThread\n  nameWithType: TransmitFileOptions.UseSystemThread\n  fullName: System.Net.Sockets.TransmitFileOptions.UseSystemThread\n- uid: System.Net.Sockets.TransmitFileOptions.WriteBehind\n  parent: System.Net.Sockets.TransmitFileOptions\n  isExternal: false\n  name: WriteBehind\n  nameWithType: TransmitFileOptions.WriteBehind\n  fullName: System.Net.Sockets.TransmitFileOptions.WriteBehind\n"}