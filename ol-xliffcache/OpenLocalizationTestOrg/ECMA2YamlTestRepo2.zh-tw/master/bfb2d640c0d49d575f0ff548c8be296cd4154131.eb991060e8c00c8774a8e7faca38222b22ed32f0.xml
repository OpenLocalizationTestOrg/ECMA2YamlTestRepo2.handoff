{"nodes":[{"pos":[460,522],"content":"Provides conduits for messages that cross remoting boundaries.","needQuote":true,"needEscape":true,"nodes":[{"content":"Provides conduits for messages that cross remoting boundaries.","pos":[0,62]}]},{"pos":[535,2277],"content":"Remoting boundaries can be <xref:System.Runtime.Remoting.Contexts.Context>s, <xref:System.AppDomain>s, processes, or computers. An application can cross these boundaries only by using channels. These crossings can be inbound and outbound. A channel can listen on an endpoint for inbound messages, send to an endpoint for outbound messages, or both. This provides an extensibility point in the runtime to plug in a wide range protocols, even though the runtime might not be at the other end of the channel.       Run-time objects can be used to represent a wide and rich set of semantics and entities. The channel provides the extensibility point to convert the messages to and from the specific protocols. If there are runtimes at both ends of the channel, a virtual channel is created between the two ends, in order to connect the client and server sink chains on either side of the boundary.       The client part of the channel is located at the end of a client context sink chain. The server part of the channel is located at the start of the server context sink chain. Messages are delivered to the client channel using the <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface, travel through the channel, and are then received by the server channel. The server channel delivers the message to the first server context sink.       Channels must expose the IChannel interface, which provides informational properties such as the <xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A> and <xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A> properties. Channels can be registered using the <xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=fullName> method.","needQuote":false,"needEscape":true,"nodes":[{"content":"Remoting boundaries can be <xref:System.Runtime.Remoting.Contexts.Context>s, <xref:System.AppDomain>s, processes, or computers. An application can cross these boundaries only by using channels. These crossings can be inbound and outbound. A channel can listen on an endpoint for inbound messages, send to an endpoint for outbound messages, or both. This provides an extensibility point in the runtime to plug in a wide range protocols, even though the runtime might not be at the other end of the channel.       Run-time objects can be used to represent a wide and rich set of semantics and entities. The channel provides the extensibility point to convert the messages to and from the specific protocols. If there are runtimes at both ends of the channel, a virtual channel is created between the two ends, in order to connect the client and server sink chains on either side of the boundary.       The client part of the channel is located at the end of a client context sink chain. The server part of the channel is located at the start of the server context sink chain. Messages are delivered to the client channel using the <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface, travel through the channel, and are then received by the server channel. The server channel delivers the message to the first server context sink.       Channels must expose the IChannel interface, which provides informational properties such as the <xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A> and <xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A> properties. Channels can be registered using the <xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=fullName> method.","pos":[0,1736],"nodes":[{"content":"Remoting boundaries can be &lt;xref:System.Runtime.Remoting.Contexts.Context&gt;s, &lt;xref:System.AppDomain&gt;s, processes, or computers.","pos":[0,127],"source":"Remoting boundaries can be <xref:System.Runtime.Remoting.Contexts.Context>s, <xref:System.AppDomain>s, processes, or computers."},{"content":"An application can cross these boundaries only by using channels.","pos":[128,193]},{"content":"These crossings can be inbound and outbound.","pos":[194,238]},{"content":"A channel can listen on an endpoint for inbound messages, send to an endpoint for outbound messages, or both.","pos":[239,348]},{"content":"This provides an extensibility point in the runtime to plug in a wide range protocols, even though the runtime might not be at the other end of the channel.","pos":[349,505]},{"content":"Run-time objects can be used to represent a wide and rich set of semantics and entities.","pos":[512,600]},{"content":"The channel provides the extensibility point to convert the messages to and from the specific protocols.","pos":[601,705]},{"content":"If there are runtimes at both ends of the channel, a virtual channel is created between the two ends, in order to connect the client and server sink chains on either side of the boundary.","pos":[706,893]},{"content":"The client part of the channel is located at the end of a client context sink chain.","pos":[900,984]},{"content":"The server part of the channel is located at the start of the server context sink chain.","pos":[985,1073]},{"content":"Messages are delivered to the client channel using the &lt;xref:System.Runtime.Remoting.Messaging.IMessageSink&gt; interface, travel through the channel, and are then received by the server channel.","pos":[1074,1266],"source":" Messages are delivered to the client channel using the <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface, travel through the channel, and are then received by the server channel."},{"content":"The server channel delivers the message to the first server context sink.","pos":[1267,1340]},{"content":"Channels must expose the IChannel interface, which provides informational properties such as the &lt;xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A&gt; and &lt;xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A&gt; properties.","pos":[1347,1591],"source":"       Channels must expose the IChannel interface, which provides informational properties such as the <xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A> and <xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A> properties."},{"content":"Channels can be registered using the &lt;xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=fullName&gt; method.","pos":[1592,1736],"source":" Channels can be registered using the <xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=fullName> method."}]}]},{"pos":[2809,2838],"content":"Gets the name of the channel.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the name of the channel.","pos":[0,29]}]},{"pos":[3316,3340],"content":"The name of the channel.","needQuote":true,"needEscape":true,"nodes":[{"content":"The name of the channel.","pos":[0,24]}]},{"pos":[3534,3595],"content":"The immediate caller does not have infrastructure permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The immediate caller does not have infrastructure permission.","pos":[0,61]}]},{"pos":[4014,4047],"content":"Gets the priority of the channel.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets the priority of the channel.","pos":[0,33]}]},{"pos":[4060,4910],"content":"Higher numbers indicate higher priority, so a channel with priority of 50 has a higher priority than a channel with priority 25. The cross application domain channel has a priority of 100.       Client channels with higher priority are given the first chance to connect to a remote object specified by a URL or a particular channel data entry from a <xref:System.Runtime.Remoting.ObjRef>.       For server channels, the priority indicates the order in which their channel data will appear in a <xref:System.Runtime.Remoting.ObjRef>, which in turn affects the order in which clients will try to connect to the server object. If the server is listening on an HTTP channel with priority 50 and a TCP channel with priority 25 and the client has registered both an HTTP and TCP channel, then the client will use the HTTP channel to talk to the server.","needQuote":false,"needEscape":true,"nodes":[{"content":"Higher numbers indicate higher priority, so a channel with priority of 50 has a higher priority than a channel with priority 25. The cross application domain channel has a priority of 100.       Client channels with higher priority are given the first chance to connect to a remote object specified by a URL or a particular channel data entry from a <xref:System.Runtime.Remoting.ObjRef>.       For server channels, the priority indicates the order in which their channel data will appear in a <xref:System.Runtime.Remoting.ObjRef>, which in turn affects the order in which clients will try to connect to the server object. If the server is listening on an HTTP channel with priority 50 and a TCP channel with priority 25 and the client has registered both an HTTP and TCP channel, then the client will use the HTTP channel to talk to the server.","pos":[0,846],"nodes":[{"content":"Higher numbers indicate higher priority, so a channel with priority of 50 has a higher priority than a channel with priority 25.","pos":[0,128]},{"content":"The cross application domain channel has a priority of 100.","pos":[129,188]},{"content":"Client channels with higher priority are given the first chance to connect to a remote object specified by a URL or a particular channel data entry from a &lt;xref:System.Runtime.Remoting.ObjRef&gt;.","pos":[195,388],"source":"       Client channels with higher priority are given the first chance to connect to a remote object specified by a URL or a particular channel data entry from a <xref:System.Runtime.Remoting.ObjRef>."},{"content":"For server channels, the priority indicates the order in which their channel data will appear in a &lt;xref:System.Runtime.Remoting.ObjRef&gt;, which in turn affects the order in which clients will try to connect to the server object.","pos":[395,623],"source":"       For server channels, the priority indicates the order in which their channel data will appear in a <xref:System.Runtime.Remoting.ObjRef>, which in turn affects the order in which clients will try to connect to the server object."},{"content":"If the server is listening on an HTTP channel with priority 50 and a TCP channel with priority 25 and the client has registered both an HTTP and TCP channel, then the client will use the HTTP channel to talk to the server.","pos":[624,846]}]}]},{"pos":[5375,5429],"content":"An integer that indicates the priority of the channel.","needQuote":true,"needEscape":true,"nodes":[{"content":"An integer that indicates the priority of the channel.","pos":[0,54]}]},{"pos":[5627,5688],"content":"The immediate caller does not have infrastructure permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The immediate caller does not have infrastructure permission.","pos":[0,61]}]},{"pos":[6160,6259],"content":"Returns the object URI as an out parameter, and the URI of the current channel as the return value.","needQuote":true,"needEscape":true,"nodes":[{"content":"Returns the object URI as an out parameter, and the URI of the current channel as the return value.","pos":[0,99]}]},{"pos":[6779,6801],"content":"The URL of the object.","needQuote":true,"needEscape":true,"nodes":[{"content":"The URL of the object.","pos":[0,22]}]},{"pos":[6867,6991],"content":"When this method returns, contains a <xref:System.String> that holds the object URI. This parameter is passed uninitialized.","needQuote":true,"needEscape":true,"nodes":[{"content":"When this method returns, contains a <xref:System.String> that holds the object URI. This parameter is passed uninitialized.","pos":[0,124],"nodes":[{"content":"When this method returns, contains a &lt;xref:System.String&gt; that holds the object URI.","pos":[0,84],"source":"When this method returns, contains a <xref:System.String> that holds the object URI."},{"content":"This parameter is passed uninitialized.","pos":[85,124]}]}]},{"pos":[7049,7188],"content":"The URI of the current channel, or <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the URI does not belong to this channel.","needQuote":true,"needEscape":true,"source":"The URI of the current channel, or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> if the URI does not belong to this channel."},{"pos":[7376,7437],"content":"The immediate caller does not have infrastructure permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The immediate caller does not have infrastructure permission.","pos":[0,61]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.Remoting.Channels.IChannel\n  id: IChannel\n  children:\n  - System.Runtime.Remoting.Channels.IChannel.ChannelName\n  - System.Runtime.Remoting.Channels.IChannel.ChannelPriority\n  - System.Runtime.Remoting.Channels.IChannel.Parse(System.String,System.String@)\n  langs:\n  - csharp\n  name: IChannel\n  nameWithType: IChannel\n  fullName: System.Runtime.Remoting.Channels.IChannel\n  type: Interface\n  summary: Provides conduits for messages that cross remoting boundaries.\n  remarks: \"Remoting boundaries can be <xref:System.Runtime.Remoting.Contexts.Context>s, <xref:System.AppDomain>s, processes, or computers. An application can cross these boundaries only by using channels. These crossings can be inbound and outbound. A channel can listen on an endpoint for inbound messages, send to an endpoint for outbound messages, or both. This provides an extensibility point in the runtime to plug in a wide range protocols, even though the runtime might not be at the other end of the channel.  \\n  \\n Run-time objects can be used to represent a wide and rich set of semantics and entities. The channel provides the extensibility point to convert the messages to and from the specific protocols. If there are runtimes at both ends of the channel, a virtual channel is created between the two ends, in order to connect the client and server sink chains on either side of the boundary.  \\n  \\n The client part of the channel is located at the end of a client context sink chain. The server part of the channel is located at the start of the server context sink chain. Messages are delivered to the client channel using the <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface, travel through the channel, and are then received by the server channel. The server channel delivers the message to the first server context sink.  \\n  \\n Channels must expose the IChannel interface, which provides informational properties such as the <xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A> and <xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A> properties. Channels can be registered using the <xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=fullName> method.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public interface IChannel\n  implements: []\n  platform:\n  - net462\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelName\n  id: ChannelName\n  parent: System.Runtime.Remoting.Channels.IChannel\n  langs:\n  - csharp\n  name: ChannelName\n  nameWithType: IChannel.ChannelName\n  fullName: System.Runtime.Remoting.Channels.IChannel.ChannelName\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.Remoting.Channels\n  summary: Gets the name of the channel.\n  remarks: ''\n  example:\n  - >-\n    [!code-cpp[HttpServerChannel_Server_Client#2](~/add/codesnippet/cpp/p-system.runtime.remotin_0_1.cpp)]\n     [!code-cs[HttpServerChannel_Server_Client#2](~/add/codesnippet/csharp/p-system.runtime.remotin_0_1.cs)]\n     [!code-vb[HttpServerChannel_Server_Client#2](~/add/codesnippet/visualbasic/p-system.runtime.remotin_0_1.vb)]\n  syntax:\n    content: public string ChannelName { get; }\n    return:\n      type: System.String\n      description: The name of the channel.\n  overload: System.Runtime.Remoting.Channels.IChannel.ChannelName*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The immediate caller does not have infrastructure permission.\n  platform:\n  - net462\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelPriority\n  id: ChannelPriority\n  parent: System.Runtime.Remoting.Channels.IChannel\n  langs:\n  - csharp\n  name: ChannelPriority\n  nameWithType: IChannel.ChannelPriority\n  fullName: System.Runtime.Remoting.Channels.IChannel.ChannelPriority\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.Remoting.Channels\n  summary: Gets the priority of the channel.\n  remarks: \"Higher numbers indicate higher priority, so a channel with priority of 50 has a higher priority than a channel with priority 25. The cross application domain channel has a priority of 100.  \\n  \\n Client channels with higher priority are given the first chance to connect to a remote object specified by a URL or a particular channel data entry from a <xref:System.Runtime.Remoting.ObjRef>.  \\n  \\n For server channels, the priority indicates the order in which their channel data will appear in a <xref:System.Runtime.Remoting.ObjRef>, which in turn affects the order in which clients will try to connect to the server object. If the server is listening on an HTTP channel with priority 50 and a TCP channel with priority 25 and the client has registered both an HTTP and TCP channel, then the client will use the HTTP channel to talk to the server.\"\n  example:\n  - >-\n    [!code-cs[HttpServerChannel_Server_Client#5](~/add/codesnippet/csharp/p-system.runtime.remotin_5_1.cs)]\n     [!code-vb[HttpServerChannel_Server_Client#5](~/add/codesnippet/visualbasic/p-system.runtime.remotin_5_1.vb)]\n     [!code-cpp[HttpServerChannel_Server_Client#5](~/add/codesnippet/cpp/p-system.runtime.remotin_5_1.cpp)]\n  syntax:\n    content: public int ChannelPriority { get; }\n    return:\n      type: System.Int32\n      description: An integer that indicates the priority of the channel.\n  overload: System.Runtime.Remoting.Channels.IChannel.ChannelPriority*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The immediate caller does not have infrastructure permission.\n  platform:\n  - net462\n- uid: System.Runtime.Remoting.Channels.IChannel.Parse(System.String,System.String@)\n  id: Parse(System.String,System.String@)\n  parent: System.Runtime.Remoting.Channels.IChannel\n  langs:\n  - csharp\n  name: Parse(String,String)\n  nameWithType: IChannel.Parse(String,String)\n  fullName: System.Runtime.Remoting.Channels.IChannel.Parse(String,String)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.Remoting.Channels\n  summary: Returns the object URI as an out parameter, and the URI of the current channel as the return value.\n  remarks: ''\n  example:\n  - >-\n    [!code-cs[HttpServerChannel_Server_Client#5](~/add/codesnippet/csharp/m-system.runtime.remotin_15_1.cs)]\n     [!code-vb[HttpServerChannel_Server_Client#5](~/add/codesnippet/visualbasic/m-system.runtime.remotin_15_1.vb)]\n     [!code-cpp[HttpServerChannel_Server_Client#5](~/add/codesnippet/cpp/m-system.runtime.remotin_15_1.cpp)]\n  syntax:\n    content: public string Parse (string url, out string objectURI);\n    parameters:\n    - id: url\n      type: System.String\n      description: The URL of the object.\n    - id: objectURI\n      type: System.String\n      description: When this method returns, contains a <xref:System.String> that holds the object URI. This parameter is passed uninitialized.\n    return:\n      type: System.String\n      description: The URI of the current channel, or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref> if the URI does not belong to this channel.\n  overload: System.Runtime.Remoting.Channels.IChannel.Parse*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The immediate caller does not have infrastructure permission.\n  platform:\n  - net462\nreferences:\n- uid: System.Security.SecurityException\n  isExternal: true\n  name: System.Security.SecurityException\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelName\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: ChannelName\n  nameWithType: IChannel.ChannelName\n  fullName: System.Runtime.Remoting.Channels.IChannel.ChannelName\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelPriority\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: ChannelPriority\n  nameWithType: IChannel.ChannelPriority\n  fullName: System.Runtime.Remoting.Channels.IChannel.ChannelPriority\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Runtime.Remoting.Channels.IChannel.Parse(System.String,System.String@)\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: Parse(String,String)\n  nameWithType: IChannel.Parse(String,String)\n  fullName: System.Runtime.Remoting.Channels.IChannel.Parse(String,String)\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelName*\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: ChannelName\n  nameWithType: IChannel.ChannelName\n- uid: System.Runtime.Remoting.Channels.IChannel.ChannelPriority*\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: ChannelPriority\n  nameWithType: IChannel.ChannelPriority\n- uid: System.Runtime.Remoting.Channels.IChannel.Parse*\n  parent: System.Runtime.Remoting.Channels.IChannel\n  isExternal: false\n  name: Parse\n  nameWithType: IChannel.Parse\n"}