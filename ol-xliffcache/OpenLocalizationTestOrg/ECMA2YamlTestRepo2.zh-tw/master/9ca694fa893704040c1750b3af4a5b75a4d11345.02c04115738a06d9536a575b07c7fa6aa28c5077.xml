{"nodes":[{"pos":[2502,2659],"content":"Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.","needQuote":true,"needEscape":true,"nodes":[{"content":"Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.","pos":[0,157]}]},{"pos":[2672,7755],"content":"Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:      -   When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.      -   Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=fullName> class and raise events from the <xref:System.Timers.Timer?displayProperty=fullName> class.      -   When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.      -   When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread. You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.   The delegate has the signature      <CodeContentPlaceHolder>0</CodeContentPlaceHolder>   <CodeContentPlaceHolder>1</CodeContentPlaceHolder>        where `state` is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.      > [!NOTE] >  The threads in the managed thread pool are background threads. That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`. This means that a ThreadPool thread will not keep an application running after all foreground threads have exited.      > [!IMPORTANT] >  When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute. Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.       You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.       Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.       There is one thread pool per process. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads. The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method. Each thread uses the default stack size and runs at the default priority.      > [!NOTE] >  Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.       The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.      > [!NOTE] >  When demand is low, the actual number of thread pool threads can fall below the minimum values.       You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.      > [!CAUTION] >  You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.","needQuote":false,"needEscape":true,"nodes":[{"content":"Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.","pos":[0,118]},{"content":"Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.","pos":[119,245]},{"content":"The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.","pos":[246,397]},{"content":"Examples of operations that use thread pool threads include the following:      -   When you create a &lt;xref:System.Threading.Tasks.Task&gt; or &lt;xref:System.Threading.Tasks.Task%601&gt; object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.","pos":[398,685],"source":" Examples of operations that use thread pool threads include the following:      -   When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread."},{"content":"-   Asynchronous timers use the thread pool.","pos":[691,735]},{"content":"Thread pool threads execute callbacks from the &lt;xref:System.Threading.Timer?displayProperty=fullName&gt; class and raise events from the &lt;xref:System.Timers.Timer?displayProperty=fullName&gt; class.","pos":[736,928],"source":" Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=fullName> class and raise events from the <xref:System.Timers.Timer?displayProperty=fullName> class."},{"content":"-   When you use registered wait handles, a system thread monitors the status of the wait handles.","pos":[934,1032]},{"content":"When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.","pos":[1033,1148]},{"content":"-   When you call the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt; method to queue a method for execution on a thread pool thread.","pos":[1154,1295],"source":"      -   When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread."},{"content":"You do this by passing the method a &lt;xref:System.Threading.WaitCallback&gt; delegate.","pos":[1296,1378],"source":" You do this by passing the method a <xref:System.Threading.WaitCallback> delegate."},{"content":"The delegate has the signature      <bpt id=\"p1\">&lt;CodeContentPlaceHolder&gt;</bpt>0<ept id=\"p1\">&lt;/CodeContentPlaceHolder&gt;</ept>   <bpt id=\"p2\">&lt;CodeContentPlaceHolder&gt;</bpt>1<ept id=\"p2\">&lt;/CodeContentPlaceHolder&gt;</ept>        where <ph id=\"ph1\">`state`</ph> is an object that contains data to be used by the delegate.","pos":[1381,1601],"source":"   The delegate has the signature      <CodeContentPlaceHolder>0</CodeContentPlaceHolder>   <CodeContentPlaceHolder>1</CodeContentPlaceHolder>        where `state` is an object that contains data to be used by the delegate."},{"content":"The actual data can be passed to the delegate by calling the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29&gt; method.","pos":[1602,1774],"source":" The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  The threads in the managed thread pool are background threads.","pos":[1780,1855],"source":"      > [!NOTE] >  The threads in the managed thread pool are background threads."},{"content":"That is, their &lt;xref:System.Threading.Thread.IsBackground%2A&gt; properties are <ph id=\"ph1\">`true`</ph>.","pos":[1856,1940],"source":" That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`."},{"content":"This means that a ThreadPool thread will not keep an application running after all foreground threads have exited.","pos":[1941,2055]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute.","pos":[2061,2252],"source":"      > [!IMPORTANT] >  When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute."},{"content":"Therefore, when a method examines thread local storage or fields that are marked with the &lt;xref:System.ThreadStaticAttribute&gt; attribute, the values it finds might be left over from an earlier use of the thread pool thread.","pos":[2253,2475],"source":" Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread."},{"content":"You can also queue work items that are not related to a wait operation to the thread pool.","pos":[2482,2572]},{"content":"To request that a work item be handled by a thread in the thread pool, call the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt; method.","pos":[2573,2716],"source":" To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method."},{"content":"This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.","pos":[2717,2852]},{"content":"There is no way to cancel a work item after it has been queued.","pos":[2853,2916]},{"content":"Timer-queue timers and registered wait operations also use the thread pool.","pos":[2923,2998]},{"content":"Their callback functions are queued to the thread pool.","pos":[2999,3054]},{"content":"There is one thread pool per process.","pos":[3061,3098]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]</ph>, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.","pos":[3099,3303],"source":" Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space."},{"content":"A process can call the &lt;xref:System.Threading.ThreadPool.GetMaxThreads%2A&gt; method to determine the number of threads.","pos":[3304,3421],"source":" A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads."},{"content":"The number of threads in the thread pool can be changed by using the &lt;xref:System.Threading.ThreadPool.SetMaxThreads%2A&gt; method.","pos":[3422,3550],"source":" The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method."},{"content":"Each thread uses the default stack size and runs at the default priority.","pos":[3551,3624]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the <ph id=\"ph2\">`CorSetMaxThreads`</ph> function, defined in the mscoree.h file.","pos":[3630,3799],"source":"      > [!NOTE] >  Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file."},{"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.","pos":[3806,3933]},{"content":"When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.","pos":[3934,4058]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.","pos":[4059,4297],"source":" Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time."},{"content":"Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.","pos":[4298,4425]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  When demand is low, the actual number of thread pool threads can fall below the minimum values.","pos":[4431,4539],"source":"      > [!NOTE] >  When demand is low, the actual number of thread pool threads can fall below the minimum values."},{"content":"You can use the &lt;xref:System.Threading.ThreadPool.GetMinThreads%2A&gt; method to obtain these minimum values.","pos":[4546,4652],"source":"       You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  You can use the &lt;xref:System.Threading.ThreadPool.SetMinThreads%2A&gt; method to increase the minimum number of threads.","pos":[4658,4791],"source":"      > [!CAUTION] >  You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads."},{"content":"However, unnecessarily increasing these values can cause performance problems.","pos":[4792,4870]},{"content":"If too many tasks start at the same time, all of them might appear to be slow.","pos":[4871,4949]},{"content":"In most cases the thread pool will perform better with its own algorithm for allocating threads.","pos":[4950,5046]}]},{"pos":[9263,9352],"content":"Binds an operating system handle to the <bpt id=\"p1\">&lt;xref href=\"System.Threading.ThreadPool\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Binds an operating system handle to the <xref href=\"System.Threading.ThreadPool\"></xref>."},{"pos":[9505,9626],"content":"An <xref:System.IntPtr> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.","needQuote":true,"needEscape":true,"nodes":[{"content":"An <xref:System.IntPtr> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.","pos":[0,121],"nodes":[{"content":"An &lt;xref:System.IntPtr&gt; that holds the handle.","pos":[0,46],"source":"An <xref:System.IntPtr> that holds the handle."},{"content":"The handle must have been opened for overlapped I/O on the unmanaged side.","pos":[47,121]}]}]},{"pos":[9685,9844],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the handle is bound; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the handle is bound; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[10023,10072],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[10530,10619],"content":"Binds an operating system handle to the <bpt id=\"p1\">&lt;xref href=\"System.Threading.ThreadPool\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Binds an operating system handle to the <xref href=\"System.Threading.ThreadPool\"></xref>."},{"pos":[10631,10806],"content":"The <ph id=\"ph1\">`osHandle`</ph> parameter should be a &lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;, which derives from the abstract &lt;xref:System.Runtime.InteropServices.SafeHandle&gt; class.","needQuote":true,"needEscape":true,"source":"The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class."},{"pos":[11022,11187],"content":"A <xref:System.Runtime.InteropServices.SafeHandle> that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.","needQuote":true,"needEscape":true,"nodes":[{"content":"A <xref:System.Runtime.InteropServices.SafeHandle> that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.","pos":[0,165],"nodes":[{"content":"A &lt;xref:System.Runtime.InteropServices.SafeHandle&gt; that holds the operating system handle.","pos":[0,90],"source":"A <xref:System.Runtime.InteropServices.SafeHandle> that holds the operating system handle."},{"content":"The handle must have been opened for overlapped I/O on the unmanaged side.","pos":[91,165]}]}]},{"pos":[11246,11405],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the handle is bound; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the handle is bound; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[11574,11660],"content":"<ph id=\"ph1\">&lt;code&gt;osHandle&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>osHandle</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[12138,12319],"content":"Retrieves the difference between the maximum number of thread pool threads returned by the <xref:System.Threading.ThreadPool.GetMaxThreads*> method, and the number currently active.","needQuote":true,"needEscape":true,"nodes":[{"content":"Retrieves the difference between the maximum number of thread pool threads returned by the &lt;xref:System.Threading.ThreadPool.GetMaxThreads*&gt; method, and the number currently active.","pos":[0,181],"source":"Retrieves the difference between the maximum number of thread pool threads returned by the <xref:System.Threading.ThreadPool.GetMaxThreads*> method, and the number currently active."}]},{"pos":[12332,12744],"content":"When GetAvailableThreads returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.       If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.","needQuote":false,"needEscape":true,"nodes":[{"content":"When GetAvailableThreads returns, the variable specified by <ph id=\"ph1\">`workerThreads`</ph> contains the number of additional worker threads that can be started, and the variable specified by <ph id=\"ph2\">`completionPortThreads`</ph> contains the number of additional asynchronous I/O threads that can be started.","pos":[0,279],"source":"When GetAvailableThreads returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started."},{"content":"If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.","pos":[286,410]}]},{"pos":[13338,13377],"content":"The number of available worker threads.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of available worker threads.","pos":[0,39]}]},{"pos":[13454,13503],"content":"The number of available asynchronous I/O threads.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of available asynchronous I/O threads.","pos":[0,49]}]},{"pos":[14029,14202],"content":"Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.","needQuote":true,"needEscape":true,"nodes":[{"content":"Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.","pos":[0,173],"nodes":[{"content":"Retrieves the number of requests to the thread pool that can be active concurrently.","pos":[0,84]},{"content":"All requests above that number remain queued until thread pool threads become available.","pos":[85,173]}]}]},{"pos":[14215,15045],"content":"When GetMaxThreads returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.       You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.       You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.       You can queue as many thread pool requests as system memory allows. If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.","needQuote":false,"needEscape":true,"nodes":[{"content":"When GetMaxThreads returns, the variable specified by <ph id=\"ph1\">`workerThreads`</ph> contains the maximum number of worker threads allowed in the thread pool, and the variable specified by <ph id=\"ph2\">`completionPortThreads`</ph> contains the maximum number of asynchronous I/O threads allowed in the thread pool.","pos":[0,281],"source":"When GetMaxThreads returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool."},{"content":"You can use the &lt;xref:System.Threading.ThreadPool.GetAvailableThreads%2A&gt; method to determine the actual number of threads in the thread pool at any given time.","pos":[288,448],"source":"       You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time."},{"content":"You can use the &lt;xref:System.Threading.ThreadPool.SetMaxThreads%2A&gt; to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.","pos":[455,615],"source":"       You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool."},{"content":"You can queue as many thread pool requests as system memory allows.","pos":[622,689]},{"content":"If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.","pos":[690,824]}]},{"pos":[16061,16117],"content":"The maximum number of worker threads in the thread pool.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of worker threads in the thread pool.","pos":[0,56]}]},{"pos":[16194,16260],"content":"The maximum number of asynchronous I/O threads in the thread pool.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of asynchronous I/O threads in the thread pool.","pos":[0,66]}]},{"pos":[16780,16959],"content":"Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.","needQuote":true,"needEscape":true,"nodes":[{"content":"Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.","pos":[0,179]}]},{"pos":[16972,17793],"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. By default, the minimum number of threads is set to the number of processors on a system. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.      > [!NOTE] >  When demand is low, the actual number of thread pool threads can fall below the minimum values.","needQuote":false,"needEscape":true,"nodes":[{"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.","pos":[0,127]},{"content":"By default, the minimum number of threads is set to the number of processors on a system.","pos":[128,217]},{"content":"When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.","pos":[218,344]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.","pos":[345,576],"source":" Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time."},{"content":"Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.","pos":[577,704]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  When demand is low, the actual number of thread pool threads can fall below the minimum values.","pos":[710,818],"source":"      > [!NOTE] >  When demand is low, the actual number of thread pool threads can fall below the minimum values."}]},{"pos":[18547,18658],"content":"When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.","needQuote":true,"needEscape":true,"nodes":[{"content":"When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.","pos":[0,111]}]},{"pos":[18735,18856],"content":"When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.","needQuote":true,"needEscape":true,"nodes":[{"content":"When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.","pos":[0,121]}]},{"pos":[19403,19498],"content":"Queues a method for execution. The method executes when a thread pool thread becomes available.","needQuote":true,"needEscape":true,"nodes":[{"content":"Queues a method for execution. The method executes when a thread pool thread becomes available.","pos":[0,95],"nodes":[{"content":"Queues a method for execution.","pos":[0,30]},{"content":"The method executes when a thread pool thread becomes available.","pos":[31,95]}]}]},{"pos":[19511,20459],"content":"You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.      > [!NOTE] >  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatically calls the correct delegate constructor.      ## Version Information    In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29&gt; overload that accepts an object containing the necessary data.","pos":[0,302],"source":"You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data."},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.WaitCallback&gt; constructor, and simply use the <ph id=\"ph2\">`AddressOf`</ph> operator when passing the callback method to &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt;.","pos":[308,535],"source":"      > [!NOTE] >  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>."},{"content":"Visual Basic automatically calls the correct delegate constructor.","pos":[536,602]},{"content":"Version Information    In the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt; method.","pos":[611,876],"source":"      ## Version Information    In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[877,942]}]},{"pos":[21399,21494],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that represents the method to be executed.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.WaitCallback\"></xref> that represents the method to be executed."},{"pos":[21553,21735],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the method is successfully queued; &lt;xref:System.NotSupportedException&gt; is thrown if the work item could not be queued.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method is successfully queued; <xref:System.NotSupportedException> is thrown if the work item could not be queued."},{"pos":[21911,21997],"content":"<ph id=\"ph1\">&lt;code&gt;callBack&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[22100,22187],"content":"The common language runtime (CLR) is hosted, and the host does not support this action.","needQuote":true,"needEscape":true,"nodes":[{"content":"The common language runtime (CLR) is hosted, and the host does not support this action.","pos":[0,87]}]},{"pos":[22711,22872],"content":"Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.","needQuote":true,"needEscape":true,"nodes":[{"content":"Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.","pos":[0,161],"nodes":[{"content":"Queues a method for execution, and specifies an object containing data to be used by the method.","pos":[0,96]},{"content":"The method executes when a thread pool thread becomes available.","pos":[97,161]}]}]},{"pos":[22885,23582],"content":"If the callback method requires complex data, you can define a class to contain the data.      > [!NOTE] >  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to QueueUserWorkItem. Visual Basic automatically calls the correct delegate constructor.      ## Version Information    In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"If the callback method requires complex data, you can define a class to contain the data.","pos":[0,89]},{"content":"&gt; <ph id=\"ph1\">[!NOTE]</ph> &gt;  Visual Basic users can omit the &lt;xref:System.Threading.WaitCallback&gt; constructor, and simply use the <ph id=\"ph2\">`AddressOf`</ph> operator when passing the callback method to QueueUserWorkItem.","pos":[95,284],"source":"      > [!NOTE] >  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to QueueUserWorkItem."},{"content":"Visual Basic automatically calls the correct delegate constructor.","pos":[285,351]},{"content":"Version Information    In the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt; method.","pos":[360,625],"source":"      ## Version Information    In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[626,691]}]},{"pos":[24368,24456],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> representing the method to execute.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.WaitCallback\"></xref> representing the method to execute."},{"pos":[24518,24569],"content":"An object containing data to be used by the method.","needQuote":true,"needEscape":true,"nodes":[{"content":"An object containing data to be used by the method.","pos":[0,51]}]},{"pos":[24628,24810],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the method is successfully queued; &lt;xref:System.NotSupportedException&gt; is thrown if the work item could not be queued.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method is successfully queued; <xref:System.NotSupportedException> is thrown if the work item could not be queued."},{"pos":[24986,25073],"content":"The common language runtime (CLR) is hosted, and the host does not support this action.","needQuote":true,"needEscape":true,"nodes":[{"content":"The common language runtime (CLR) is hosted, and the host does not support this action.","pos":[0,87]}]},{"pos":[25176,25262],"content":"<ph id=\"ph1\">&lt;code&gt;callBack&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[26058,26197],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit signed integer for the time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a 32-bit signed integer for the time-out in milliseconds.","pos":[0,139],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit signed integer for the time-out in milliseconds."}]},{"pos":[26210,29335],"content":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.       The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.      -   The time-out interval elapses.       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.       Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[0,251],"source":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[252,431],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[432,644],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."},{"content":"The RegisterWaitForSingleObject method queues the specified delegate to the thread pool.","pos":[651,739]},{"content":"A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.","pos":[740,871]},{"content":"-   The time-out interval elapses.","pos":[877,911]},{"content":"The RegisterWaitForSingleObject method checks the current state of the specified object's &lt;xref:System.Threading.WaitHandle&gt;.","pos":[918,1043],"source":"       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>."},{"content":"If the object's state is unsignaled, the method registers a wait operation.","pos":[1044,1119]},{"content":"The wait operation is performed by a thread from the thread pool.","pos":[1120,1185]},{"content":"The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.","pos":[1186,1304]},{"content":"If the <ph id=\"ph1\">`timeOutInterval`</ph> parameter is not 0 (zero) and the <ph id=\"ph2\">`executeOnlyOnce`</ph> parameter is <ph id=\"ph3\">`false`</ph>, the timer is reset every time the event is signaled or the time-out interval elapses.","pos":[1305,1489],"source":" If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph2\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph3\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[1495,1760],"source":"      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"Instead of a &lt;xref:System.Threading.Mutex&gt;, use a &lt;xref:System.Threading.Semaphore&gt; with a maximum count of 1.","pos":[1761,1871],"source":" Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1."},{"content":"To cancel the wait operation, call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method.","pos":[1878,2008],"source":"       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method."},{"content":"The wait thread uses the Win32 <ph id=\"ph1\">`WaitForMultipleObjects`</ph> function to monitor registered wait operations.","pos":[2015,2118],"source":"       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations."},{"content":"Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <ph id=\"ph1\">`DuplicateHandle`</ph> function.","pos":[2119,2309],"source":" Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function."},{"content":"Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.","pos":[2310,2483]},{"content":"Before returning, the function modifies the state of some types of synchronization objects.","pos":[2490,2581]},{"content":"Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.","pos":[2582,2685]},{"content":"For example, the count of a semaphore is decreased by one.","pos":[2686,2744]},{"content":"Version Information    Starting with the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method.","pos":[2753,3039],"source":"      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[3040,3105]}]},{"pos":[29694,29828],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[29916,30039],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitOrTimerCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled."},{"pos":[30101,30143],"content":"The object that is passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate.","pos":[0,42]}]},{"pos":[30226,30466],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[30539,30884],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[30966,31065],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that encapsulates the native handle.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle."},{"pos":[31263,31334],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeOutInterval</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>millisecondsTimeOutInterval</code> parameter is less than -1."},{"pos":[32130,32269],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a 64-bit signed integer for the time-out in milliseconds.","pos":[0,139],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds."}]},{"pos":[32282,35407],"content":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.       The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.      -   The time-out interval elapses.       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.       Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[0,251],"source":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[252,431],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[432,644],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."},{"content":"The RegisterWaitForSingleObject method queues the specified delegate to the thread pool.","pos":[651,739]},{"content":"A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.","pos":[740,871]},{"content":"-   The time-out interval elapses.","pos":[877,911]},{"content":"The RegisterWaitForSingleObject method checks the current state of the specified object's &lt;xref:System.Threading.WaitHandle&gt;.","pos":[918,1043],"source":"       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>."},{"content":"If the object's state is unsignaled, the method registers a wait operation.","pos":[1044,1119]},{"content":"The wait operation is performed by a thread from the thread pool.","pos":[1120,1185]},{"content":"The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.","pos":[1186,1304]},{"content":"If the <ph id=\"ph1\">`timeOutInterval`</ph> parameter is not 0 (zero) and the <ph id=\"ph2\">`executeOnlyOnce`</ph> parameter is <ph id=\"ph3\">`false`</ph>, the timer is reset every time the event is signaled or the time-out interval elapses.","pos":[1305,1489],"source":" If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph2\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph3\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[1495,1760],"source":"      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"Instead of a &lt;xref:System.Threading.Mutex&gt;, use a &lt;xref:System.Threading.Semaphore&gt; with a maximum count of 1.","pos":[1761,1871],"source":" Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1."},{"content":"To cancel the wait operation, call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method.","pos":[1878,2008],"source":"       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method."},{"content":"The wait thread uses the Win32 <ph id=\"ph1\">`WaitForMultipleObjects`</ph> function to monitor registered wait operations.","pos":[2015,2118],"source":"       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations."},{"content":"Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <ph id=\"ph1\">`DuplicateHandle`</ph> function.","pos":[2119,2309],"source":" Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function."},{"content":"Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.","pos":[2310,2483]},{"content":"Before returning, the function modifies the state of some types of synchronization objects.","pos":[2490,2581]},{"content":"Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.","pos":[2582,2685]},{"content":"For example, the count of a semaphore is decreased by one.","pos":[2686,2744]},{"content":"Version Information    Starting with the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method.","pos":[2753,3039],"source":"      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[3040,3105]}]},{"pos":[35767,35901],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[35989,36112],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitOrTimerCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled."},{"pos":[36174,36208],"content":"The object passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object passed to the delegate.","pos":[0,34]}]},{"pos":[36291,36531],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[36604,36949],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[37031,37130],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that encapsulates the native handle.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle."},{"pos":[37328,37399],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeOutInterval</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>millisecondsTimeOutInterval</code> parameter is less than -1."},{"pos":[38210,38340],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a &lt;xref:System.TimeSpan&gt; value for the time-out.","pos":[0,130],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out."}]},{"pos":[38353,41478],"content":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.       The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.      -   The time-out interval elapses.       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.       Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[0,251],"source":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[252,431],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[432,644],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."},{"content":"The RegisterWaitForSingleObject method queues the specified delegate to the thread pool.","pos":[651,739]},{"content":"A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.","pos":[740,871]},{"content":"-   The time-out interval elapses.","pos":[877,911]},{"content":"The RegisterWaitForSingleObject method checks the current state of the specified object's &lt;xref:System.Threading.WaitHandle&gt;.","pos":[918,1043],"source":"       The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>."},{"content":"If the object's state is unsignaled, the method registers a wait operation.","pos":[1044,1119]},{"content":"The wait operation is performed by a thread from the thread pool.","pos":[1120,1185]},{"content":"The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.","pos":[1186,1304]},{"content":"If the <ph id=\"ph1\">`timeOutInterval`</ph> parameter is not 0 (zero) and the <ph id=\"ph2\">`executeOnlyOnce`</ph> parameter is <ph id=\"ph3\">`false`</ph>, the timer is reset every time the event is signaled or the time-out interval elapses.","pos":[1305,1489],"source":" If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph2\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph3\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[1495,1760],"source":"      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"Instead of a &lt;xref:System.Threading.Mutex&gt;, use a &lt;xref:System.Threading.Semaphore&gt; with a maximum count of 1.","pos":[1761,1871],"source":" Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1."},{"content":"To cancel the wait operation, call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method.","pos":[1878,2008],"source":"       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method."},{"content":"The wait thread uses the Win32 <ph id=\"ph1\">`WaitForMultipleObjects`</ph> function to monitor registered wait operations.","pos":[2015,2118],"source":"       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations."},{"content":"Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <ph id=\"ph1\">`DuplicateHandle`</ph> function.","pos":[2119,2309],"source":" Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function."},{"content":"Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.","pos":[2310,2483]},{"content":"Before returning, the function modifies the state of some types of synchronization objects.","pos":[2490,2581]},{"content":"Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.","pos":[2582,2685]},{"content":"For example, the count of a semaphore is decreased by one.","pos":[2686,2744]},{"content":"Version Information    Starting with the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method.","pos":[2753,3039],"source":"      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[3040,3105]}]},{"pos":[41822,41956],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[42044,42167],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitOrTimerCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled."},{"pos":[42229,42263],"content":"The object passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object passed to the delegate.","pos":[0,34]}]},{"pos":[42329,42539],"content":"The time-out represented by a <xref:System.TimeSpan>. If `timeout` is 0 (zero), the function tests the object's state and returns immediately. If `timeout` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out represented by a &lt;xref:System.TimeSpan&gt;.","pos":[0,53],"source":"The time-out represented by a <xref:System.TimeSpan>."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 (zero), the function tests the object's state and returns immediately.","pos":[54,142],"source":" If `timeout` is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is -1, the function's time-out interval never elapses.","pos":[143,210],"source":" If `timeout` is -1, the function's time-out interval never elapses."}]},{"pos":[42612,42957],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[43039,43138],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that encapsulates the native handle.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle."},{"pos":[43336,43387],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>timeout</code> parameter is less than -1."},{"pos":[43490,43601],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is greater than <ph id=\"ph2\">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id=\"ph3\">&amp;gt;</ph>.","needQuote":true,"needEscape":true,"source":"The <code>timeout</code> parameter is greater than &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."},{"pos":[44402,44543],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a 32-bit unsigned integer for the time-out in milliseconds.","pos":[0,141],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds."}]},{"pos":[44556,47832],"content":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.       The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.      -   The time-out interval elapses.       The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.       Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.","needQuote":false,"needEscape":true,"nodes":[{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[0,251],"source":"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[252,431],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[432,644],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."},{"content":"The &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method queues the specified delegate to the thread pool.","pos":[651,777],"source":"       The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool."},{"content":"A worker thread will execute the delegate when one of the following occurs:      -   The specified object is in the signaled state.","pos":[778,909]},{"content":"-   The time-out interval elapses.","pos":[915,949]},{"content":"The &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;method checks the current state of the specified object's &lt;xref:System.Threading.WaitHandle&gt;.","pos":[956,1118],"source":"       The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>method checks the current state of the specified object's <xref:System.Threading.WaitHandle>."},{"content":"If the object's state is unsignaled, the method registers a wait operation.","pos":[1119,1194]},{"content":"The wait operation is performed by a thread from the thread pool.","pos":[1195,1260]},{"content":"The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.","pos":[1261,1379]},{"content":"If the <ph id=\"ph1\">`timeOutInterval`</ph> parameter is not 0 (zero) and the <ph id=\"ph2\">`executeOnlyOnce`</ph> parameter is <ph id=\"ph3\">`false`</ph>, the timer is reset every time the event is signaled or the time-out interval elapses.","pos":[1380,1564],"source":" If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses."},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph2\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph3\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[1570,1835],"source":"      > [!IMPORTANT] >  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"Instead of a &lt;xref:System.Threading.Mutex&gt;, use a &lt;xref:System.Threading.Semaphore&gt; with a maximum count of 1.","pos":[1836,1946],"source":" Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1."},{"content":"To cancel the wait operation, call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method.","pos":[1953,2083],"source":"       To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method."},{"content":"The wait thread uses the Win32 <ph id=\"ph1\">`WaitForMultipleObjects`</ph> function to monitor registered wait operations.","pos":[2090,2193],"source":"       The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations."},{"content":"Therefore, if you must use the same native operating system handle in multiple calls to &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;, you must duplicate the handle using the Win32 <ph id=\"ph1\">`DuplicateHandle`</ph> function.","pos":[2194,2422],"source":" Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function."},{"content":"Note that you should not pulse an event object passed to &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;, because the wait thread might not detect that the event is signaled before it is reset.","pos":[2423,2634],"source":" Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset."},{"content":"Before returning, the function modifies the state of some types of synchronization objects.","pos":[2641,2732]},{"content":"Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.","pos":[2733,2836]},{"content":"For example, the count of a semaphore is decreased by one.","pos":[2837,2895]},{"content":"Version Information    Starting with the .NET Framework version 2.0, the &lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName&gt; property value is propagated to worker threads queued using the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method.","pos":[2904,3190],"source":"      ## Version Information    Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method."},{"content":"In earlier versions, the principal information is not propagated.","pos":[3191,3256]}]},{"pos":[50353,50487],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[50575,50698],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitOrTimerCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled."},{"pos":[50760,50794],"content":"The object passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object passed to the delegate.","pos":[0,34]}]},{"pos":[50878,51118],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[51191,51536],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[51618,51738],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that can be used to cancel the registered wait operation.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that can be used to cancel the registered wait operation."},{"pos":[51936,52007],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeOutInterval</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>millisecondsTimeOutInterval</code> parameter is less than -1."},{"pos":[52451,52619],"content":"Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.","pos":[0,168],"nodes":[{"content":"Sets the number of requests to the thread pool that can be active concurrently.","pos":[0,79]},{"content":"All requests above that number remain queued until thread pool threads become available.","pos":[80,168]}]}]},{"pos":[52632,53785],"content":"You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer. To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> property. In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads. To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.       If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.       Use caution when changing the maximum number of threads in the thread pool. While your code might benefit, the changes might have an adverse effect on code libraries you use.       Setting the thread pool size too large can cause performance problems. If too many threads are executing at the same time, the task switching overhead becomes a significant factor.","needQuote":false,"needEscape":true,"nodes":[{"content":"You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer. To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> property. In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads. To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.       If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.       Use caution when changing the maximum number of threads in the thread pool. While your code might benefit, the changes might have an adverse effect on code libraries you use.       Setting the thread pool size too large can cause performance problems. If too many threads are executing at the same time, the task switching overhead becomes a significant factor.","pos":[0,1147],"nodes":[{"content":"You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.","pos":[0,144]},{"content":"To determine how many processors are present, retrieve the value of the &lt;xref:System.Environment.ProcessorCount%2A?displayProperty=fullName&gt; property.","pos":[145,295],"source":" To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> property."},{"content":"In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.","pos":[296,489]},{"content":"To determine the minimum thread pool size,  call the &lt;xref:System.Threading.ThreadPool.GetMinThreads%2A&gt; method.","pos":[490,602],"source":" To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method."},{"content":"If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.","pos":[609,779]},{"content":"Use caution when changing the maximum number of threads in the thread pool.","pos":[786,861]},{"content":"While your code might benefit, the changes might have an adverse effect on code libraries you use.","pos":[862,960]},{"content":"Setting the thread pool size too large can cause performance problems.","pos":[967,1037]},{"content":"If too many threads are executing at the same time, the task switching overhead becomes a significant factor.","pos":[1038,1147]}]}]},{"pos":[53975,54031],"content":"The maximum number of worker threads in the thread pool.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of worker threads in the thread pool.","pos":[0,56]}]},{"pos":[54108,54174],"content":"The maximum number of asynchronous I/O threads in the thread pool.","needQuote":true,"needEscape":true,"nodes":[{"content":"The maximum number of asynchronous I/O threads in the thread pool.","pos":[0,66]}]},{"pos":[54233,54397],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the change is successful; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the change is successful; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[54913,55087],"content":"Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.","needQuote":true,"needEscape":true,"nodes":[{"content":"Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.","pos":[0,174]}]},{"pos":[55100,56617],"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.       When demand is low, the actual number of thread pool threads can fall below the minimum values.       If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads returns `false` and does not change either of the minimum values.      > [!CAUTION] >  By default, the minimum number of threads is set to the number of processors on a system. You can use the SetMinThreads method to increase the minimum number ofthreads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases, the thread pool will perform better with its own algorithm for allocating threads. Reducing the minimum to less than the number of processors can also hurt performance.","needQuote":false,"needEscape":true,"nodes":[{"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.","pos":[0,127]},{"content":"When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.","pos":[128,254]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]</ph>, the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.","pos":[255,486],"source":" Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time."},{"content":"Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.","pos":[487,614]},{"content":"When demand is low, the actual number of thread pool threads can fall below the minimum values.","pos":[621,716]},{"content":"If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using &lt;xref:System.Threading.ThreadPool.GetMaxThreads%2A&gt;), SetMinThreads returns <ph id=\"ph1\">`false`</ph> and does not change either of the minimum values.","pos":[723,978],"source":"       If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads returns `false` and does not change either of the minimum values."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  By default, the minimum number of threads is set to the number of processors on a system.","pos":[984,1089],"source":"      > [!CAUTION] >  By default, the minimum number of threads is set to the number of processors on a system."},{"content":"You can use the SetMinThreads method to increase the minimum number ofthreads.","pos":[1090,1168]},{"content":"However, unnecessarily increasing these values can cause performance problems.","pos":[1169,1247]},{"content":"If too many tasks start at the same time, all of them might appear to be slow.","pos":[1248,1326]},{"content":"In most cases, the thread pool will perform better with its own algorithm for allocating threads.","pos":[1327,1424]},{"content":"Reducing the minimum to less than the number of processors can also hurt performance.","pos":[1425,1510]}]},{"pos":[57363,57439],"content":"The minimum number of worker threads that the thread pool creates on demand.","needQuote":true,"needEscape":true,"nodes":[{"content":"The minimum number of worker threads that the thread pool creates on demand.","pos":[0,76]}]},{"pos":[57516,57602],"content":"The minimum number of asynchronous I/O threads that the thread pool creates on demand.","needQuote":true,"needEscape":true,"nodes":[{"content":"The minimum number of asynchronous I/O threads that the thread pool creates on demand.","pos":[0,86]}]},{"pos":[57661,57825],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the change is successful; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the change is successful; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[58447,58496],"content":"Queues an overlapped I/O operation for execution.","needQuote":true,"needEscape":true,"nodes":[{"content":"Queues an overlapped I/O operation for execution.","pos":[0,49]}]},{"pos":[58509,59178],"content":"For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.      > [!CAUTION] >  Using the UnsafeQueueNativeOverlapped method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueNativeOverlapped, the stack of the thread pool thread does not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.","needQuote":false,"needEscape":true,"nodes":[{"content":"For information about using native Win32 overlapped I/O, see the &lt;xref:System.Threading.Overlapped&gt; class, the &lt;xref:System.Threading.NativeOverlapped&gt; structure, and the <ph id=\"ph1\">`OVERLAPPED`</ph> structure in the Win32 Platform SDK.","pos":[0,220],"source":"For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK."},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using the UnsafeQueueNativeOverlapped method could inadvertently open up a security hole.","pos":[226,331],"source":"      > [!CAUTION] >  Using the UnsafeQueueNativeOverlapped method could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[332,432]},{"content":"When work is queued on a thread pool thread using UnsafeQueueNativeOverlapped, the stack of the thread pool thread does not have the context of the actual callers.","pos":[433,596]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[597,666]}]},{"pos":[59402,59480],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> structure to queue.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to queue."},{"pos":[59539,59742],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the operation was successfully queued to an I/O completion port; otherwise, <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the operation was successfully queued to an I/O completion port; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."},{"pos":[60382,60494],"content":"Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.","needQuote":true,"needEscape":true,"nodes":[{"content":"Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.","pos":[0,112]}]},{"pos":[60507,61185],"content":"Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, UnsafeQueueUserWorkItem does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.      > [!CAUTION] >  Using UnsafeQueueUserWorkItem could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueUserWorkItem, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.","needQuote":false,"needEscape":true,"nodes":[{"content":"Unlike the &lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt; method, UnsafeQueueUserWorkItem does not propagate the calling stack to the worker thread.","pos":[0,157],"source":"Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, UnsafeQueueUserWorkItem does not propagate the calling stack to the worker thread."},{"content":"This allows code to lose the calling stack and thereby to elevate its security privileges.","pos":[158,248]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using UnsafeQueueUserWorkItem could inadvertently open up a security hole.","pos":[254,344],"source":"      > [!CAUTION] >  Using UnsafeQueueUserWorkItem could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[345,445]},{"content":"When work is queued on a thread pool thread using UnsafeQueueUserWorkItem, the stack of the thread pool thread will not have the context of the actual callers.","pos":[446,605]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[606,675]}]},{"pos":[61405,61553],"content":"A <bpt id=\"p1\">&lt;xref href=\"System.Threading.WaitCallback\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> that represents the delegate to invoke when a thread in the thread pool picks up the work item.","needQuote":true,"needEscape":true,"source":"A <xref href=\"System.Threading.WaitCallback\"></xref> that represents the delegate to invoke when a thread in the thread pool picks up the work item."},{"pos":[61615,61692],"content":"The object that is passed to the delegate when serviced from the thread pool.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate when serviced from the thread pool.","pos":[0,77]}]},{"pos":[61751,61918],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> if the method succeeds; &lt;xref:System.OutOfMemoryException&gt; is thrown if the work item could not be queued.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method succeeds; <xref:System.OutOfMemoryException> is thrown if the work item could not be queued."},{"pos":[62110,62159],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[62260,62303],"content":"An out-of-memory condition was encountered.","needQuote":true,"needEscape":true,"nodes":[{"content":"An out-of-memory condition was encountered.","pos":[0,43]}]},{"pos":[62404,62438],"content":"The work item could not be queued.","needQuote":true,"needEscape":true,"nodes":[{"content":"The work item could not be queued.","pos":[0,34]}]},{"pos":[62541,62627],"content":"<ph id=\"ph1\">&lt;code&gt;callBack&lt;/code&gt;</ph> is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"<code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[63453,63658],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","pos":[0,205],"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, using a 32-bit signed integer for the time-out in milliseconds.","pos":[0,134],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, using a 32-bit signed integer for the time-out in milliseconds."},{"content":"This method does not propagate the calling stack to the worker thread.","pos":[135,205]}]}]},{"pos":[63671,65298],"content":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.","needQuote":false,"needEscape":true,"nodes":[{"content":"Unlike the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread.","pos":[0,177],"source":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread."},{"content":"This allows code to lose the calling stack and thereby to elevate its security privileges.","pos":[178,268]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole.","pos":[274,374],"source":"      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[375,475]},{"content":"When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers.","pos":[476,645]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[646,715]},{"content":"Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph1\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph2\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[722,969],"source":"       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[976,1227],"source":"       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[1228,1407],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[1408,1620],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."}]},{"pos":[65663,65797],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[65885,65950],"content":"The delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The delegate to call when the `waitObject` parameter is signaled."},{"pos":[66012,66054],"content":"The object that is passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate.","pos":[0,42]}]},{"pos":[66137,66377],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[66450,66795],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[66877,67004],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that can be used to cancel the registered wait operation.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation."},{"pos":[67208,67279],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeOutInterval</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>millisecondsTimeOutInterval</code> parameter is less than -1."},{"pos":[67392,67441],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[68267,68477],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","pos":[0,210],"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a 64-bit signed integer for the time-out in milliseconds.","pos":[0,139],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds."},{"content":"This method does not propagate the calling stack to the worker thread.","pos":[140,210]}]}]},{"pos":[68490,70117],"content":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.","needQuote":false,"needEscape":true,"nodes":[{"content":"Unlike the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread.","pos":[0,177],"source":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread."},{"content":"This allows code to lose the calling stack and thereby to elevate its security privileges.","pos":[178,268]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole.","pos":[274,374],"source":"      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[375,475]},{"content":"When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers.","pos":[476,645]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[646,715]},{"content":"Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph1\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph2\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[722,969],"source":"       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[976,1227],"source":"       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[1228,1407],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[1408,1620],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."}]},{"pos":[70483,70617],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[70705,70770],"content":"The delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The delegate to call when the `waitObject` parameter is signaled."},{"pos":[70832,70874],"content":"The object that is passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate.","pos":[0,42]}]},{"pos":[70957,71197],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[71270,71615],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[71697,71824],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that can be used to cancel the registered wait operation.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation."},{"pos":[72028,72099],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeOutInterval</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>millisecondsTimeOutInterval</code> parameter is less than -1."},{"pos":[72212,72261],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[73102,73303],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out. This method does not propagate the calling stack to the worker thread.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out. This method does not propagate the calling stack to the worker thread.","pos":[0,201],"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a &lt;xref:System.TimeSpan&gt; value for the time-out.","pos":[0,130],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out."},{"content":"This method does not propagate the calling stack to the worker thread.","pos":[131,201]}]}]},{"pos":[73316,74943],"content":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.","needQuote":false,"needEscape":true,"nodes":[{"content":"Unlike the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread.","pos":[0,177],"source":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread."},{"content":"This allows code to lose the calling stack and thereby to elevate its security privileges.","pos":[178,268]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole.","pos":[274,374],"source":"      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[375,475]},{"content":"When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers.","pos":[476,645]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[646,715]},{"content":"Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph1\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph2\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[722,969],"source":"       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[976,1227],"source":"       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[1228,1407],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[1408,1620],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."}]},{"pos":[75293,75427],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[75515,75580],"content":"The delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The delegate to call when the `waitObject` parameter is signaled."},{"pos":[75642,75684],"content":"The object that is passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate.","pos":[0,42]}]},{"pos":[75750,75960],"content":"The time-out represented by a <xref:System.TimeSpan>. If `timeout` is 0 (zero), the function tests the object's state and returns immediately. If `timeout` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out represented by a &lt;xref:System.TimeSpan&gt;.","pos":[0,53],"source":"The time-out represented by a <xref:System.TimeSpan>."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 (zero), the function tests the object's state and returns immediately.","pos":[54,142],"source":" If `timeout` is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is -1, the function's time-out interval never elapses.","pos":[143,210],"source":" If `timeout` is -1, the function's time-out interval never elapses."}]},{"pos":[76033,76378],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[76460,76587],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that can be used to cancel the registered wait operation.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation."},{"pos":[76791,76842],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is less than -1.","needQuote":true,"needEscape":true,"source":"The <code>timeout</code> parameter is less than -1."},{"pos":[76945,77056],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is greater than <ph id=\"ph2\">&amp;lt;</ph>xref:System.Int32.MaxValue?displayProperty=fullName<ph id=\"ph3\">&amp;gt;</ph>.","needQuote":true,"needEscape":true,"source":"The <code>timeout</code> parameter is greater than &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."},{"pos":[77169,77218],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]},{"pos":[78049,78261],"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","needQuote":true,"needEscape":true,"nodes":[{"content":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.","pos":[0,212],"nodes":[{"content":"Registers a delegate to wait for a &lt;xref:System.Threading.WaitHandle&gt;, specifying a 32-bit unsigned integer for the time-out in milliseconds.","pos":[0,141],"source":"Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds."},{"content":"This method does not propagate the calling stack to the worker thread.","pos":[142,212]}]}]},{"pos":[78274,79901],"content":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.","needQuote":false,"needEscape":true,"nodes":[{"content":"Unlike the &lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt; method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread.","pos":[0,177],"source":"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread."},{"content":"This allows code to lose the calling stack and thereby to elevate its security privileges.","pos":[178,268]},{"content":"&gt; <ph id=\"ph1\">[!CAUTION]</ph> &gt;  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole.","pos":[274,374],"source":"      > [!CAUTION] >  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[375,475]},{"content":"When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers.","pos":[476,645]},{"content":"Malicious code might be able exploit this to avoid permission checks.","pos":[646,715]},{"content":"Using a &lt;xref:System.Threading.Mutex&gt; for <ph id=\"ph1\">`waitObject`</ph> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <ph id=\"ph2\">`WT_EXECUTEDEFAULT`</ph> flag, so each callback is dispatched on a separate thread pool thread.","pos":[722,969],"source":"       Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread."},{"content":"When you are finished using the &lt;xref:System.Threading.RegisteredWaitHandle&gt; that is returned by this method, call its &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method to release references to the wait handle.","pos":[976,1227],"source":"       When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle."},{"content":"We recommend that you always call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method, even if you specify <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`executeOnlyOnce`</ph>.","pos":[1228,1407],"source":" We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`."},{"content":"Garbage collection works more efficiently if you call the &lt;xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName&gt; method instead of depending on the registered wait handle's finalizer.","pos":[1408,1620],"source":" Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer."}]},{"pos":[80267,80401],"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","needQuote":true,"needEscape":true,"nodes":[{"content":"The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.","pos":[0,134],"nodes":[{"content":"The &lt;xref:System.Threading.WaitHandle&gt; to register.","pos":[0,51],"source":"The <xref:System.Threading.WaitHandle> to register."},{"content":"Use a &lt;xref:System.Threading.WaitHandle&gt; other than &lt;xref:System.Threading.Mutex&gt;.","pos":[52,134],"source":" Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>."}]}]},{"pos":[80489,80554],"content":"The delegate to call when the <ph id=\"ph1\">`waitObject`</ph> parameter is signaled.","needQuote":true,"needEscape":true,"source":"The delegate to call when the `waitObject` parameter is signaled."},{"pos":[80616,80658],"content":"The object that is passed to the delegate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The object that is passed to the delegate.","pos":[0,42]}]},{"pos":[80742,80982],"content":"The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.","needQuote":true,"needEscape":true,"nodes":[{"content":"The time-out in milliseconds.","pos":[0,29]},{"content":"If the <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> parameter is 0 (zero), the function tests the object's state and returns immediately.","pos":[30,152],"source":" If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately."},{"content":"If <ph id=\"ph1\">`millisecondsTimeOutInterval`</ph> is -1, the function's time-out interval never elapses.","pos":[153,240],"source":" If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses."}]},{"pos":[81055,81400],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to indicate that the thread will no longer wait on the <ph id=\"ph1\">`waitObject`</ph> parameter after the delegate has been called; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered."},{"pos":[81482,81609],"content":"The <bpt id=\"p1\">&lt;xref href=\"System.Threading.RegisteredWaitHandle\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object that can be used to cancel the registered wait operation.","needQuote":true,"needEscape":true,"source":"The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation."},{"pos":[81811,81860],"content":"The caller does not have the required permission.","needQuote":true,"needEscape":true,"nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.ThreadPool\n  id: ThreadPool\n  children:\n  - System.Threading.ThreadPool.BindHandle(System.IntPtr)\n  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)\n  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)\n  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)\n  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)\n  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)\n  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)\n  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)\n  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)\n  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  langs:\n  - csharp\n  name: ThreadPool\n  nameWithType: ThreadPool\n  fullName: System.Threading.ThreadPool\n  type: Class\n  summary: Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.\n  remarks: \"Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:  \\n  \\n-   When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.  \\n  \\n-   Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=fullName> class and raise events from the <xref:System.Timers.Timer?displayProperty=fullName> class.  \\n  \\n-   When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.  \\n  \\n-   When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread. You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.   The delegate has the signature  \\n  \\n<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  \\n<CodeContentPlaceHolder>1</CodeContentPlaceHolder>  \\n     where `state` is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.  \\n  \\n> [!NOTE]\\n>  The threads in the managed thread pool are background threads. That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`. This means that a ThreadPool thread will not keep an application running after all foreground threads have exited.  \\n  \\n> [!IMPORTANT]\\n>  When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute. Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.  \\n  \\n You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.  \\n  \\n Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.  \\n  \\n There is one thread pool per process. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads. The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method. Each thread uses the default stack size and runs at the default priority.  \\n  \\n> [!NOTE]\\n>  Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.  \\n  \\n The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  \\n  \\n> [!NOTE]\\n>  When demand is low, the actual number of thread pool threads can fall below the minimum values.  \\n  \\n You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.  \\n  \\n> [!CAUTION]\\n>  You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.\"\n  example:\n  - \"In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \\n  \\n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \\n  \\n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)\"\n  syntax:\n    content: public static class ThreadPool\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)\n  id: BindHandle(System.IntPtr)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: BindHandle(IntPtr)\n  nameWithType: ThreadPool.BindHandle(IntPtr)\n  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Binds an operating system handle to the <xref href=\"System.Threading.ThreadPool\"></xref>.\n  syntax:\n    content: public static bool BindHandle (IntPtr osHandle);\n    parameters:\n    - id: osHandle\n      type: System.IntPtr\n      description: An <xref:System.IntPtr> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the handle is bound; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ThreadPool.BindHandle*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)\n  id: BindHandle(System.Runtime.InteropServices.SafeHandle)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: BindHandle(SafeHandle)\n  nameWithType: ThreadPool.BindHandle(SafeHandle)\n  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Binds an operating system handle to the <xref href=\"System.Threading.ThreadPool\"></xref>.\n  remarks: The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.\n  syntax:\n    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);\n    parameters:\n    - id: osHandle\n      type: System.Runtime.InteropServices.SafeHandle\n      description: A <xref:System.Runtime.InteropServices.SafeHandle> that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the handle is bound; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ThreadPool.BindHandle*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>osHandle</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)\n  id: GetAvailableThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: GetAvailableThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Retrieves the difference between the maximum number of thread pool threads returned by the <xref:System.Threading.ThreadPool.GetMaxThreads*> method, and the number currently active.\n  remarks: \"When GetAvailableThreads returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.  \\n  \\n If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.\"\n  example:\n  - \"The following example displays the number of worker threads and I/O threads available when a simple app is started.  \\n  \\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]\"\n  syntax:\n    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);\n    parameters:\n    - id: workerThreads\n      type: System.Int32\n      description: The number of available worker threads.\n    - id: completionPortThreads\n      type: System.Int32\n      description: The number of available asynchronous I/O threads.\n  overload: System.Threading.ThreadPool.GetAvailableThreads*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)\n  id: GetMaxThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: GetMaxThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.\n  remarks: \"When GetMaxThreads returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.  \\n  \\n You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.  \\n  \\n You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.  \\n  \\n You can queue as many thread pool requests as system memory allows. If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.\"\n  example:\n  - \"The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \\n  \\n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]\"\n  syntax:\n    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);\n    parameters:\n    - id: workerThreads\n      type: System.Int32\n      description: The maximum number of worker threads in the thread pool.\n    - id: completionPortThreads\n      type: System.Int32\n      description: The maximum number of asynchronous I/O threads in the thread pool.\n  overload: System.Threading.ThreadPool.GetMaxThreads*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)\n  id: GetMinThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: GetMinThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.\n  remarks: \"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. By default, the minimum number of threads is set to the number of processors on a system. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  \\n  \\n> [!NOTE]\\n>  When demand is low, the actual number of thread pool threads can fall below the minimum values.\"\n  example:\n  - \"The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \\n  \\n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]\"\n  syntax:\n    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);\n    parameters:\n    - id: workerThreads\n      type: System.Int32\n      description: When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.\n    - id: completionPortThreads\n      type: System.Int32\n      description: When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.\n  overload: System.Threading.ThreadPool.GetMinThreads*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)\n  id: QueueUserWorkItem(System.Threading.WaitCallback)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: QueueUserWorkItem(WaitCallback)\n  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)\n  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Queues a method for execution. The method executes when a thread pool thread becomes available.\n  remarks: \"You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.  \\n  \\n> [!NOTE]\\n>  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic automatically calls the correct delegate constructor.  \\n  \\n## Version Information  \\n In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. In earlier versions, the principal information is not propagated.\"\n  example:\n  - \"The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \\n  \\n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]\"\n  syntax:\n    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);\n    parameters:\n    - id: callBack\n      type: System.Threading.WaitCallback\n      description: A <xref href=\"System.Threading.WaitCallback\"></xref> that represents the method to be executed.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method is successfully queued; <xref:System.NotSupportedException> is thrown if the work item could not be queued.\n  overload: System.Threading.ThreadPool.QueueUserWorkItem*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The common language runtime (CLR) is hosted, and the host does not support this action.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: QueueUserWorkItem(WaitCallback,Object)\n  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)\n  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.\n  remarks: \"If the callback method requires complex data, you can define a class to contain the data.  \\n  \\n> [!NOTE]\\n>  Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to QueueUserWorkItem. Visual Basic automatically calls the correct delegate constructor.  \\n  \\n## Version Information  \\n In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method. In earlier versions, the principal information is not propagated.\"\n  example:\n  - \"The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \\n  \\n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]\"\n  syntax:\n    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);\n    parameters:\n    - id: callBack\n      type: System.Threading.WaitCallback\n      description: A <xref href=\"System.Threading.WaitCallback\"></xref> representing the method to execute.\n    - id: state\n      type: System.Object\n      description: An object containing data to be used by the method.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method is successfully queued; <xref:System.NotSupportedException> is thrown if the work item could not be queued.\n  overload: System.Threading.ThreadPool.QueueUserWorkItem*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The common language runtime (CLR) is hosted, and the host does not support this action.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit signed integer for the time-out in milliseconds.\n  remarks: \"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.  \\n  \\n The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  \\n  \\n-   The specified object is in the signaled state.  \\n  \\n-   The time-out interval elapses.  \\n  \\n The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.  \\n  \\n> [!IMPORTANT]\\n>  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.  \\n  \\n To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.  \\n  \\n The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  \\n  \\n Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  \\n  \\n## Version Information  \\n Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.Int32\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle.\n  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>millisecondsTimeOutInterval</code> parameter is less than -1.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds.\n  remarks: \"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.  \\n  \\n The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  \\n  \\n-   The specified object is in the signaled state.  \\n  \\n-   The time-out interval elapses.  \\n  \\n The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.  \\n  \\n> [!IMPORTANT]\\n>  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.  \\n  \\n To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.  \\n  \\n The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  \\n  \\n Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  \\n  \\n## Version Information  \\n Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.Int64\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle.\n  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>millisecondsTimeOutInterval</code> parameter is less than -1.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out.\n  remarks: \"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.  \\n  \\n The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  \\n  \\n-   The specified object is in the signaled state.  \\n  \\n-   The time-out interval elapses.  \\n  \\n The RegisterWaitForSingleObject method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.  \\n  \\n> [!IMPORTANT]\\n>  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.  \\n  \\n To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.  \\n  \\n The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  \\n  \\n Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  \\n  \\n## Version Information  \\n Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object passed to the delegate.\n    - id: timeout\n      type: System.TimeSpan\n      description: The time-out represented by a <xref:System.TimeSpan>. If `timeout` is 0 (zero), the function tests the object's state and returns immediately. If `timeout` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that encapsulates the native handle.\n  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>timeout</code> parameter is less than -1.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <code>timeout</code> parameter is greater than &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds.\n  remarks: \"When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.  \\n  \\n The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  \\n  \\n-   The specified object is in the signaled state.  \\n  \\n-   The time-out interval elapses.  \\n  \\n The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>method checks the current state of the specified object's <xref:System.Threading.WaitHandle>. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.  \\n  \\n> [!IMPORTANT]\\n>  Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread. Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.  \\n  \\n To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method.  \\n  \\n The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function. Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.  \\n  \\n Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  \\n  \\n## Version Information  \\n Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method. In earlier versions, the principal information is not propagated.\"\n  example:\n  - \"The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \\n  \\n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \\n  \\n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \\n  \\n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \\n  \\n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The <xref href=\"System.Threading.WaitOrTimerCallback\"></xref> delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.UInt32\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> that can be used to cancel the registered wait operation.\n  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>millisecondsTimeOutInterval</code> parameter is less than -1.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)\n  id: SetMaxThreads(System.Int32,System.Int32)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: SetMaxThreads(Int32,Int32)\n  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.\n  remarks: \"You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer. To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> property. In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads. To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.  \\n  \\n If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.  \\n  \\n Use caution when changing the maximum number of threads in the thread pool. While your code might benefit, the changes might have an adverse effect on code libraries you use.  \\n  \\n Setting the thread pool size too large can cause performance problems. If too many threads are executing at the same time, the task switching overhead becomes a significant factor.\"\n  syntax:\n    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);\n    parameters:\n    - id: workerThreads\n      type: System.Int32\n      description: The maximum number of worker threads in the thread pool.\n    - id: completionPortThreads\n      type: System.Int32\n      description: The maximum number of asynchronous I/O threads in the thread pool.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the change is successful; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ThreadPool.SetMaxThreads*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)\n  id: SetMinThreads(System.Int32,System.Int32)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: SetMinThreads(Int32,Int32)\n  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.\n  remarks: \"The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  \\n  \\n When demand is low, the actual number of thread pool threads can fall below the minimum values.  \\n  \\n If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), SetMinThreads returns `false` and does not change either of the minimum values.  \\n  \\n> [!CAUTION]\\n>  By default, the minimum number of threads is set to the number of processors on a system. You can use the SetMinThreads method to increase the minimum number ofthreads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases, the thread pool will perform better with its own algorithm for allocating threads. Reducing the minimum to less than the number of processors can also hurt performance.\"\n  example:\n  - \"The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \\n  \\n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]\"\n  syntax:\n    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);\n    parameters:\n    - id: workerThreads\n      type: System.Int32\n      description: The minimum number of worker threads that the thread pool creates on demand.\n    - id: completionPortThreads\n      type: System.Int32\n      description: The minimum number of asynchronous I/O threads that the thread pool creates on demand.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the change is successful; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ThreadPool.SetMinThreads*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)\n  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)\n  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)\n  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Queues an overlapped I/O operation for execution.\n  remarks: \"For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.  \\n  \\n> [!CAUTION]\\n>  Using the UnsafeQueueNativeOverlapped method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueNativeOverlapped, the stack of the thread pool thread does not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.\"\n  syntax:\n    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);\n    parameters:\n    - id: overlapped\n      type: System.Threading.NativeOverlapped*\n      description: The <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to queue.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the operation was successfully queued to an I/O completion port; otherwise, <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.\n  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeQueueUserWorkItem(WaitCallback,Object)\n  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)\n  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.\n  remarks: \"Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, UnsafeQueueUserWorkItem does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  \\n  \\n> [!CAUTION]\\n>  Using UnsafeQueueUserWorkItem could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueUserWorkItem, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.\"\n  syntax:\n    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);\n    parameters:\n    - id: callBack\n      type: System.Threading.WaitCallback\n      description: A <xref href=\"System.Threading.WaitCallback\"></xref> that represents the delegate to invoke when a thread in the thread pool picks up the work item.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate when serviced from the thread pool.\n    return:\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> if the method succeeds; <xref:System.OutOfMemoryException> is thrown if the work item could not be queued.\n  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: An out-of-memory condition was encountered.\n  - type: System.OutOfMemoryException\n    commentId: T:System.OutOfMemoryException\n    description: The work item could not be queued.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>callBack</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.\n  remarks: \"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  \\n  \\n> [!CAUTION]\\n>  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  \\n  \\n Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.  \\n  \\n When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.Int32\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation.\n  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>millisecondsTimeOutInterval</code> parameter is less than -1.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.\n  remarks: \"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  \\n  \\n> [!CAUTION]\\n>  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  \\n  \\n Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.  \\n  \\n When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.Int64\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation.\n  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>millisecondsTimeOutInterval</code> parameter is less than -1.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a <xref:System.TimeSpan> value for the time-out. This method does not propagate the calling stack to the worker thread.\n  remarks: \"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  \\n  \\n> [!CAUTION]\\n>  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  \\n  \\n Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.  \\n  \\n When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate.\n    - id: timeout\n      type: System.TimeSpan\n      description: The time-out represented by a <xref:System.TimeSpan>. If `timeout` is 0 (zero), the function tests the object's state and returns immediately. If `timeout` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation.\n  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>timeout</code> parameter is less than -1.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <code>timeout</code> parameter is greater than &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  langs:\n  - csharp\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Threading\n  summary: Registers a delegate to wait for a <xref:System.Threading.WaitHandle>, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.\n  remarks: \"Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  \\n  \\n> [!CAUTION]\\n>  Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  \\n  \\n Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.  \\n  \\n When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method to release references to the wait handle. We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method, even if you specify `true` for `executeOnlyOnce`. Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> method instead of depending on the registered wait handle's finalizer.\"\n  syntax:\n    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);\n    parameters:\n    - id: waitObject\n      type: System.Threading.WaitHandle\n      description: The <xref:System.Threading.WaitHandle> to register. Use a <xref:System.Threading.WaitHandle> other than <xref:System.Threading.Mutex>.\n    - id: callBack\n      type: System.Threading.WaitOrTimerCallback\n      description: The delegate to call when the `waitObject` parameter is signaled.\n    - id: state\n      type: System.Object\n      description: The object that is passed to the delegate.\n    - id: millisecondsTimeOutInterval\n      type: System.UInt32\n      description: The time-out in milliseconds. If the `millisecondsTimeOutInterval` parameter is 0 (zero), the function tests the object's state and returns immediately. If `millisecondsTimeOutInterval` is -1, the function's time-out interval never elapses.\n    - id: executeOnlyOnce\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to indicate that the thread will no longer wait on the `waitObject` parameter after the delegate has been called; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.\n    return:\n      type: System.Threading.RegisteredWaitHandle\n      description: The <xref href=\"System.Threading.RegisteredWaitHandle\"></xref> object that can be used to cancel the registered wait operation.\n  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  platform:\n  - net462\nreferences:\n- uid: System.Object\n  isExternal: false\n  name: System.Object\n- uid: System.Security.SecurityException\n  isExternal: true\n  name: System.Security.SecurityException\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.NotSupportedException\n  isExternal: true\n  name: System.NotSupportedException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.ApplicationException\n  parent: System\n  isExternal: false\n  name: ApplicationException\n  nameWithType: ApplicationException\n  fullName: System.ApplicationException\n- uid: System.OutOfMemoryException\n  isExternal: true\n  name: System.OutOfMemoryException\n- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: BindHandle(IntPtr)\n  nameWithType: ThreadPool.BindHandle(IntPtr)\n  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.IntPtr\n  parent: System\n  isExternal: true\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: BindHandle(SafeHandle)\n  nameWithType: ThreadPool.BindHandle(SafeHandle)\n  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)\n- uid: System.Runtime.InteropServices.SafeHandle\n  parent: System.Runtime.InteropServices\n  isExternal: true\n  name: SafeHandle\n  nameWithType: SafeHandle\n  fullName: System.Runtime.InteropServices.SafeHandle\n- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetAvailableThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetMaxThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)\n- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetMinThreads(Int32,Int32)\n  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)\n- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: QueueUserWorkItem(WaitCallback)\n  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)\n  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)\n- uid: System.Threading.WaitCallback\n  parent: System.Threading\n  isExternal: false\n  name: WaitCallback\n  nameWithType: WaitCallback\n  fullName: System.Threading.WaitCallback\n- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: QueueUserWorkItem(WaitCallback,Object)\n  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)\n  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n- uid: System.Threading.RegisteredWaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: RegisteredWaitHandle\n  nameWithType: RegisteredWaitHandle\n  fullName: System.Threading.RegisteredWaitHandle\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: true\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.Threading.WaitOrTimerCallback\n  parent: System.Threading\n  isExternal: false\n  name: WaitOrTimerCallback\n  nameWithType: WaitOrTimerCallback\n  fullName: System.Threading.WaitOrTimerCallback\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n- uid: System.Int64\n  parent: System\n  isExternal: true\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: true\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n- uid: System.UInt32\n  parent: System\n  isExternal: true\n  name: UInt32\n  nameWithType: UInt32\n  fullName: System.UInt32\n- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: SetMaxThreads(Int32,Int32)\n  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)\n- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: SetMinThreads(Int32,Int32)\n  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)\n  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)\n- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)\n  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)\n  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)\n- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeQueueUserWorkItem(WaitCallback,Object)\n  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)\n  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)\n- uid: System.Threading.ThreadPool.BindHandle*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: BindHandle\n  nameWithType: ThreadPool.BindHandle\n- uid: System.Threading.ThreadPool.GetAvailableThreads*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetAvailableThreads\n  nameWithType: ThreadPool.GetAvailableThreads\n- uid: System.Threading.ThreadPool.GetMaxThreads*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetMaxThreads\n  nameWithType: ThreadPool.GetMaxThreads\n- uid: System.Threading.ThreadPool.GetMinThreads*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: GetMinThreads\n  nameWithType: ThreadPool.GetMinThreads\n- uid: System.Threading.ThreadPool.QueueUserWorkItem*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: QueueUserWorkItem\n  nameWithType: ThreadPool.QueueUserWorkItem\n- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: RegisterWaitForSingleObject\n  nameWithType: ThreadPool.RegisterWaitForSingleObject\n- uid: System.Threading.ThreadPool.SetMaxThreads*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: SetMaxThreads\n  nameWithType: ThreadPool.SetMaxThreads\n- uid: System.Threading.ThreadPool.SetMinThreads*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: SetMinThreads\n  nameWithType: ThreadPool.SetMinThreads\n- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeQueueNativeOverlapped\n  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped\n- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeQueueUserWorkItem\n  nameWithType: ThreadPool.UnsafeQueueUserWorkItem\n- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*\n  parent: System.Threading.ThreadPool\n  isExternal: false\n  name: UnsafeRegisterWaitForSingleObject\n  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject\n"}