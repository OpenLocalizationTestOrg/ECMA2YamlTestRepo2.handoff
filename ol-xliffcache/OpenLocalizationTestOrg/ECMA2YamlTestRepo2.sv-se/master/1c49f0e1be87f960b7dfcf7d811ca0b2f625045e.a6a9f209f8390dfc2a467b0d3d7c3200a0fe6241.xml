{"nodes":[{"pos":[1224,1398],"content":"Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.HMACSHA1\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <xref href=\"System.Security.Cryptography.HMACSHA1\"></xref>."},{"pos":[1411,2719],"content":"Rfc2898DeriveBytes takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The Rfc2898DeriveBytes class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"Rfc2898DeriveBytes takes a password, a salt, and an iteration count, and then generates keys through calls to the &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt; method.","pos":[0,188],"source":"Rfc2898DeriveBytes takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method."},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[195,296]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[297,468]},{"content":"The Rfc2898DeriveBytes class can be used to produce a derived key from a base key and other parameters.","pos":[469,572]},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[573,710]},{"content":"For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[717,927],"source":"       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[928,976]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[982,1051],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[1053,1297],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[4082,4235],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using a password and salt to derive the key.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password and salt to derive the key."},{"pos":[4248,5444],"content":"The salt size must be 8 bytes or larger.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The salt size must be 8 bytes or larger.","pos":[0,40]},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[47,148]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[149,320]},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class can be used to produce a derived key from a base key and other parameters.","pos":[321,460],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters."},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[461,598]},{"content":"For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[605,815],"source":"       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[816,864]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[870,939],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[941,1185],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[6121,6157],"content":"The password used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The password used to derive the key.","pos":[0,36]}]},{"pos":[6218,6254],"content":"The key salt used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The key salt used to derive the key.","pos":[0,36]}]},{"pos":[6430,6516],"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","pos":[0,86]}]},{"pos":[6619,6704],"content":"The password or salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[7239,7399],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using the password and salt size to derive the key.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using the password and salt size to derive the key."},{"pos":[7412,8608],"content":"The salt size must be 8 bytes or larger.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The salt size must be 8 bytes or larger.","pos":[0,40]},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[47,148]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[149,320]},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class can be used to produce a derived key from a base key and other parameters.","pos":[321,460],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters."},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[461,598]},{"content":"For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[605,815],"source":"       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[816,864]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[870,939],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[941,1185],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[8772,8808],"content":"The password used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The password used to derive the key.","pos":[0,36]}]},{"pos":[8872,8936],"content":"The size of the random salt that you want the class to generate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the random salt that you want the class to generate.","pos":[0,64]}]},{"pos":[9112,9160],"content":"The specified salt size is smaller than 8 bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes.","pos":[0,48]}]},{"pos":[9263,9348],"content":"The password or salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[9932,10110],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using a password, a salt, and number of iterations to derive the key.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt, and number of iterations to derive the key."},{"pos":[10123,11423],"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero.","pos":[0,90]},{"content":"The minimum recommended number of iterations is 1000.","pos":[91,144]},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[151,252]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[253,424]},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class can be used to produce a derived key from a base key and other parameters.","pos":[425,564],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters."},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[565,702]},{"content":"For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[709,919],"source":"       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[920,968]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[974,1043],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[1045,1289],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[11602,11638],"content":"The password used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The password used to derive the key.","pos":[0,36]}]},{"pos":[11699,11735],"content":"The key salt used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The key salt used to derive the key.","pos":[0,36]}]},{"pos":[11801,11844],"content":"The number of iterations for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of iterations for the operation.","pos":[0,43]}]},{"pos":[12020,12106],"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","pos":[0,86]}]},{"pos":[12209,12294],"content":"The password or salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[12878,13056],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using a password, a salt, and number of iterations to derive the key.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt, and number of iterations to derive the key."},{"pos":[13069,14369],"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero.","pos":[0,90]},{"content":"The minimum recommended number of iterations is 1000.","pos":[91,144]},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[151,252]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[253,424]},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class can be used to produce a derived key from a base key and other parameters.","pos":[425,564],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters."},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[565,702]},{"content":"For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[709,919],"source":"       For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[920,968]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[974,1043],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[1045,1289],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[15062,15098],"content":"The password used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The password used to derive the key.","pos":[0,36]}]},{"pos":[15159,15195],"content":"The key salt used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The key salt used to derive the key.","pos":[0,36]}]},{"pos":[15261,15304],"content":"The number of iterations for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of iterations for the operation.","pos":[0,43]}]},{"pos":[15480,15566],"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","pos":[0,86]}]},{"pos":[15669,15754],"content":"The password or salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[16333,16516],"content":"Initializes a new instance of the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class using a password, a salt size, and number of iterations to derive the key.","needQuote":true,"needEscape":true,"source":"Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt size, and number of iterations to derive the key."},{"pos":[16529,17825],"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.       RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.       For more information on PBKDF2, see RFC 2898,\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \"PBKDF2,\" for complete details.      > [!IMPORTANT] >  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"The salt size must be 8 bytes or larger and the iteration count must be greater than zero.","pos":[0,90]},{"content":"The minimum recommended number of iterations is 1000.","pos":[91,144]},{"content":"RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.","pos":[151,252]},{"content":"You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.","pos":[253,424]},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class can be used to produce a derived key from a base key and other parameters.","pos":[425,564],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters."},{"content":"In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.","pos":[565,702]},{"content":"For more information on PBKDF2, see RFC 2898,\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <bpt id=\"p1\">[</bpt>Request for Comments Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.","pos":[709,915],"source":"       For more information on PBKDF2, see RFC 2898,\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119)."},{"content":"See section 5.2, \"PBKDF2,\" for complete details.","pos":[916,964]},{"content":"&gt; <ph id=\"ph1\">[!IMPORTANT]</ph> &gt;  Never hard-code a password within your source code.","pos":[970,1039],"source":"      > [!IMPORTANT] >  Never hard-code a password within your source code."},{"content":"Hard-coded passwords can be retrieved from an assembly by using the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/add/includes/ajax-current-ext-md.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.","pos":[1041,1285],"source":"  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe."}]},{"pos":[18005,18041],"content":"The password used to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The password used to derive the key.","pos":[0,36]}]},{"pos":[18105,18169],"content":"The size of the random salt that you want the class to generate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the random salt that you want the class to generate.","pos":[0,64]}]},{"pos":[18235,18278],"content":"The number of iterations for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of iterations for the operation.","pos":[0,43]}]},{"pos":[18454,18540],"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes or the iteration count is less than 1.","pos":[0,86]}]},{"pos":[18643,18728],"content":"The password or salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."},{"pos":[18843,18930],"content":"<code>iterations </code>is out of range. This parameter requires a non-negative number.","needQuote":true,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;iterations &lt;/code&gt;</ph>is out of range.","pos":[0,40],"source":"<code>iterations </code>is out of range."},{"content":"This parameter requires a non-negative number.","pos":[41,87]}]},{"pos":[19562,19675],"content":"Derives a cryptographic key from the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> object.","needQuote":true,"needEscape":true,"source":"Derives a cryptographic key from the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> object."},{"pos":[19688,19953],"content":"This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.       If the `keySize` parameter is set to 0 bits, the default key size for the specified algorithm is used.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.","pos":[0,154]},{"content":"If the <ph id=\"ph1\">`keySize`</ph> parameter is set to 0 bits, the default key size for the specified algorithm is used.","pos":[161,263],"source":"       If the `keySize` parameter is set to 0 bits, the default key size for the specified algorithm is used."}]},{"pos":[20151,20198],"content":"The algorithm name for which to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The algorithm name for which to derive the key.","pos":[0,47]}]},{"pos":[20266,20315],"content":"The hash algorithm name to use to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The hash algorithm name to use to derive the key.","pos":[0,49]}]},{"pos":[20378,20418],"content":"The size of the key, in bits, to derive.","needQuote":true,"needEscape":true,"nodes":[{"content":"The size of the key, in bits, to derive.","pos":[0,40]}]},{"pos":[20480,20536],"content":"The initialization vector (IV) to use to derive the key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The initialization vector (IV) to use to derive the key.","pos":[0,56]}]},{"pos":[20594,20610],"content":"The derived key.","needQuote":true,"needEscape":true,"nodes":[{"content":"The derived key.","pos":[0,16]}]},{"pos":[20850,21163],"content":"The <code>keySize</code> parameter is incorrect.       -or-       The cryptographic service provider (CSP) cannot be acquired.       -or-       The <code>algname</code> parameter is not a valid algorithm name.       -or-       The <code>alghashname</code> parameter is not a valid hash algorithm name.","needQuote":false,"needEscape":true,"nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">keySize</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is incorrect.","pos":[0,48],"source":"The <code>keySize</code> parameter is incorrect."},{"content":"-or-       The cryptographic service provider (CSP) cannot be acquired.","pos":[55,126]},{"content":"-or-       The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">algname</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not a valid algorithm name.","pos":[133,209],"source":"       -or-       The <code>algname</code> parameter is not a valid algorithm name."},{"content":"-or-       The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">alghashname</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not a valid hash algorithm name.","pos":[216,301],"source":"       -or-       The <code>alghashname</code> parameter is not a valid hash algorithm name."}]},{"pos":[21624,21790],"content":"Releases the unmanaged resources used by the <bpt id=\"p1\">&lt;xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> class and optionally releases the managed resources.","needQuote":true,"needEscape":true,"source":"Releases the unmanaged resources used by the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class and optionally releases the managed resources."},{"pos":[21803,22312],"content":"This method is called by the public `Dispose()` method and the `Finalize` method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. `Finalize` invokes `Dispose` with `disposing` set to `false`.       When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.Rfc2898DeriveBytes> references. This method invokes the `Dispose()` method of each referenced object.","needQuote":false,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is called by the public <ph id=\"ph1\">`Dispose()`</ph> method and the <ph id=\"ph2\">`Finalize`</ph> method.","pos":[0,81],"source":"This method is called by the public `Dispose()` method and the `Finalize` method."},{"content":"<ph id=\"ph1\">`Dispose()`</ph> invokes the protected <ph id=\"ph2\">`Dispose(Boolean)`</ph> method with the <ph id=\"ph3\">`disposing`</ph> parameter set to <ph id=\"ph4\">`true`</ph>.","pos":[82,187],"source":"`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`."},{"content":"<ph id=\"ph1\">`Finalize`</ph> invokes <ph id=\"ph2\">`Dispose`</ph> with <ph id=\"ph3\">`disposing`</ph> set to <ph id=\"ph4\">`false`</ph>.","pos":[188,249],"source":"`Finalize` invokes `Dispose` with `disposing` set to `false`."},{"content":"When the <ph id=\"ph1\">`disposing`</ph> parameter is <ph id=\"ph2\">`true`</ph>, this method releases all resources held by any managed objects that this &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; references.","pos":[256,437],"source":"       When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.Rfc2898DeriveBytes> references."},{"content":"This method invokes the <ph id=\"ph1\">`Dispose()`</ph> method of each referenced object.","pos":[438,507],"source":" This method invokes the `Dispose()` method of each referenced object."}]},{"pos":[22469,22678],"content":"<bpt id=\"p1\">&lt;xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept> to release both managed and unmanaged resources; <bpt id=\"p2\">&lt;xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"&gt;</bpt><ept id=\"p2\">&lt;/xref&gt;</ept> to release only unmanaged resources.","needQuote":true,"needEscape":true,"source":"<xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to release both managed and unmanaged resources; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to release only unmanaged resources."},{"pos":[23219,23265],"content":"Returns the pseudo-random key for this object.","needQuote":true,"needEscape":true,"nodes":[{"content":"Returns the pseudo-random key for this object.","pos":[0,46]}]},{"pos":[23277,23887],"content":"The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class implements PBKDF2 functionality by using a pseudorandom number generator based on <xref:System.Security.Cryptography.HMACSHA1>. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class takes a password, a salt, and an iteration count, and then generates keys through calls to the GetBytes method. Repeated calls to this method will not generate the same key; instead, appending two calls of the GetBytes method with a `cb` parameter value of `20` is the equivalent of calling the GetBytes method once with a `cb` parameter value of `40`.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class implements PBKDF2 functionality by using a pseudorandom number generator based on &lt;xref:System.Security.Cryptography.HMACSHA1&gt;.","pos":[0,192],"source":"The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class implements PBKDF2 functionality by using a pseudorandom number generator based on <xref:System.Security.Cryptography.HMACSHA1>."},{"content":"The &lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt; class takes a password, a salt, and an iteration count, and then generates keys through calls to the GetBytes method.","pos":[193,369],"source":" The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class takes a password, a salt, and an iteration count, and then generates keys through calls to the GetBytes method."},{"content":"Repeated calls to this method will not generate the same key; instead, appending two calls of the GetBytes method with a <ph id=\"ph1\">`cb`</ph> parameter value of <ph id=\"ph2\">`20`</ph> is the equivalent of calling the GetBytes method once with a <ph id=\"ph3\">`cb`</ph> parameter value of <ph id=\"ph4\">`40`</ph>.","pos":[370,610],"source":" Repeated calls to this method will not generate the same key; instead, appending two calls of the GetBytes method with a `cb` parameter value of `20` is the equivalent of calling the GetBytes method once with a `cb` parameter value of `40`."}]},{"pos":[24582,24632],"content":"The number of pseudo-random key bytes to generate.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of pseudo-random key bytes to generate.","pos":[0,50]}]},{"pos":[24690,24739],"content":"A byte array filled with pseudo-random key bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"A byte array filled with pseudo-random key bytes.","pos":[0,49]}]},{"pos":[24938,25017],"content":"<code>cb </code>is out of range. This parameter requires a non-negative number.","needQuote":true,"needEscape":true,"nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;cb &lt;/code&gt;</ph>is out of range.","pos":[0,32],"source":"<code>cb </code>is out of range."},{"content":"This parameter requires a non-negative number.","pos":[33,79]}]},{"pos":[25455,25511],"content":"Gets or sets the number of iterations for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the number of iterations for the operation.","pos":[0,56]}]},{"pos":[25523,25698],"content":"Iteration count is the number of times an operation is performed. For this method, the count should be greater than zero. The minimum recommended number of iterations is 1000.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Iteration count is the number of times an operation is performed. For this method, the count should be greater than zero. The minimum recommended number of iterations is 1000.","pos":[0,175],"nodes":[{"content":"Iteration count is the number of times an operation is performed.","pos":[0,65]},{"content":"For this method, the count should be greater than zero.","pos":[66,121]},{"content":"The minimum recommended number of iterations is 1000.","pos":[122,175]}]}]},{"pos":[26363,26406],"content":"The number of iterations for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of iterations for the operation.","pos":[0,43]}]},{"pos":[26611,26651],"content":"The number of iterations is less than 1.","needQuote":true,"needEscape":true,"nodes":[{"content":"The number of iterations is less than 1.","pos":[0,40]}]},{"pos":[27048,27082],"content":"Resets the state of the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"Resets the state of the operation.","pos":[0,34]}]},{"pos":[27094,27173],"content":"This method is automatically called if the salt or iteration count is modified.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"This method is automatically called if the salt or iteration count is modified.","pos":[0,79]}]},{"pos":[28179,28229],"content":"Gets or sets the key salt value for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"Gets or sets the key salt value for the operation.","pos":[0,50]}]},{"pos":[28241,28675],"content":"Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult. A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys. This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.","needQuote":true,"needEscape":true,"extradata":"MT","nodes":[{"content":"Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult. A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys. This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.","pos":[0,434],"nodes":[{"content":"Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult.","pos":[0,97]},{"content":"A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys.","pos":[98,294]},{"content":"This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.","pos":[295,434]}]}]},{"pos":[28789,28826],"content":"The key salt value for the operation.","needQuote":true,"needEscape":true,"nodes":[{"content":"The key salt value for the operation.","pos":[0,37]}]},{"pos":[29001,29049],"content":"The specified salt size is smaller than 8 bytes.","needQuote":true,"needEscape":true,"nodes":[{"content":"The specified salt size is smaller than 8 bytes.","pos":[0,48]}]},{"pos":[29152,29225],"content":"The salt is <bpt id=\"p1\">&lt;xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"&gt;</bpt><ept id=\"p1\">&lt;/xref&gt;</ept>.","needQuote":true,"needEscape":true,"source":"The salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes\n  id: Rfc2898DeriveBytes\n  children:\n  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])\n  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])\n  - System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\n  - System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\n  - System.Security.Cryptography.Rfc2898DeriveBytes.Reset\n  - System.Security.Cryptography.Rfc2898DeriveBytes.Salt\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes\n  nameWithType: Rfc2898DeriveBytes\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes\n  type: Class\n  summary: Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <xref href=\"System.Security.Cryptography.HMACSHA1\"></xref>.\n  remarks: \"Rfc2898DeriveBytes takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The Rfc2898DeriveBytes class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information about PBKDF2, see RFC 2898, \\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  example:\n  - \"The following code example uses the Rfc2898DeriveBytes class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \\n  \\n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/t-system.security.crypto_117_1.cs)]\\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/t-system.security.crypto_117_1.vb)]\\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/t-system.security.crypto_117_1.cpp)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes\n  inheritance:\n  - System.Object\n  - System.Security.Cryptography.DeriveBytes\n  implements: []\n  inheritedMembers:\n  - System.Security.Cryptography.DeriveBytes.Dispose\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])\n  id: '#ctor(System.String,System.Byte[])'\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes(String,Byte[])\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password and salt to derive the key.\n  remarks: \"The salt size must be 8 bytes or larger.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information about PBKDF2, see RFC 2898, \\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  example:\n  - \"The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \\n  \\n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/7aa0756c-8905-4e75-ae9a-_1.cs)]\\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/7aa0756c-8905-4e75-ae9a-_1.vb)]\\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/7aa0756c-8905-4e75-ae9a-_1.cpp)]\"\n  syntax:\n    content: public Rfc2898DeriveBytes (string password, byte[] salt);\n    parameters:\n    - id: password\n      type: System.String\n      description: The password used to derive the key.\n    - id: salt\n      type: System.Byte[]\n      description: The key salt used to derive the key.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes or the iteration count is less than 1.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)\n  id: '#ctor(System.String,System.Int32)'\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes(String,Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using the password and salt size to derive the key.\n  remarks: \"The salt size must be 8 bytes or larger.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information about PBKDF2, see RFC 2898, \\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  syntax:\n    content: public Rfc2898DeriveBytes (string password, int saltSize);\n    parameters:\n    - id: password\n      type: System.String\n      description: The password used to derive the key.\n    - id: saltSize\n      type: System.Int32\n      description: The size of the random salt that you want the class to generate.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)\n  id: '#ctor(System.Byte[],System.Byte[],System.Int32)'\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt, and number of iterations to derive the key.\n  remarks: \"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information about PBKDF2, see RFC 2898, \\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  syntax:\n    content: public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);\n    parameters:\n    - id: password\n      type: System.Byte[]\n      description: The password used to derive the key.\n    - id: salt\n      type: System.Byte[]\n      description: The key salt used to derive the key.\n    - id: iterations\n      type: System.Int32\n      description: The number of iterations for the operation.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes or the iteration count is less than 1.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)\n  id: '#ctor(System.String,System.Byte[],System.Int32)'\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes(String,Byte[],Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt, and number of iterations to derive the key.\n  remarks: \"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information about PBKDF2, see RFC 2898, \\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  example:\n  - \"The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.  It then encrypts and decrypts some data using the keys.  \\n  \\n [!code-cs[rfc28981#1](~/add/codesnippet/csharp/8b79aa42-3b6a-4a39-985a-_1.cs)]\\n [!code-vb[rfc28981#1](~/add/codesnippet/visualbasic/8b79aa42-3b6a-4a39-985a-_1.vb)]\\n [!code-cpp[rfc28981#1](~/add/codesnippet/cpp/8b79aa42-3b6a-4a39-985a-_1.cpp)]\"\n  syntax:\n    content: public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);\n    parameters:\n    - id: password\n      type: System.String\n      description: The password used to derive the key.\n    - id: salt\n      type: System.Byte[]\n      description: The key salt used to derive the key.\n    - id: iterations\n      type: System.Int32\n      description: The number of iterations for the operation.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes or the iteration count is less than 1.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)\n  id: '#ctor(System.String,System.Int32,System.Int32)'\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Rfc2898DeriveBytes(String,Int32,Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class using a password, a salt size, and number of iterations to derive the key.\n  remarks: \"The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.  \\n  \\n RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.  \\n  \\n For more information on PBKDF2, see RFC 2898,\\\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\\\" available on the [Request for Comments Web site](http://go.microsoft.com/fwlink/?LinkID=37119). See section 5.2, \\\"PBKDF2,\\\" for complete details.  \\n  \\n> [!IMPORTANT]\\n>  Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.\"\n  syntax:\n    content: public Rfc2898DeriveBytes (string password, int saltSize, int iterations);\n    parameters:\n    - id: password\n      type: System.String\n      description: The password used to derive the key.\n    - id: saltSize\n      type: System.Int32\n      description: The size of the random salt that you want the class to generate.\n    - id: iterations\n      type: System.Int32\n      description: The number of iterations for the operation.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes or the iteration count is less than 1.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The password or salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>iterations </code>is out of range. This parameter requires a non-negative number.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])\n  id: CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: CryptDeriveKey(String,String,Int32,Byte[])\n  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Derives a cryptographic key from the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> object.\n  remarks: \"This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.  \\n  \\n If the `keySize` parameter is set to 0 bits, the default key size for the specified algorithm is used.\"\n  syntax:\n    content: public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);\n    parameters:\n    - id: algname\n      type: System.String\n      description: The algorithm name for which to derive the key.\n    - id: alghashname\n      type: System.String\n      description: The hash algorithm name to use to derive the key.\n    - id: keySize\n      type: System.Int32\n      description: The size of the key, in bits, to derive.\n    - id: rgbIV\n      type: System.Byte[]\n      description: The initialization vector (IV) to use to derive the key.\n    return:\n      type: System.Byte[]\n      description: The derived key.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*\n  exceptions:\n  - type: System.Security.Cryptography.CryptographicException\n    commentId: T:System.Security.Cryptography.CryptographicException\n    description: \"The <code>keySize</code> parameter is incorrect.  \\n  \\n -or-  \\n  \\n The cryptographic service provider (CSP) cannot be acquired.  \\n  \\n -or-  \\n  \\n The <code>algname</code> parameter is not a valid algorithm name.  \\n  \\n -or-  \\n  \\n The <code>alghashname</code> parameter is not a valid hash algorithm name.\"\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Releases the unmanaged resources used by the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\"></xref> class and optionally releases the managed resources.\n  remarks: \"This method is called by the public `Dispose()` method and the `Finalize` method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. `Finalize` invokes `Dispose` with `disposing` set to `false`.  \\n  \\n When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.Rfc2898DeriveBytes> references. This method invokes the `Dispose()` method of each referenced object.\"\n  syntax:\n    content: protected override void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> to release both managed and unmanaged resources; <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref> to release only unmanaged resources.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\n  id: GetBytes(System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: GetBytes(Int32)\n  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Returns the pseudo-random key for this object.\n  remarks: The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class implements PBKDF2 functionality by using a pseudorandom number generator based on <xref:System.Security.Cryptography.HMACSHA1>. The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class takes a password, a salt, and an iteration count, and then generates keys through calls to the GetBytes method. Repeated calls to this method will not generate the same key; instead, appending two calls of the GetBytes method with a `cb` parameter value of `20` is the equivalent of calling the GetBytes method once with a `cb` parameter value of `40`.\n  example:\n  - \"The following example shows how to use the GetBytes method to get the key for an instance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \\n  \\n [!code-cs[rfc28981#2](~/add/codesnippet/csharp/m-system.security.crypto_127_1.cs)]\\n [!code-vb[rfc28981#2](~/add/codesnippet/visualbasic/m-system.security.crypto_127_1.vb)]\\n [!code-cpp[rfc28981#2](~/add/codesnippet/cpp/m-system.security.crypto_127_1.cpp)]\"\n  syntax:\n    content: public override byte[] GetBytes (int cb);\n    parameters:\n    - id: cb\n      type: System.Int32\n      description: The number of pseudo-random key bytes to generate.\n    return:\n      type: System.Byte[]\n      description: A byte array filled with pseudo-random key bytes.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>cb </code>is out of range. This parameter requires a non-negative number.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\n  id: IterationCount\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: IterationCount\n  nameWithType: Rfc2898DeriveBytes.IterationCount\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Gets or sets the number of iterations for the operation.\n  remarks: Iteration count is the number of times an operation is performed. For this method, the count should be greater than zero. The minimum recommended number of iterations is 1000.\n  example:\n  - \"The following example shows how to use the IterationCount property to display the number of iterations used in the generation of the key. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \\n  \\n [!code-cs[rfc28981#3](~/add/codesnippet/csharp/p-system.security.crypto_117_1.cs)]\\n [!code-vb[rfc28981#3](~/add/codesnippet/visualbasic/p-system.security.crypto_117_1.vb)]\\n [!code-cpp[rfc28981#3](~/add/codesnippet/cpp/p-system.security.crypto_117_1.cpp)]\"\n  syntax:\n    content: public int IterationCount { get; set; }\n    return:\n      type: System.Int32\n      description: The number of iterations for the operation.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The number of iterations is less than 1.\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset\n  id: Reset\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Reset()\n  nameWithType: Rfc2898DeriveBytes.Reset()\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Resets the state of the operation.\n  remarks: This method is automatically called if the salt or iteration count is modified.\n  example:\n  - \"The following example shows how to use the Reset method. This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.  \\n  \\n [!code-cs[rfc28981#5](~/add/codesnippet/csharp/m-system.security.crypto_26_1.cs)]\\n [!code-vb[rfc28981#5](~/add/codesnippet/visualbasic/m-system.security.crypto_26_1.vb)]\\n [!code-cpp[rfc28981#5](~/add/codesnippet/cpp/m-system.security.crypto_26_1.cpp)]\"\n  syntax:\n    content: public override void Reset ();\n    parameters: []\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*\n  exceptions: []\n  platform:\n  - net462\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt\n  id: Salt\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  langs:\n  - csharp\n  name: Salt\n  nameWithType: Rfc2898DeriveBytes.Salt\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt\n  type: Property\n  assemblies:\n  - mscorlib\n  namespace: System.Security.Cryptography\n  summary: Gets or sets the key salt value for the operation.\n  remarks: Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult. A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys. This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.\n  syntax:\n    content: public byte[] Salt { get; set; }\n    return:\n      type: System.Byte[]\n      description: The key salt value for the operation.\n  overload: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The specified salt size is smaller than 8 bytes.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The salt is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.\n  platform:\n  - net462\nreferences:\n- uid: System.Security.Cryptography.DeriveBytes\n  isExternal: false\n  name: System.Security.Cryptography.DeriveBytes\n- uid: System.ArgumentException\n  isExternal: true\n  name: System.ArgumentException\n- uid: System.ArgumentNullException\n  isExternal: true\n  name: System.ArgumentNullException\n- uid: System.ArgumentOutOfRangeException\n  isExternal: true\n  name: System.ArgumentOutOfRangeException\n- uid: System.Security.Cryptography.CryptographicException\n  parent: System.Security.Cryptography\n  isExternal: false\n  name: CryptographicException\n  nameWithType: CryptographicException\n  fullName: System.Security.Cryptography.CryptographicException\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes(String,Byte[])\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[])\n- uid: System.String\n  parent: System\n  isExternal: true\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Byte[]\n  parent: System\n  isExternal: true\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: Byte[]\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes(String,Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: true\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(Byte[],Byte[],Int32)\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes(String,Byte[],Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Byte[],Int32)\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes(String,Int32,Int32)\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(String,Int32,Int32)\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: CryptDeriveKey(String,String,Int32,Byte[])\n  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(String,String,Int32,Byte[])\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: Rfc2898DeriveBytes.Dispose(Boolean)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: true\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: GetBytes(Int32)\n  nameWithType: Rfc2898DeriveBytes.GetBytes(Int32)\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(Int32)\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: IterationCount\n  nameWithType: Rfc2898DeriveBytes.IterationCount\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Reset()\n  nameWithType: Rfc2898DeriveBytes.Reset()\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Salt\n  nameWithType: Rfc2898DeriveBytes.Salt\n  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Rfc2898DeriveBytes\n  nameWithType: Rfc2898DeriveBytes.Rfc2898DeriveBytes\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: CryptDeriveKey\n  nameWithType: Rfc2898DeriveBytes.CryptDeriveKey\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Dispose\n  nameWithType: Rfc2898DeriveBytes.Dispose\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: GetBytes\n  nameWithType: Rfc2898DeriveBytes.GetBytes\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: IterationCount\n  nameWithType: Rfc2898DeriveBytes.IterationCount\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Reset\n  nameWithType: Rfc2898DeriveBytes.Reset\n- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt*\n  parent: System.Security.Cryptography.Rfc2898DeriveBytes\n  isExternal: false\n  name: Salt\n  nameWithType: Rfc2898DeriveBytes.Salt\n"}